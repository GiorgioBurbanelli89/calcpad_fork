@{code}
@{html-ifc}
<!DOCTYPE html>
<html lang="en"><head>
    <title>Created with Calcpad</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <script src="https://calcpad.local/jquery-3.6.3.min.js"></script>
    <style>
        body {
            font-size: 10.5pt;
            font-family: 'Segoe UI', 'Arial Nova', Helvetica, sans-serif;
            margin-left: 5mm;
            max-width: 190mm;
        }

        h1, h2, h3, h4, h5, h6, .errorHeader, .roundBox {
            font-family: 'Arial Nova', Helvetica, sans-serif;
            margin: 0.5em 0 0.5em 0;
            padding: 0;
            line-height: 150%;
        }

        h1 {font-size: 2.1em;}
        h2 {font-size: 1.7em;}
        h3 {font-size: 1.4em;}
        h4 {font-size: 1.2em;}
        h5 {font-size: 1.1em;}
        h6 {font-size: 1em;}

        p, li {
            margin: 0.05em 0 0.05em 0;
            padding: 0;
            line-height: 120%;
        }

        select, kbd {
            font-family: 'Segoe UI', sans-serif;
        }

        a:hover {
            background-color: #e9f6ff;
        }

        .eq, input[type="text"], table.matrix {
            font-family: 'Georgia Pro', 'Century Schoolbook', 'Times New Roman', Times, serif;
        }

            .eq var {
                color: #06d;
                font-size: 105%;
            }

            .eq i {
                color: #086;
                font-style: normal;
                font-size: 90%;
            }

            i.unit {
                color: #043!important;
                font-size: 90%!important;
                vertical-align: -1pt;
            }

            sup.unit {
                font-family: Calibri, Candara, Corbel, sans-serif;
                font-size: 70%!important;
            }

            .eq b {
                font-weight: 600;
            }

            .eq sub {
                font-family: Calibri, Candara, Corbel, sans-serif;
                font-size: 80%;
                vertical-align: -18%;
                margin-left: 1pt;
            }

            .eq sup {
                display: inline-block;
                margin-left: 1pt;
                margin-top: -3pt;
                font-size: 75%;
            }

            .eq small {
                font-family: Calibri, Candara, Corbel, sans-serif;
                font-size: 70%;
            }

                .eq small var {
                    font-family: 'Georgia Pro', 'Century Schoolbook', 'Times New Roman', Times, serif;
                    font-size: 8.5pt;
                }

                .eq small i {
                    font-family: 'Georgia Pro', 'Century Schoolbook', 'Times New Roman', Times, serif;
                    font-size: 6pt;
                }

            .eq u, input, select {
                background-color: LightYellow;
            }

                input[type="text"], select {
                    font-size: 10pt;
                    padding: 0.2em 0.4em;
                    border: 0.5pt solid #CCC;
                    border-radius: 0.35em;
                    box-shadow: 0.06em 0.06em 0.5em #ddd;
                    min-width: 3em;
                }

                input[type="text"] {
                    text-align: right;
                }

                input[type="checkbox"],
                input[type="radio"] {
                    vertical-align: baseline;
                    position: relative;
                    bottom: -1pt;
                    margin-right: 1pt;
                }

                    input[type="checkbox"].post:disabled:not(:checked),
                    input[type="checkbox"].post:disabled:not(:checked) + label,
                    input[type="radio"].post:disabled:not(:checked),
                    input[type="radio"].post:disabled:not(:checked) + label {
                        display: none;
                    }

                select:disabled {
                    background: none;
                    color: #444;
                }

                select.post:disabled {
                    font-size: 12pt;
                    border: none;
                    box-shadow: none;
                    color: red;
                    background: none;
                    appearance: none;
                    -webkit-appearance: none;
                    -moz-appearance: none;
                }

                select.post:disabled::-ms-expand {
                    display: none;
                }

                input[type="text"]:focus {
                    box-shadow: 0.1em 0.1em 1em #ccc;
                    color: black;
                }

        td, th {
            padding: 2pt 4pt 2pt 4pt;
            vertical-align: top;
        }

        small {
            font-weight: normal;
        }

        table {
            border-collapse: collapse;
        }

            table.bordered {
                margin-top: 1em;
            }

                table.bordered th {
                    background-color: #F0F0F0;
                    border: solid 1pt #AAAAAA;
                }

                table.bordered td {
                    border: solid 1pt #CCCCCC;
                }

            table.centered td, .matrix .td {
                text-align: center;
            }

            table.data td {
                text-align: right;
            }

                table.data td:first-child {
                    text-align: left;
                    padding-left: 0;
                }

        .matrix {
            display: inline-table;
        }

            .matrix .tr {
                display: table-row;
            }

            .matrix .td {
                white-space: nowrap;
                padding: 0 2pt 0 2pt;
                min-width: 10pt;
                display: table-cell;
                font-size: 10pt;
            }

                .matrix .td:first-child,
                .matrix .td:last-child {
                    width: 0.75pt;
                    min-width: 0.75pt;
                    max-width: 0.75pt;
                    padding: 0 1pt 0 1pt;
                }

                .matrix .td:first-child {
                    border-left: solid 1pt black;
                }

                .matrix .td:last-child {
                    border-right: solid 1pt black;
                }

            .matrix .tr:first-child .td:first-child,
            .matrix .tr:first-child .td:last-child {
                border-top: solid 1pt black;
            }

            .matrix .tr:last-child .td:first-child,
            .matrix .tr:last-child .td:last-child {
                border-bottom: solid 1pt black;
            }

        .block {
            display: inline-block;
            vertical-align: middle;
            padding-left: 4pt;
            margin-left: -1pt;
            border-left: solid 1pt #80b0e8;
            background: linear-gradient(to right, rgba(0, 192, 255, 0.06), rgba(0, 192, 255, 0.03));
        }

            .block .block {
                background: linear-gradient(to right, rgba(0, 192, 255, 0.04), rgba(0, 192, 255, 0.02));
            }

        .dvcs:has(.block):not(.block *) {
            display: inline-block;
            border-left: solid 1pt #80b0e8;
            padding-left: 0;
            margin-left: 3pt;
        }

            .dvcs:has(.block):not(.block *)::before {
                content: " ðŸž€";
                font-size: 9pt;
                color: #90c4f0;
                margin-left: -4.5pt;
            }

        .arr {
            color: #90c4f0;
        }

        .r0, .r1, .r2, .r3,
        .o0, .o1, .o2, .o3,
        .b1, .b2, .b3,
        .c1, .c2, .c3, .c4,
        .c5, .c6, .c7, .c8 {
            display: inline-block;
        }

        .r0, .r1, .r2, .r3 {
            margin-top: -1.5pt;
            margin-right: 1.5pt;
            vertical-align: top;
            background-repeat: no-repeat;
            background-size: cover;
            background-position: right top;
        }

        .o0, .o1, .o2, .o3 {
            border-top: solid 0.75pt;
            line-height: 130%;
            vertical-align: middle;
            margin-top: 0.75pt;
            padding-top: 1.25pt;
            padding-left: 1pt;
            padding-right: 1pt;
        }

        .r {
            font-family: 'Times New Roman', Times, serif;
            font-size: 150%;
            display: inline-block;
            vertical-align: top;
            margin-left: -9.5pt;
            position: relative;
            top: 1pt;
        }

        .r0 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwIDIwIiBoZWlnaHQ9IjE1cHQiIHdpZHRoPSIxMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMCwxMyAyLDEyIDUsMTkgOSwwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC42cHQ7IHN0cm9rZS1saW5lam9pbjpyb3VuZDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IGZpbGw6bm9uZSIgLz4NCiAgPGxpbmUgeDE9IjIuMiIgeTE9IjEyLjMiIHgyPSI0LjYiIHkyPSIxOC43IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC44cHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 8pt;
            height: 16pt;
            margin-left: -8pt;
        }

        .r1 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE1IDQwIiBoZWlnaHQ9IjMwcHQiIHdpZHRoPSIxNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMSwyNiAzLDI0IDgsMzggMTQsMCIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjAuNnB0OyBzdHJva2UtbGluZWpvaW46cm91bmQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyBmaWxsOm5vbmUiIC8+DQogIDxsaW5lIHgxPSIzLjIiIHkxPSIyNC40IiB4Mj0iNy42IiB5Mj0iMzcuNiIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjFwdDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IiAvPg0KPC9zdmc+");
            width: 12pt;
            height: 32pt;
            margin-left: -12pt;
        }

        .r2 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDIwIDYwIiBoZWlnaHQ9IjQ1cHQiIHdpZHRoPSIyMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMiwzNyA1LDM0IDExLDU1IDE5LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNS4xIiB5MT0iMzQuNiIgeDI9IjEwLjYiIHkyPSI1NC40IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 16pt;
            height: 48pt;
            margin-left: -16pt;
        }

        .r3 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI1IDgwIiBoZWlnaHQ9IjYwcHQiIHdpZHRoPSIyNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMyw1MCA3LDQ2IDE1LDc0IDI0LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNy4xIiB5MT0iNDYuOCIgeDI9IjE0LjUiIHkyPSI3My4yIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 19pt;
            height: 62pt;
            margin-left: -19pt;
        }

        .nth {
            position: relative;
            bottom: 1pt;
        }

        .eq small.nth {font-size: 70%;}
        .dvr small {font-size: 65%;}
        sup.raised {vertical-align: top;}

        sup .r0, sup .r1, sup .r2, sup .r3 {
            zoom: 0.7;
            -moz-transform: scale(0.7);
            -webkit-transform: scale(0.7);
            transform: scale(0.7);
            transform-origin: top right;
            max-height: none;
        }

        sup .r0 { margin-left: -5pt; }
        sup .r1 { margin-left: -11pt; }
        sup .r2 { margin-left: -13pt; }
        sup .r3 { margin-left: -16pt; }

        .b1, .b2, .b3, .c1, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {
            vertical-align: middle;
            font-weight: 100;
            font-stretch: ultra-condensed;
        }

        .b2, .b3, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {
            font-family: 'Jost* Hairline', sans-serif;
        }

        .b0, .b1, .c1 {
            font-family: 'Jost* Thin', sans-serif;
        }

        .b0 {
            font-size: 120%;
            font-weight: 600;
            padding: 0 1pt 0 1pt;
        }

        .b1 {
            font-size: 240%;
            margin-top: -3pt;
            margin-left: -1pt;
            margin-right: -1pt;
        }

        .b2 {
            font-size: 370%;
            margin-top: -5pt;
            margin-left: -3pt;
            margin-right: -3pt;
        }

        .b3 {
            font-size: 520%;
            margin-top: -8pt;
            margin-left: -5pt;
            margin-right: -5pt;
        }

        .c1 {
            font-size: 240%;
            margin-top: -4pt;
        }

        .c2 {
            font-size: 360%;
            margin-top: -6pt;
            margin-left: -2.5pt;
            margin-right: -0.5pt;
        }

        .c3 {
            font-size: 480%;
            margin-top: -8pt;
            margin-left: -3pt;
            margin-right: -1pt;
        }

        .c4 {
            font-size: 600%;
            margin-top: -10pt;
            margin-left: -4pt;
            margin-right: -2pt;
            transform: scaleX(0.9);
        }

        .c5 {
            font-size: 710%;
            margin-top: -11.5pt;
            margin-left: -6pt;
            margin-right: -4pt;
            transform: scaleX(0.8);
        }

        .c6 {
            font-size: 820%;
            margin-top: -13pt;
            margin-left: -7pt;
            margin-right: -5pt;
            transform: scaleX(0.7);
        }

        .c7 {
            font-size: 930%;
            margin-top: -14.5pt;
            margin-left: -8pt;
            margin-right: -6pt;
            transform: scaleX(0.6);
        }

        .c8 {
            font-size: 1040%;
            margin-top: -16pt;
            margin-left: -9pt;
            margin-right: -7pt;
            transform: scaleX(0.5);
        }

        .dvc, .dvr, .dvs {
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
        }

        .dvc {
            padding-left: 2pt;
            padding-right: 2pt;
            text-align: center;
            line-height: 110%;
        }

        .dvr {
            text-align: center;
            line-height: 110%;
            margin-bottom: 4pt;
        }

        .dvs {
            text-align: left;
            line-height: 110%;
        }

        .dvl {
            display: block;
            border-bottom: solid 1pt black;
            margin-top: 1pt;
            margin-bottom: 1pt;
        }

        .nary {
            color: #C080F0;
            font-size: 240%;
            font-family: Georgia Pro Light, serif;
            font-weight: 200;
            line-height: 80%;
            display: block;
            margin: -1pt 1pt 3pt 1pt;
        }

            .nary em {
                display: block;
                transform: scaleX(0.7) rotate(7deg);
            }

        .dvc.down {
            position: relative;
            top: 0.5em;
        }

        .dvc.up {
            position: relative;
            bottom: 0.6em;
        }

        .low {
            font-size: 70%;
            display: inline-block;
            position: relative;
            top: 1.2em;
        }

        .cond {
            color: #E000D0;
        }

        .err {
            color: Crimson;
            background-color: #FEE;
        }

        .ok {
            color: Green;
            background-color: #F0FFF0;
        }

        .ref {
            float: right;
            margin-left: 18pt;
            color: Green;
            background-color: #F8FFF0;
            margin-top: 0;
            margin-bottom: 0;
        }

        .side {
            float: right;
            max-width: 50%;
        }

        .plot {
            max-width: 100%
        }

        .indent {
            border-left: 0.75pt solid #dddddd;
            padding-left: 2em;
        }

        span.indent {
            display: inline-block;
        }

        .fold {
            height: 2.4em;
            overflow: hidden;
        }

        .unfold {
            height: auto;
            overflow: auto;
        }

            .fold > :first-child, .unfold > :first-child {
                cursor: pointer;
            }

                .fold > :first-child:hover, .unfold > :first-child:hover {
                    color: #0066bb;
                    text-decoration: underline;
                }

                .fold > :first-child::after {
                    content: " ... â–¼";
                    font-size: 80%;
                }

                .unfold > :first-child::after {
                    content: " â–²";
                    font-size: 80%;
                }

        .vec {
            font-family: 'Cambria Math', serif;
            color: #8af;
            font-style: normal;
            display: inline-block;
            vertical-align: 2pt;
            margin-left: 3pt;
            margin-right: -7pt;
        }

        small .vec, sup .vec {
            margin-left: 2pt;
            margin-right: -6pt;
        }

        #Units {
            float: right;
        }

        @media screen {
            .no-screen {
                display: none;
            }
        }

        @media print {
            .side {
                zoom: 0.8;
                -moz-transform: scale(0.8);
            }

            body {
                margin: 0;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .no-print {
                display: none;
            }
        }

        @page {
            size: A4 portrait;
            margin-left: 20mm;
            margin-right: 10mm;
            margin-top: 10mm;
            margin-bottom: 10mm;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }

        .value {
            position: relative;
            background-color: #f4fbff;
            border-radius: 3pt;
        }

            .value:after {
                content: "";
                position: absolute;
                left: 100%;
                top: -100%;
                transform: translateY(-50%);
                margin-left: 2pt;
                height: 16pt;
                line-height: 16pt;
                vertical-align: middle;
                width: fit-content;
                white-space: nowrap;
                min-width: 10pt;
                z-index: 1;
                padding: 0 6pt 0 6pt;
                border-radius: 6pt 6pt 6pt 0;
                background: #000;
                color: #fff;
                font-family: 'Segoe UI', sans-serif;
                font-style: normal;
                font-size: 10pt;
                text-align: center;
                display: none;
                opacity: 0;
                transition: opacity 2s;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                -moz-user-select: none;
            }

            .value:hover:after {
                content: attr(data-value);
                display: block;
                opacity: 1;
            }

        .errorHeader {
            color: white;
            background-color: crimson;
            font-size: 10pt;
            position: fixed;
            top: 0;
            left: 0;
            margin-top: 0;
            width: 100vw;
            max-width: 100%;
            height: 1.8em;
            line-height: 1.2em;
            padding-left: 6pt;
            overflow-x: hidden;
        }

        .roundBox {
            background-color: #fee;
            color: crimson;
            font-size: 9pt;
            font-weight: bold;
            text-decoration: none;
            text-align: center;
            cursor: pointer;
            display: inline-block;
            border-radius: 4pt;
            min-width: 1.1em;
            padding-left: 2pt;
            padding-right: 2pt;
            margin-top: 2pt;
        }

            .roundBox:hover {
                background-color: white;
            }

        .lineLink {
            background: none;
            color: #b0e0ff;
            font-family: Calibri, sans-serif;
            font-size: 10pt;
            font-weight: bold;
            text-decoration: none;
            text-align: left;
            display: inline-block;
            position: absolute;
            left: 0;
            width: 2em;
            height: 4em;
            z-index: 1;
        }

            .lineLink:hover {
                background: none;
                color: #09e;
            }
    </style>
</head>
<body>
    <script>
        var contextMenu = false;
        function getVerticalPosition(line) { return document.querySelector("[data-text='" + line + "']").getBoundingClientRect().top; }
        function isNumeric(s) { return s.match(/^-?\d+(?:\.\d+)?$/); }
        if (window.jQuery) {
            function getHtmlWithInput() {
                $("input[type=text]").each(function () {
                    $(this).attr("value", $(this).val());
                });
                $("input[type=hidden]").each(function () {
                    $(this).attr("value", $(this).val());
                });
                $("textarea").each(function () {
                    $(this).html($(this).val());
                });
                $("input[type=radio]").each(function () {
                    if (this.checked)
                        $(this).attr("checked", "checked");
                    else
                        $(this).removeAttr("checked");
                });
                $("input[type=checkbox]").each(function () {
                    if (this.checked)
                        $(this).attr("checked", "checked");
                    else
                        $(this).removeAttr("checked");
                });
                $("select option").each(function () {
                    if (this.selected) {
                        $(this).attr("selected", "true");
                    }
                    else
                        $(this).removeAttr("selected");
                });
                return document.body.outerHTML;
            }

            function getTargetId(element) {
                var id = $(element).attr("name");
                if (id != null && id.length > 0)
                    return id;

                return $(element).data("target");
            }

            function getValue(id, source) {
                var value = "";
                var target = $("#" + id + " input");
                var domObj = target.get(0);
                if (domObj == null || domObj.Length == 0) {
                    target = $("#" + id + " .eq u");
                    target.each(function () {
                        value += $(this).text() + ";";
                    });
                    $(source).prop('disabled', true);
                }
                else {
                    target.each(function () {
                        value += $(this).val() + ";";
                    });
                }
                if (value.length > 1) {
                    value = value.slice(0, -1);
                }
                return value;
            }

            $(document).ready(function () {

                $(".dvcs:has(.block) > :first-child").html("&hairsp;");

                $("#Units").change(function () { $(".Units").text($(this).val()); });

                $(".fold > :first-child").click(function () {
                    if ($(this).parent().hasClass("fold")) {
                        $(this).parent().removeClass("fold").addClass("unfold");
                    }
                    else {
                        $(this).parent().removeClass("unfold").addClass("fold");
                    }
                });

                $("select").each(function (index) {
                    if ($(this).prop("id") != "Units") {
                        var id = getTargetId(this);
                        if (id != null && id.length > 0) {
                            var value = getValue(id, this);
                            $(this).val(value);
                        }
                    }

                });

                $("select").change(function () {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var target = $("#" + id + " input");
                        if (target != null) {
                            var values = $(this).val().split(";");
                            target.each(function (index) {
                                $(this).val(values[index]);
                            });
                        }
                    }
                });

                $("input:radio, input:checkbox").each(function (index) {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var value = getValue(id, this);
                        $(this).prop("checked", $(this).val() == value);
                    }
                });

                $("input:radio, input:checkbox").change(function () {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var target = $("#" + id + " input");
                        if (target != null) {
                            if ($(this).prop("checked")) {
                                var values = $(this).val().split(";");
                                target.each(function (index) {
                                    $(this).val(values[index]);
                                });
                            }
                            else if ($(this).prop("type") == "checkbox") {
                                target.each(function () {
                                    $(this).val("0");
                                });
                            }
                        }
                    }
                });

                $(".line:not(style, script)").each(function () {
                    var line = $(this).prop("id").split("-")[1];
                    var $lineLink = $('<a class="lineLink" href="#0" data-text="' + line + '" title="Code line ' + line + '">&larr;</a>');
                    $(this).append($lineLink);
                    $lineLink.hide();
                    $(this).hover(function () {
                        $(".lineLink").hide();
                        $lineLink.show();
                    });
                    $(window).scroll(function () {
                        $lineLink.hide();
                    });
                });

                $("body").mouseleave(function () {
                    $(".lineLink").hide();
                });

                $(".roundBox").click(function () {
                    var line = $(this).data("line");
                    var e = document.getElementById("line-" + line);
                    if (e) {
                        window.scrollTo(0, e.offsetTop - $(this).outerHeight() - 20);
                    }
                });
                $(".money").each(function () { $(this).text(Number(($(this).text())).toFixed(2)); });

                $("input").change(function() {
                    var e = $(this);
                    var s = e.val();
                    if (isNumeric(s)) {
                        e.css("color", "black");
                        e.removeAttr("title");
                    } else {
                        e.css("color", "red");
                        e.attr("title", "Invalid number");
                    }
                });

                $("a").click(function () {
                    chrome.webview.postMessage('clicked');
                });

                window.addEventListener('click', () => {
                    chrome.webview.postMessage('focused');
                });
            });
        }
        document.oncontextmenu = function () { contextMenu = true; };
        document.onmousedown = function () { contextMenu = false; };
    </script><style>

        body {

            font-size: 10.5pt;

            font-family: 'Segoe UI', 'Arial Nova', Helvetica, sans-serif;

            margin-left: 5mm;

            max-width: 190mm;

        }

        h1, h2, h3, h4, h5, h6, .errorHeader, .roundBox {

            font-family: 'Arial Nova', Helvetica, sans-serif;

            margin: 0.5em 0 0.5em 0;

            padding: 0;

            line-height: 150%;

        }

        h1 {font-size: 2.1em;}

        h2 {font-size: 1.7em;}

        h3 {font-size: 1.4em;}

        h4 {font-size: 1.2em;}

        h5 {font-size: 1.1em;}

        h6 {font-size: 1em;}

        p, li {

            margin: 0.05em 0 0.05em 0;

            padding: 0;

            line-height: 120%;

        }

        select, kbd {

            font-family: 'Segoe UI', sans-serif;

        }

        a:hover {

            background-color: #e9f6ff;

        }

        .eq, input[type="text"], table.matrix {

            font-family: 'Georgia Pro', 'Century Schoolbook', 'Times New Roman', Times, serif;

        }

            .eq var {

                color: #06d;

                font-size: 105%;

            }

            .eq i {

                color: #086;

                font-style: normal;

                font-size: 90%;

            }

            i.unit {

                color: #043!important;

                font-size: 90%!important;

                vertical-align: -1pt;

            }

            sup.unit {

                font-family: Calibri, Candara, Corbel, sans-serif;

                font-size: 70%!important;

            }

            .eq b {

                font-weight: 600;

            }

            .eq sub {

                font-family: Calibri, Candara, Corbel, sans-serif;

                font-size: 80%;

                vertical-align: -18%;

                margin-left: 1pt;

            }

            .eq sup {

                display: inline-block;

                margin-left: 1pt;

                margin-top: -3pt;

                font-size: 75%;

            }

            .eq small {

                font-family: Calibri, Candara, Corbel, sans-serif;

                font-size: 70%;

            }

                .eq small var {

                    font-family: 'Georgia Pro', 'Century Schoolbook', 'Times New Roman', Times, serif;

                    font-size: 8.5pt;

                }

                .eq small i {

                    font-family: 'Georgia Pro', 'Century Schoolbook', 'Times New Roman', Times, serif;

                    font-size: 6pt;

                }

            .eq u, input, select {

                background-color: LightYellow;

            }

                input[type="text"], select {

                    font-size: 10pt;

                    padding: 0.2em 0.4em;

                    border: 0.5pt solid #CCC;

                    border-radius: 0.35em;

                    box-shadow: 0.06em 0.06em 0.5em #ddd;

                    min-width: 3em;

                }

                input[type="text"] {

                    text-align: right;

                }

                input[type="checkbox"],

                input[type="radio"] {

                    vertical-align: baseline;

                    position: relative;

                    bottom: -1pt;

                    margin-right: 1pt;

                }

                    input[type="checkbox"].post:disabled:not(:checked),

                    input[type="checkbox"].post:disabled:not(:checked) + label,

                    input[type="radio"].post:disabled:not(:checked),

                    input[type="radio"].post:disabled:not(:checked) + label {

                        display: none;

                    }

                select:disabled {

                    background: none;

                    color: #444;

                }

                select.post:disabled {

                    font-size: 12pt;

                    border: none;

                    box-shadow: none;

                    color: red;

                    background: none;

                    appearance: none;

                    -webkit-appearance: none;

                    -moz-appearance: none;

                }

                select.post:disabled::-ms-expand {

                    display: none;

                }

                input[type="text"]:focus {

                    box-shadow: 0.1em 0.1em 1em #ccc;

                    color: black;

                }

        td, th {

            padding: 2pt 4pt 2pt 4pt;

            vertical-align: top;

        }

        small {

            font-weight: normal;

        }

        table {

            border-collapse: collapse;

        }

            table.bordered {

                margin-top: 1em;

            }

                table.bordered th {

                    background-color: #F0F0F0;

                    border: solid 1pt #AAAAAA;

                }

                table.bordered td {

                    border: solid 1pt #CCCCCC;

                }

            table.centered td, .matrix .td {

                text-align: center;

            }

            table.data td {

                text-align: right;

            }

                table.data td:first-child {

                    text-align: left;

                    padding-left: 0;

                }

        .matrix {

            display: inline-table;

        }

            .matrix .tr {

                display: table-row;

            }

            .matrix .td {

                white-space: nowrap;

                padding: 0 2pt 0 2pt;

                min-width: 10pt;

                display: table-cell;

                font-size: 10pt;

            }

                .matrix .td:first-child,

                .matrix .td:last-child {

                    width: 0.75pt;

                    min-width: 0.75pt;

                    max-width: 0.75pt;

                    padding: 0 1pt 0 1pt;

                }

                .matrix .td:first-child {

                    border-left: solid 1pt black;

                }

                .matrix .td:last-child {

                    border-right: solid 1pt black;

                }

            .matrix .tr:first-child .td:first-child,

            .matrix .tr:first-child .td:last-child {

                border-top: solid 1pt black;

            }

            .matrix .tr:last-child .td:first-child,

            .matrix .tr:last-child .td:last-child {

                border-bottom: solid 1pt black;

            }

        .block {

            display: inline-block;

            vertical-align: middle;

            padding-left: 4pt;

            margin-left: -1pt;

            border-left: solid 1pt #80b0e8;

            background: linear-gradient(to right, rgba(0, 192, 255, 0.06), rgba(0, 192, 255, 0.03));

        }

            .block .block {

                background: linear-gradient(to right, rgba(0, 192, 255, 0.04), rgba(0, 192, 255, 0.02));

            }

        .dvcs:has(.block):not(.block *) {

            display: inline-block;

            border-left: solid 1pt #80b0e8;

            padding-left: 0;

            margin-left: 3pt;

        }

            .dvcs:has(.block):not(.block *)::before {

                content: " ðŸž€";

                font-size: 9pt;

                color: #90c4f0;

                margin-left: -4.5pt;

            }

        .arr {

            color: #90c4f0;

        }

        .r0, .r1, .r2, .r3,

        .o0, .o1, .o2, .o3,

        .b1, .b2, .b3,

        .c1, .c2, .c3, .c4,

        .c5, .c6, .c7, .c8 {

            display: inline-block;

        }

        .r0, .r1, .r2, .r3 {

            margin-top: -1.5pt;

            margin-right: 1.5pt;

            vertical-align: top;

            background-repeat: no-repeat;

            background-size: cover;

            background-position: right top;

        }

        .o0, .o1, .o2, .o3 {

            border-top: solid 0.75pt;

            line-height: 130%;

            vertical-align: middle;

            margin-top: 0.75pt;

            padding-top: 1.25pt;

            padding-left: 1pt;

            padding-right: 1pt;

        }

        .r {

            font-family: 'Times New Roman', Times, serif;

            font-size: 150%;

            display: inline-block;

            vertical-align: top;

            margin-left: -9.5pt;

            position: relative;

            top: 1pt;

        }

        .r0 {

            content: "";

            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwIDIwIiBoZWlnaHQ9IjE1cHQiIHdpZHRoPSIxMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMCwxMyAyLDEyIDUsMTkgOSwwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC42cHQ7IHN0cm9rZS1saW5lam9pbjpyb3VuZDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IGZpbGw6bm9uZSIgLz4NCiAgPGxpbmUgeDE9IjIuMiIgeTE9IjEyLjMiIHgyPSI0LjYiIHkyPSIxOC43IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC44cHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");

            width: 8pt;

            height: 16pt;

            margin-left: -8pt;

        }

        .r1 {

            content: "";

            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE1IDQwIiBoZWlnaHQ9IjMwcHQiIHdpZHRoPSIxNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMSwyNiAzLDI0IDgsMzggMTQsMCIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjAuNnB0OyBzdHJva2UtbGluZWpvaW46cm91bmQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyBmaWxsOm5vbmUiIC8+DQogIDxsaW5lIHgxPSIzLjIiIHkxPSIyNC40IiB4Mj0iNy42IiB5Mj0iMzcuNiIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjFwdDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IiAvPg0KPC9zdmc+");

            width: 12pt;

            height: 32pt;

            margin-left: -12pt;

        }

        .r2 {

            content: "";

            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDIwIDYwIiBoZWlnaHQ9IjQ1cHQiIHdpZHRoPSIyMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMiwzNyA1LDM0IDExLDU1IDE5LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNS4xIiB5MT0iMzQuNiIgeDI9IjEwLjYiIHkyPSI1NC40IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");

            width: 16pt;

            height: 48pt;

            margin-left: -16pt;

        }

        .r3 {

            content: "";

            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI1IDgwIiBoZWlnaHQ9IjYwcHQiIHdpZHRoPSIyNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMyw1MCA3LDQ2IDE1LDc0IDI0LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNy4xIiB5MT0iNDYuOCIgeDI9IjE0LjUiIHkyPSI3My4yIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");

            width: 19pt;

            height: 62pt;

            margin-left: -19pt;

        }

        .nth {

            position: relative;

            bottom: 1pt;

        }

        .eq small.nth {font-size: 70%;}

        .dvr small {font-size: 65%;}

        sup.raised {vertical-align: top;}

        sup .r0, sup .r1, sup .r2, sup .r3 {

            zoom: 0.7;

            -moz-transform: scale(0.7);

            -webkit-transform: scale(0.7);

            transform: scale(0.7);

            transform-origin: top right;

            max-height: none;

        }

        sup .r0 { margin-left: -5pt; }

        sup .r1 { margin-left: -11pt; }

        sup .r2 { margin-left: -13pt; }

        sup .r3 { margin-left: -16pt; }

        .b1, .b2, .b3, .c1, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {

            vertical-align: middle;

            font-weight: 100;

            font-stretch: ultra-condensed;

        }

        .b2, .b3, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {

            font-family: 'Jost* Hairline', sans-serif;

        }

        .b0, .b1, .c1 {

            font-family: 'Jost* Thin', sans-serif;

        }

        .b0 {

            font-size: 120%;

            font-weight: 600;

            padding: 0 1pt 0 1pt;

        }

        .b1 {

            font-size: 240%;

            margin-top: -3pt;

            margin-left: -1pt;

            margin-right: -1pt;

        }

        .b2 {

            font-size: 370%;

            margin-top: -5pt;

            margin-left: -3pt;

            margin-right: -3pt;

        }

        .b3 {

            font-size: 520%;

            margin-top: -8pt;

            margin-left: -5pt;

            margin-right: -5pt;

        }

        .c1 {

            font-size: 240%;

            margin-top: -4pt;

        }

        .c2 {

            font-size: 360%;

            margin-top: -6pt;

            margin-left: -2.5pt;

            margin-right: -0.5pt;

        }

        .c3 {

            font-size: 480%;

            margin-top: -8pt;

            margin-left: -3pt;

            margin-right: -1pt;

        }

        .c4 {

            font-size: 600%;

            margin-top: -10pt;

            margin-left: -4pt;

            margin-right: -2pt;

            transform: scaleX(0.9);

        }

        .c5 {

            font-size: 710%;

            margin-top: -11.5pt;

            margin-left: -6pt;

            margin-right: -4pt;

            transform: scaleX(0.8);

        }

        .c6 {

            font-size: 820%;

            margin-top: -13pt;

            margin-left: -7pt;

            margin-right: -5pt;

            transform: scaleX(0.7);

        }

        .c7 {

            font-size: 930%;

            margin-top: -14.5pt;

            margin-left: -8pt;

            margin-right: -6pt;

            transform: scaleX(0.6);

        }

        .c8 {

            font-size: 1040%;

            margin-top: -16pt;

            margin-left: -9pt;

            margin-right: -7pt;

            transform: scaleX(0.5);

        }

        .dvc, .dvr, .dvs {

            display: inline-block;

            vertical-align: middle;

            white-space: nowrap;

        }

        .dvc {

            padding-left: 2pt;

            padding-right: 2pt;

            text-align: center;

            line-height: 110%;

        }

        .dvr {

            text-align: center;

            line-height: 110%;

            margin-bottom: 4pt;

        }

        .dvs {

            text-align: left;

            line-height: 110%;

        }

        .dvl {

            display: block;

            border-bottom: solid 1pt black;

            margin-top: 1pt;

            margin-bottom: 1pt;

        }

        .nary {

            color: #C080F0;

            font-size: 240%;

            font-family: Georgia Pro Light, serif;

            font-weight: 200;

            line-height: 80%;

            display: block;

            margin: -1pt 1pt 3pt 1pt;

        }

            .nary em {

                display: block;

                transform: scaleX(0.7) rotate(7deg);

            }

        .dvc.down {

            position: relative;

            top: 0.5em;

        }

        .dvc.up {

            position: relative;

            bottom: 0.6em;

        }

        .low {

            font-size: 70%;

            display: inline-block;

            position: relative;

            top: 1.2em;

        }

        .cond {

            color: #E000D0;

        }

        .err {

            color: Crimson;

            background-color: #FEE;

        }

        .ok {

            color: Green;

            background-color: #F0FFF0;

        }

        .ref {

            float: right;

            margin-left: 18pt;

            color: Green;

            background-color: #F8FFF0;

            margin-top: 0;

            margin-bottom: 0;

        }

        .side {

            float: right;

            max-width: 50%;

        }

        .plot {

            max-width: 100%

        }

        .indent {

            border-left: 0.75pt solid #dddddd;

            padding-left: 2em;

        }

        span.indent {

            display: inline-block;

        }

        .fold {

            height: 2.4em;

            overflow: hidden;

        }

        .unfold {

            height: auto;

            overflow: auto;

        }

            .fold > :first-child, .unfold > :first-child {

                cursor: pointer;

            }

                .fold > :first-child:hover, .unfold > :first-child:hover {

                    color: #0066bb;

                    text-decoration: underline;

                }

                .fold > :first-child::after {

                    content: " ... â–¼";

                    font-size: 80%;

                }

                .unfold > :first-child::after {

                    content: " â–²";

                    font-size: 80%;

                }

        .vec {

            font-family: 'Cambria Math', serif;

            color: #8af;

            font-style: normal;

            display: inline-block;

            vertical-align: 2pt;

            margin-left: 3pt;

            margin-right: -7pt;

        }

        small .vec, sup .vec {

            margin-left: 2pt;

            margin-right: -6pt;

        }

        #Units {

            float: right;

        }

        @media screen {

            .no-screen {

                display: none;

            }

        }

        @media print {

            .side {

                zoom: 0.8;

                -moz-transform: scale(0.8);

            }

            body {

                margin: 0;

                -webkit-print-color-adjust: exact;

                print-color-adjust: exact;

            }

            .no-print {

                display: none;

            }

        }

        @page {

            size: A4 portrait;

            margin-left: 20mm;

            margin-right: 10mm;

            margin-top: 10mm;

            margin-bottom: 10mm;

            -webkit-print-color-adjust: exact;

            print-color-adjust: exact;

        }

        .value {

            position: relative;

            background-color: #f4fbff;

            border-radius: 3pt;

        }

            .value:after {

                content: "";

                position: absolute;

                left: 100%;

                top: -100%;

                transform: translateY(-50%);

                margin-left: 2pt;

                height: 16pt;

                line-height: 16pt;

                vertical-align: middle;

                width: fit-content;

                white-space: nowrap;

                min-width: 10pt;

                z-index: 1;

                padding: 0 6pt 0 6pt;

                border-radius: 6pt 6pt 6pt 0;

                background: #000;

                color: #fff;

                font-family: 'Segoe UI', sans-serif;

                font-style: normal;

                font-size: 10pt;

                text-align: center;

                display: none;

                opacity: 0;

                transition: opacity 2s;

                user-select: none;

                -webkit-user-select: none;

                -ms-user-select: none;

                -moz-user-select: none;

            }

            .value:hover:after {

                content: attr(data-value);

                display: block;

                opacity: 1;

            }

        .errorHeader {

            color: white;

            background-color: crimson;

            font-size: 10pt;

            position: fixed;

            top: 0;

            left: 0;

            margin-top: 0;

            width: 100vw;

            max-width: 100%;

            height: 1.8em;

            line-height: 1.2em;

            padding-left: 6pt;

            overflow-x: hidden;

        }

        .roundBox {

            background-color: #fee;

            color: crimson;

            font-size: 9pt;

            font-weight: bold;

            text-decoration: none;

            text-align: center;

            cursor: pointer;

            display: inline-block;

            border-radius: 4pt;

            min-width: 1.1em;

            padding-left: 2pt;

            padding-right: 2pt;

            margin-top: 2pt;

        }

            .roundBox:hover {

                background-color: white;

            }

        .lineLink {

            background: none;

            color: #b0e0ff;

            font-family: Calibri, sans-serif;

            font-size: 10pt;

            font-weight: bold;

            text-decoration: none;

            text-align: left;

            display: inline-block;

            position: absolute;

            left: 0;

            width: 2em;

            height: 4em;

            z-index: 1;

        }

            .lineLink:hover {

                background: none;

                color: #09e;

            }

    </style>
<style>

        /* ========== ESTILOS GENERALES - TEMA OSCURO ========== */

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {

            width: 100vw;

            height: 100vh;

            overflow: hidden;

            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

            background: #1a1a1a;

            color: #fff;

        }

        #ifc-viewer-main { width: 100%; height: 100%; position: relative; }

        #ifc-viewer-main-canvas { width: 100%; height: 100%; }

        @keyframes ifc-spin { to { transform: rotate(360deg); } }

        .progress-bar {

            width: 200px;

            height: 6px;

            background: #333;

            border-radius: 3px;

            margin-top: 10px;

            overflow: hidden;

        }

        .progress-bar-fill {

            height: 100%;

            background: #0078d4;

            width: 0%;

            transition: width 0.3s;

        }

        /* ========== TOOLBAR PRINCIPAL ========== */

        .toolbar {

            position: absolute;

            top: 8px;

            left: 10px;

            right: 10px;

            display: flex;

            justify-content: center;

            flex-wrap: wrap;

            gap: 4px;

            background: rgba(0,0,0,0.85);

            padding: 6px 10px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            z-index: 100;

        }

        .toolbar button {

            background: #2c3e50;

            color: #fff;

            border: 1px solid #444;

            border-radius: 4px;

            padding: 6px 12px;

            cursor: pointer;

            font-size: 11px;

            font-weight: 500;

            transition: all 0.2s;

        }

        .toolbar button:hover { background: #34495e; border-color: #0078d4; }

        .toolbar button.active { background: #0078d4; color: white; border-color: #0078d4; }

        .toolbar-separator { width: 1px; background: #555; margin: 0 4px; }

        /* ========== PANEL DE FILTROS ========== */

        .filters-panel {

            position: absolute;

            top: 55px;

            left: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 140px;

        }

        .filters-panel .title { color: #4fc3f7; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .filters-panel label { display: flex; align-items: center; gap: 6px; margin: 4px 0; cursor: pointer; color: #ddd; }

        .filters-panel input[type="checkbox"] { accent-color: #0078d4; }

        /* ========== PANEL DE NIVELES ========== */

        .levels-panel {

            position: absolute;

            top: 55px;

            right: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 120px;

        }

        .levels-panel .title { color: #4fc3f7; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .level-nav { display: flex; align-items: center; gap: 8px; margin-top: 6px; }

        .level-nav button { background: #2c3e50; border: 1px solid #444; border-radius: 4px; padding: 4px 10px; cursor: pointer; font-size: 14px; color: #fff; }

        .level-nav button:hover { background: #34495e; }

        .level-display { font-weight: 600; color: #fff; min-width: 60px; text-align: center; }

        /* ========== PANEL DE CORTE ========== */

        .clipping-panel {

            position: absolute;

            bottom: 80px;

            right: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 180px;

        }

        .clipping-panel .title { color: #4fc3f7; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .clipping-panel label { display: block; margin: 6px 0 2px; color: #aaa; }

        .clipping-panel input[type="range"] { width: 100%; accent-color: #0078d4; }

        .clipping-panel .axis-btns { display: flex; gap: 4px; margin-bottom: 8px; }

        .clipping-panel .axis-btns button { flex: 1; padding: 4px 8px; font-size: 10px; }

        /* ========== COORDENADAS Y INFO ========== */

        .coords-display {

            position: absolute;

            bottom: 10px;

            left: 50%;

            transform: translateX(-50%);

            background: rgba(0,0,0,0.85);

            color: #4fc3f7;

            padding: 6px 16px;

            border-radius: 6px;

            font-family: 'Consolas', monospace;

            font-size: 11px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.3);

        }

        .line-info {

            position: absolute;

            bottom: 45px;

            left: 50%;

            transform: translateX(-50%);

            background: #0078d4;

            color: white;

            padding: 5px 14px;

            border-radius: 6px;

            font-family: 'Consolas', monospace;

            font-size: 11px;

            display: none;

        }

        .snap-indicator {

            position: absolute;

            padding: 3px 8px;

            background: #f1c40f;

            color: #000;

            border-radius: 4px;

            font-size: 10px;

            font-weight: 600;

            pointer-events: none;

            display: none;

            z-index: 150;

        }

        /* ========== INFO PANEL ========== */

        .info-panel {

            position: absolute;

            top: 55px;

            left: 160px;

            background: rgba(0,0,0,0.85);

            color: #fff;

            padding: 10px 14px;

            border-radius: 8px;

            font-size: 12px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

        }

        /* ========== CONTROLES INFO ========== */

        .controls-info {

            position: absolute;

            bottom: 10px;

            left: 10px;

            background: rgba(0,0,0,0.85);

            color: #ddd;

            padding: 8px 12px;

            border-radius: 6px;

            font-size: 10px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.3);

        }

        .controls-info p { margin: 2px 0; }

        .controls-info span { background: #444; padding: 2px 6px; border-radius: 3px; font-family: monospace; color: #fff; }

        /* ========== PANEL DE SELECCION ========== */

        .selection-panel {

            position: absolute;

            bottom: 60px;

            right: 10px;

            background: rgba(0,0,0,0.9);

            padding: 12px 15px;

            border-radius: 8px;

            font-size: 11px;

            z-index: 100;

            min-width: 180px;

            border: 1px solid #27ae60;

            box-shadow: 0 4px 15px rgba(39,174,96,0.3);

        }

        .selection-panel .title { color: #27ae60; font-weight: 600; margin-bottom: 8px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .selection-panel .sel-tipo { color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 6px; }

        .selection-panel .sel-info { color: #aaa; font-size: 10px; margin-bottom: 10px; }

        .selection-panel .sel-info div { margin: 3px 0; }

        .selection-panel .sel-btn {

            width: 100%;

            padding: 6px 10px;

            background: #c0392b;

            border: none;

            color: #fff;

            border-radius: 4px;

            cursor: pointer;

            font-size: 10px;

        }

        .selection-panel .sel-btn:hover { background: #e74c3c; }

        /* ========== PANEL DE TRANSPARENCIA ========== */

        .transparency-panel {

            position: absolute;

            top: 55px;

            left: 160px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 160px;

            display: none;

        }

        .transparency-panel .title { color: #9b59b6; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .transparency-panel .trans-row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }

        .transparency-panel .trans-row label { flex: 1; color: #ddd; }

        .transparency-panel .trans-row input { width: 80px; accent-color: #9b59b6; }

        .transparency-panel button { width: 100%; padding: 6px; margin-top: 8px; background: #555; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px; }

        /* ========== PANEL DE MODELO ANALITICO ========== */

        .analytic-panel {

            position: absolute;

            top: 200px;

            right: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 180px;

            border: 1px solid #8e44ad;

            display: none;

        }

        .analytic-panel .title { color: #8e44ad; font-weight: 600; margin-bottom: 8px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .analytic-panel .stat-row { display: flex; justify-content: space-between; padding: 3px 0; }

        .analytic-panel .stat-row .lbl { color: #888; }

        .analytic-panel .stat-row .val { color: #9b59b6; font-weight: bold; }

        .analytic-panel .toggle-row { display: flex; gap: 10px; margin: 8px 0; }

        .analytic-panel .toggle-row label { display: flex; align-items: center; gap: 5px; color: #ddd; }

        .analytic-panel button { width: 100%; padding: 6px; margin-top: 6px; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px; }

        .analytic-panel button.purple { background: #8e44ad; }

        .analytic-panel button.red { background: #c0392b; }

        .analytic-panel button.blue { background: #0078d4; }

    </style>
<script>

        var contextMenu = false;

        function getVerticalPosition(line) { return document.querySelector("[data-text='" + line + "']").getBoundingClientRect().top; }

        function isNumeric(s) { return s.match(/^-?\d+(?:\.\d+)?$/); }

        if (window.jQuery) {

            function getHtmlWithInput() {

                $("input[type=text]").each(function () {

                    $(this).attr("value", $(this).val());

                });

                $("input[type=hidden]").each(function () {

                    $(this).attr("value", $(this).val());

                });

                $("textarea").each(function () {

                    $(this).html($(this).val());

                });

                $("input[type=radio]").each(function () {

                    if (this.checked)

                        $(this).attr("checked", "checked");

                    else

                        $(this).removeAttr("checked");

                });

                $("input[type=checkbox]").each(function () {

                    if (this.checked)

                        $(this).attr("checked", "checked");

                    else

                        $(this).removeAttr("checked");

                });

                $("select option").each(function () {

                    if (this.selected) {

                        $(this).attr("selected", "true");

                    }

                    else

                        $(this).removeAttr("selected");

                });

                return document.body.outerHTML;

            }

            function getTargetId(element) {

                var id = $(element).attr("name");

                if (id != null && id.length > 0)

                    return id;

                return $(element).data("target");

            }

            function getValue(id, source) {

                var value = "";

                var target = $("#" + id + " input");

                var domObj = target.get(0);

                if (domObj == null || domObj.Length == 0) {

                    target = $("#" + id + " .eq u");

                    target.each(function () {

                        value += $(this).text() + ";";

                    });

                    $(source).prop('disabled', true);

                }

                else {

                    target.each(function () {

                        value += $(this).val() + ";";

                    });

                }

                if (value.length > 1) {

                    value = value.slice(0, -1);

                }

                return value;

            }

            $(document).ready(function () {

                $(".dvcs:has(.block) > :first-child").html("&hairsp;");

                $("#Units").change(function () { $(".Units").text($(this).val()); });

                $(".fold > :first-child").click(function () {

                    if ($(this).parent().hasClass("fold")) {

                        $(this).parent().removeClass("fold").addClass("unfold");

                    }

                    else {

                        $(this).parent().removeClass("unfold").addClass("fold");

                    }

                });

                $("select").each(function (index) {

                    if ($(this).prop("id") != "Units") {

                        var id = getTargetId(this);

                        if (id != null && id.length > 0) {

                            var value = getValue(id, this);

                            $(this).val(value);

                        }

                    }

                });

                $("select").change(function () {

                    var id = getTargetId(this);

                    if (id != null && id.length > 0) {

                        var target = $("#" + id + " input");

                        if (target != null) {

                            var values = $(this).val().split(";");

                            target.each(function (index) {

                                $(this).val(values[index]);

                            });

                        }

                    }

                });

                $("input:radio, input:checkbox").each(function (index) {

                    var id = getTargetId(this);

                    if (id != null && id.length > 0) {

                        var value = getValue(id, this);

                        $(this).prop("checked", $(this).val() == value);

                    }

                });

                $("input:radio, input:checkbox").change(function () {

                    var id = getTargetId(this);

                    if (id != null && id.length > 0) {

                        var target = $("#" + id + " input");

                        if (target != null) {

                            if ($(this).prop("checked")) {

                                var values = $(this).val().split(";");

                                target.each(function (index) {

                                    $(this).val(values[index]);

                                });

                            }

                            else if ($(this).prop("type") == "checkbox") {

                                target.each(function () {

                                    $(this).val("0");

                                });

                            }

                        }

                    }

                });

                $(".line:not(style, script)").each(function () {

                    var line = $(this).prop("id").split("-")[1];

                    var $lineLink = $('<a class="lineLink" href="#0" data-text="' + line + '" title="Code line ' + line + '">&larr;</a>');

                    $(this).append($lineLink);

                    $lineLink.hide();

                    $(this).hover(function () {

                        $(".lineLink").hide();

                        $lineLink.show();

                    });

                    $(window).scroll(function () {

                        $lineLink.hide();

                    });

                });

                $("body").mouseleave(function () {

                    $(".lineLink").hide();

                });

                $(".roundBox").click(function () {

                    var line = $(this).data("line");

                    var e = document.getElementById("line-" + line);

                    if (e) {

                        window.scrollTo(0, e.offsetTop - $(this).outerHeight() - 20);

                    }

                });

                $(".money").each(function () { $(this).text(Number(($(this).text())).toFixed(2)); });

                $("input").change(function() {

                    var e = $(this);

                    var s = e.val();

                    if (isNumeric(s)) {

                        e.css("color", "black");

                        e.removeAttr("title");

                    } else {

                        e.css("color", "red");

                        e.attr("title", "Invalid number");

                    }

                });

                $("a").click(function () {

                    chrome.webview.postMessage('clicked');

                });

                window.addEventListener('click', () => {

                    chrome.webview.postMessage('focused');

                });

            });

        }

        document.oncontextmenu = function () { contextMenu = true; };

        document.onmousedown = function () { contextMenu = false; };

    </script><style>

        /* ========== ESTILOS GENERALES - TEMA OSCURO ========== */

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {

            width: 100vw;

            height: 100vh;

            overflow: hidden;

            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

            background: #1a1a1a;

            color: #fff;

        }

        #ifc-viewer-main { width: 100%; height: 100%; position: relative; }

        #ifc-viewer-main-canvas { width: 100%; height: 100%; }

        @keyframes ifc-spin { to { transform: rotate(360deg); } }

        .progress-bar {

            width: 200px;

            height: 6px;

            background: #333;

            border-radius: 3px;

            margin-top: 10px;

            overflow: hidden;

        }

        .progress-bar-fill {

            height: 100%;

            background: #0078d4;

            width: 0%;

            transition: width 0.3s;

        }

        /* ========== TOOLBAR PRINCIPAL ========== */

        .toolbar {

            position: absolute;

            top: 8px;

            left: 10px;

            right: 10px;

            display: flex;

            justify-content: center;

            flex-wrap: wrap;

            gap: 4px;

            background: rgba(0,0,0,0.85);

            padding: 6px 10px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            z-index: 100;

        }

        .toolbar button {

            background: #2c3e50;

            color: #fff;

            border: 1px solid #444;

            border-radius: 4px;

            padding: 6px 12px;

            cursor: pointer;

            font-size: 11px;

            font-weight: 500;

            transition: all 0.2s;

        }

        .toolbar button:hover { background: #34495e; border-color: #0078d4; }

        .toolbar button.active { background: #0078d4; color: white; border-color: #0078d4; }

        .toolbar-separator { width: 1px; background: #555; margin: 0 4px; }

        /* ========== PANEL DE FILTROS ========== */

        .filters-panel {

            position: absolute;

            top: 55px;

            left: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 140px;

        }

        .filters-panel .title { color: #4fc3f7; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .filters-panel label { display: flex; align-items: center; gap: 6px; margin: 4px 0; cursor: pointer; color: #ddd; }

        .filters-panel input[type="checkbox"] { accent-color: #0078d4; }

        /* ========== PANEL DE NIVELES ========== */

        .levels-panel {

            position: absolute;

            top: 55px;

            right: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 120px;

        }

        .levels-panel .title { color: #4fc3f7; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .level-nav { display: flex; align-items: center; gap: 8px; margin-top: 6px; }

        .level-nav button { background: #2c3e50; border: 1px solid #444; border-radius: 4px; padding: 4px 10px; cursor: pointer; font-size: 14px; color: #fff; }

        .level-nav button:hover { background: #34495e; }

        .level-display { font-weight: 600; color: #fff; min-width: 60px; text-align: center; }

        /* ========== PANEL DE CORTE ========== */

        .clipping-panel {

            position: absolute;

            bottom: 80px;

            right: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 180px;

        }

        .clipping-panel .title { color: #4fc3f7; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .clipping-panel label { display: block; margin: 6px 0 2px; color: #aaa; }

        .clipping-panel input[type="range"] { width: 100%; accent-color: #0078d4; }

        .clipping-panel .axis-btns { display: flex; gap: 4px; margin-bottom: 8px; }

        .clipping-panel .axis-btns button { flex: 1; padding: 4px 8px; font-size: 10px; }

        /* ========== COORDENADAS Y INFO ========== */

        .coords-display {

            position: absolute;

            bottom: 10px;

            left: 50%;

            transform: translateX(-50%);

            background: rgba(0,0,0,0.85);

            color: #4fc3f7;

            padding: 6px 16px;

            border-radius: 6px;

            font-family: 'Consolas', monospace;

            font-size: 11px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.3);

        }

        .line-info {

            position: absolute;

            bottom: 45px;

            left: 50%;

            transform: translateX(-50%);

            background: #0078d4;

            color: white;

            padding: 5px 14px;

            border-radius: 6px;

            font-family: 'Consolas', monospace;

            font-size: 11px;

            display: none;

        }

        .snap-indicator {

            position: absolute;

            padding: 3px 8px;

            background: #f1c40f;

            color: #000;

            border-radius: 4px;

            font-size: 10px;

            font-weight: 600;

            pointer-events: none;

            display: none;

            z-index: 150;

        }

        /* ========== INFO PANEL ========== */

        .info-panel {

            position: absolute;

            top: 55px;

            left: 160px;

            background: rgba(0,0,0,0.85);

            color: #fff;

            padding: 10px 14px;

            border-radius: 8px;

            font-size: 12px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

        }

        /* ========== CONTROLES INFO ========== */

        .controls-info {

            position: absolute;

            bottom: 10px;

            left: 10px;

            background: rgba(0,0,0,0.85);

            color: #ddd;

            padding: 8px 12px;

            border-radius: 6px;

            font-size: 10px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.3);

        }

        .controls-info p { margin: 2px 0; }

        .controls-info span { background: #444; padding: 2px 6px; border-radius: 3px; font-family: monospace; color: #fff; }

        /* ========== PANEL DE SELECCION ========== */

        .selection-panel {

            position: absolute;

            bottom: 60px;

            right: 10px;

            background: rgba(0,0,0,0.9);

            padding: 12px 15px;

            border-radius: 8px;

            font-size: 11px;

            z-index: 100;

            min-width: 180px;

            border: 1px solid #27ae60;

            box-shadow: 0 4px 15px rgba(39,174,96,0.3);

        }

        .selection-panel .title { color: #27ae60; font-weight: 600; margin-bottom: 8px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .selection-panel .sel-tipo { color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 6px; }

        .selection-panel .sel-info { color: #aaa; font-size: 10px; margin-bottom: 10px; }

        .selection-panel .sel-info div { margin: 3px 0; }

        .selection-panel .sel-btn {

            width: 100%;

            padding: 6px 10px;

            background: #c0392b;

            border: none;

            color: #fff;

            border-radius: 4px;

            cursor: pointer;

            font-size: 10px;

        }

        .selection-panel .sel-btn:hover { background: #e74c3c; }

        /* ========== PANEL DE TRANSPARENCIA ========== */

        .transparency-panel {

            position: absolute;

            top: 55px;

            left: 160px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 160px;

            display: none;

        }

        .transparency-panel .title { color: #9b59b6; font-weight: 600; margin-bottom: 8px; font-size: 12px; }

        .transparency-panel .trans-row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }

        .transparency-panel .trans-row label { flex: 1; color: #ddd; }

        .transparency-panel .trans-row input { width: 80px; accent-color: #9b59b6; }

        .transparency-panel button { width: 100%; padding: 6px; margin-top: 8px; background: #555; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px; }

        /* ========== PANEL DE MODELO ANALITICO ========== */

        .analytic-panel {

            position: absolute;

            top: 200px;

            right: 10px;

            background: rgba(0,0,0,0.85);

            padding: 10px 12px;

            border-radius: 8px;

            box-shadow: 0 2px 8px rgba(0,0,0,0.5);

            font-size: 11px;

            z-index: 100;

            min-width: 180px;

            border: 1px solid #8e44ad;

            display: none;

        }

        .analytic-panel .title { color: #8e44ad; font-weight: 600; margin-bottom: 8px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .analytic-panel .stat-row { display: flex; justify-content: space-between; padding: 3px 0; }

        .analytic-panel .stat-row .lbl { color: #888; }

        .analytic-panel .stat-row .val { color: #9b59b6; font-weight: bold; }

        .analytic-panel .toggle-row { display: flex; gap: 10px; margin: 8px 0; }

        .analytic-panel .toggle-row label { display: flex; align-items: center; gap: 5px; color: #ddd; }

        .analytic-panel button { width: 100%; padding: 6px; margin-top: 6px; border: none; color: #fff; border-radius: 4px; cursor: pointer; font-size: 10px; }

        .analytic-panel button.purple { background: #8e44ad; }

        .analytic-panel button.red { background: #c0392b; }

        .analytic-panel button.blue { background: #0078d4; }

    </style>

<!-- ========== CONTENEDOR PRINCIPAL ========== -->

    <div id="ifc-viewer-main" style="width: 100%; height: 100%; position: relative; background: #1a1a1a;">

        <canvas id="ifc-viewer-main-canvas" style="width: 718px; height: 872px;" data-engine="three.js r149" width="1077" height="1308"></canvas>

        <!-- TOOLBAR PRINCIPAL -->

        <div class="toolbar" id="ifc-viewer-main-toolbar">

            <button class="tb-btn" data-action="select" title="Seleccionar (S)">Seleccionar</button>

            <button class="tb-btn" data-action="line" title="Dibujar LÃ­nea (L)">LÃ­nea</button>

            <button class="tb-btn" data-action="polyline" title="PolilÃ­nea (P)">PolilÃ­nea</button>

            <span class="toolbar-separator"></span>

            <button class="tb-btn snap-btn" data-action="snap" title="Snap (F3)">Snap OFF</button>

            <button class="tb-btn ortho-btn" data-action="ortho" title="Ortho (F8)">Ortho OFF</button>

            <button class="tb-btn grid-btn active" data-action="grid" title="Grid (G)">Grid</button>

            <span class="toolbar-separator"></span>

            <button class="tb-btn" data-action="top" title="Vista Planta">Planta</button>

            <button class="tb-btn" data-action="front" title="Vista Frontal">Frontal</button>

            <button class="tb-btn" data-action="right" title="Vista Derecha">Derecha</button>

            <button class="tb-btn" data-action="3d" title="Vista 3D">3D</button>

            <button class="tb-btn" data-action="fit" title="Fit to View (F)">Fit</button>

            <span class="toolbar-separator"></span>

            <button class="tb-btn" data-action="undo" title="Deshacer (Ctrl+Z)">Deshacer</button>

            <button class="tb-btn" data-action="clear" title="Limpiar Dibujo">Limpiar</button>

            <span class="toolbar-separator"></span>

            <button class="tb-btn trans-btn" data-action="transparency" title="Transparencia (T)">Transparencia</button>

            <button class="tb-btn analytic-btn" data-action="auto-analytic" title="Generar Modelo AnalÃ­tico (A)" style="background:#8e44ad">Auto AnalÃ­tico</button>

            <button class="tb-btn model-btn" data-action="show-model" title="Ver Modelo AnalÃ­tico (M)">Modelo</button>

            <span class="toolbar-separator"></span>

            <button class="tb-btn" data-action="copy-html" title="Copiar HTML al portapapeles" style="background:#16a085">Copiar HTML</button>

            <button class="tb-btn" data-action="update-editor" title="Actualizar cÃ³digo en el editor (Ctrl+U)" style="background:#e67e22">Actualizar Editor</button>

        </div>

        <!-- PANEL DE FILTROS -->

        <div class="filters-panel" id="ifc-viewer-main-filters">

            <div class="title">Filtrar Elementos</div>

            <label><input type="checkbox" class="filter-cb" data-type="WALL" checked="checked"> Muros</label>

            <label><input type="checkbox" class="filter-cb" data-type="SLAB" checked="checked" title="Invalid number" style="color: red;"> Losas</label>

            <label><input type="checkbox" class="filter-cb" data-type="COLUMN" checked="checked"> Columnas</label>

            <label><input type="checkbox" class="filter-cb" data-type="BEAM" checked="checked"> Vigas</label>

            <label><input type="checkbox" class="filter-cb" data-type="WINDOW" checked="checked"> Ventanas</label>

            <label><input type="checkbox" class="filter-cb" data-type="DOOR" checked="checked"> Puertas</label>

            <label><input type="checkbox" class="filter-cb" data-type="OTHER" checked="checked"> Otros</label>

        </div>

        <!-- PANEL DE NIVELES -->

        <div class="levels-panel" id="ifc-viewer-main-levels">

            <div class="title">Niveles</div>

            <div class="level-nav">

                <button id="ifc-viewer-main-level-up" title="Nivel Superior">â–²</button>

                <span class="level-display" id="ifc-viewer-main-level-display">Todos</span>

                <button id="ifc-viewer-main-level-down" title="Nivel Inferior">â–¼</button>

            </div>

        </div>

        <!-- PANEL DE CORTE -->

        <div class="clipping-panel" id="ifc-viewer-main-clipping">

            <div class="title">Plano de Corte</div>

            <div class="axis-btns">

                <button class="tb-btn clip-axis" data-axis="x">X</button>

                <button class="tb-btn clip-axis" data-axis="y">Y</button>

                <button class="tb-btn clip-axis" data-axis="z">Z</button>

                <button class="tb-btn clip-axis" data-axis="none">OFF</button>

            </div>

            <label>PosiciÃ³n: <span id="ifc-viewer-main-clip-value">0</span></label>

            <input type="range" id="ifc-viewer-main-clip-slider" min="-12.351004284100002" max="12.351004284100002" value="0">

        </div>

        <!-- INFO PANEL -->

        <div class="info-panel" id="ifc-viewer-main-info">

            <strong>Silvia CedeÃ±o.ifc</strong>

            <div id="ifc-viewer-main-stats"><br>68 elementos</div>

        </div>

        <!-- LOADING SPINNER -->

        <div id="ifc-viewer-main-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: rgb(255, 255, 255); background: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 12px; box-shadow: rgba(0, 0, 0, 0.5) 0px 4px 20px; display: none;">

            <div style="width: 50px; height: 50px; border: 3px solid #333; border-top-color: #0078d4; border-radius: 50%; animation: ifc-spin 1s linear infinite; margin: 0 auto;"></div>

            <p style="margin-top: 15px;" id="ifc-viewer-main-status">Ajustando vista...</p>

            <div class="progress-bar"><div class="progress-bar-fill" id="ifc-viewer-main-progress" style="width: 90%;"></div></div>

        </div>

        <!-- COORDENADAS -->

        <div class="coords-display" id="ifc-viewer-main-coords">X: -288.39 Y: 0.00 Z: -159.85</div>

        <div class="line-info" id="ifc-viewer-main-lineinfo">Longitud: 0.00</div>

        <div class="snap-indicator" id="ifc-viewer-main-snap-indicator" style="display: none;"></div>

        <!-- PANEL DE SELECCIÃ“N -->

        <div class="selection-panel" id="ifc-viewer-main-selection" style="display: none;">

            <div class="title">Elemento Seleccionado</div>

            <div id="ifc-viewer-main-sel-tipo" class="sel-tipo">Columna</div>

            <div id="ifc-viewer-main-sel-info" class="sel-info">

                                <div>Nivel: -59</div>

                                <div>Dimensiones: 350.00 Ã— 350.00 Ã— 8480.00 m</div>

                            </div>

            <button id="ifc-viewer-main-sel-deselect" class="sel-btn">Deseleccionar (Esc)</button>

        </div>

        <!-- PANEL DE TRANSPARENCIA -->

        <div class="transparency-panel" id="ifc-viewer-main-transparency" style="display: block;">

            <div class="title">Transparencia</div>

            <div class="trans-row"><label>Muros</label><input type="range" class="trans-slider" data-type="WALL" min="0" max="1" step="0.1" value="1"></div>

            <div class="trans-row"><label>Losas</label><input type="range" class="trans-slider" data-type="SLAB" min="0" max="1" step="0.1" value="0.2" style="color: black;"></div>

            <div class="trans-row"><label>Columnas</label><input type="range" class="trans-slider" data-type="COLUMN" min="0" max="1" step="0.1" value="0.2" style="color: black;"></div>

            <div class="trans-row"><label>Vigas</label><input type="range" class="trans-slider" data-type="BEAM" min="0" max="1" step="0.1" value="0.2" style="color: black;"></div>

            <div class="trans-row"><label>Otros</label><input type="range" class="trans-slider" data-type="OTHER" min="0" max="1" step="0.1" value="1"></div>

            <button id="ifc-viewer-main-trans-reset">Resetear</button>

        </div>

        <!-- PANEL DE MODELO ANALITICO -->

        <div class="analytic-panel" id="ifc-viewer-main-analytic" style="display: block;">

            <div class="title">Modelo AnalÃ­tico</div>

            <div class="stat-row"><span class="lbl">Columnas:</span><span class="val" id="ifc-viewer-main-stat-cols">11</span></div>

            <div class="stat-row"><span class="lbl">Vigas:</span><span class="val" id="ifc-viewer-main-stat-beams">0</span></div>

            <div class="stat-row"><span class="lbl">Nodos:</span><span class="val" id="ifc-viewer-main-stat-nodes">2</span></div>

            <div class="stat-row"><span class="lbl">Long. total:</span><span class="val" id="ifc-viewer-main-stat-length">3850.00 m</span></div>

            <div class="toggle-row">

                <label><input type="checkbox" id="ifc-viewer-main-show-physical" checked=""> FÃ­sico</label>

                <label><input type="checkbox" id="ifc-viewer-main-show-analytic" checked=""> AnalÃ­tico</label>

            </div>

            <div style="margin:8px 0;border-top:1px solid #444;padding-top:8px;">

                <div style="font-size:11px;color:#aaa;margin-bottom:5px;">Generar LÃ­neas AnalÃ­ticas:</div>

                <label style="display:block;margin:3px 0;color:#fff;font-size:12px;">

                    <input type="checkbox" id="ifc-viewer-main-chk-columns" checked=""> Columnas (Centro)

                </label>

                <label style="display:block;margin:3px 0;color:#fff;font-size:12px;">

                    <input type="checkbox" id="ifc-viewer-main-chk-beams" checked="" title="Invalid number" style="color: red;"> Vigas (Arriba)

                </label>

                <button id="ifc-viewer-main-gen-analytic" style="background:#8e44ad;margin-top:5px;width:100%;">Generar Modelo</button>

            </div>

            <div style="margin:8px 0;border-top:1px solid #444;padding-top:8px;">

                <div style="font-size:11px;color:#aaa;margin-bottom:5px;">Opciones Columnas:</div>

                <button class="orange" id="ifc-viewer-main-divide-elements" style="background: rgb(52, 152, 219); margin-bottom: 5px; width: 100%;">Unir Columnas</button>

            </div>

            <button class="purple" id="ifc-viewer-main-export-model">Exportar JSON</button>

            <button class="green" id="ifc-viewer-main-export-ifc" style="background:#27ae60;margin-top:5px;width:100%;">Exportar IFC</button>

            <button class="red" id="ifc-viewer-main-clear-model">Limpiar</button>

        </div>

        <!-- CONTROLES INFO -->

        <div class="controls-info">

            <p><span>Click + Arrastrar</span> Rotar</p>

            <p><span>Scroll</span> Zoom</p>

            <p><span>F</span> Fit | <span>L</span> LÃ­nea | <span>S</span> Seleccionar</p>

        </div>

    </div>

    <!-- ========== SCRIPTS ========== -->

    <script src="https://calcpad.ifc/three.min.js"></script>

    <script src="https://calcpad.ifc/OrbitControls.js"></script>

    <script src="https://calcpad.ifc/web-ifc-api-iife.js"></script>

    <script>

        (async function() {

            // ========== CONFIGURACION DE ELEMENTOS DOM ==========

            const containerId = 'ifc-viewer-main';

            const canvas = document.getElementById(containerId + '-canvas');

            const stats = document.getElementById(containerId + '-stats');

            const loading = document.getElementById(containerId + '-loading');

            const status = document.getElementById(containerId + '-status');

            const progress = document.getElementById(containerId + '-progress');

            const container = document.getElementById(containerId);

            const coordsEl = document.getElementById(containerId + '-coords');

            const lineInfoEl = document.getElementById(containerId + '-lineinfo');

            const snapIndicator = document.getElementById(containerId + '-snap-indicator');

            const levelDisplay = document.getElementById(containerId + '-level-display');

            const clipSlider = document.getElementById(containerId + '-clip-slider');

            const clipValue = document.getElementById(containerId + '-clip-value');

            const selectionPanel = document.getElementById(containerId + '-selection');

            const selTipo = document.getElementById(containerId + '-sel-tipo');

            const selInfo = document.getElementById(containerId + '-sel-info');

            const selDeselect = document.getElementById(containerId + '-sel-deselect');

            function updateStatus(msg, pct) {

                if (status) status.textContent = msg;

                if (progress && pct !== undefined) progress.style.width = pct + '%';

            }

            // ========== ESTADO DE LA APLICACION ==========

            let modo = 'select';

            let snapActivo = false;

            let orthoActivo = false;

            let gridVisible = true;

            let dibujando = false;

            let puntoInicial = null;

            const snapPuntos = [];

            const lineasGroup = new THREE.Group();

            const lineasHistorial = [];

            let lineaTemporal = null;

            let modelCenter, modelMaxDim;

            const geometries = [];

            let niveles = ['Todos'];

            const nivelesY = [];  // Alturas Y de cada nivel

            let nivelActual = 0;

            let clipPlane = null;

            let clipAxis = 'none';

            // Variables para selecciÃ³n de elementos

            let selectedMesh = null;

            let originalMaterial = null;

            const selectMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x003300, side: THREE.DoubleSide });

            // Variables para modelo analÃ­tico

            const analyticGroup = new THREE.Group();

            let slabLevels = [];

            let columnCenters = [];

            // Historial para deshacer modelo analÃ­tico

            let analyticHistory = [];

            let analyticModel = {

                members: [],

                nodes: [],

                nextId: 1,

                nextNodeId: 1

            };

            const analyticColors = {

                beam: 0xe74c3c,

                column: 0x27ae60,

                brace: 0xf39c12

            };

            // Variable para controlar divisiÃ³n de columnas por piso

            let divideByFloor = true;

            // Elementos clasificados por tipo

            const elementsByType = {

                WALL: [],

                SLAB: [],

                COLUMN: [],

                BEAM: [],

                WINDOW: [],

                DOOR: [],

                OTHER: []

            };

            try {

                updateStatus('Inicializando Three.js...', 10);

                // ========== CONFIGURACION DE LA ESCENA 3D ==========

                const scene = new THREE.Scene();

                scene.background = new THREE.Color(0x1a1a1a);

                const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 10000);

                camera.position.set(50, 50, 50);

                const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });

                renderer.setSize(container.clientWidth, container.clientHeight);

                renderer.setPixelRatio(window.devicePixelRatio);

                renderer.localClippingEnabled = true;

                const controls = new THREE.OrbitControls(camera, renderer.domElement);

                controls.enableDamping = true;

                controls.dampingFactor = 0.05;

                // ========== ILUMINACION ==========

                scene.add(new THREE.AmbientLight(0xffffff, 0.6));

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);

                dirLight.position.set(50, 100, 50);

                scene.add(dirLight);

                // ========== GRID ==========

                const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x333333);

                scene.add(gridHelper);

                scene.add(lineasGroup);

                scene.add(analyticGroup);

                // ========== RAYCASTER PARA SNAP Y SELECCION ==========

                const raycaster = new THREE.Raycaster();

                const mouse = new THREE.Vector2();

                updateStatus('Descargando archivo IFC...', 20);

                // ========== CARGA DEL ARCHIVO IFC ==========

                const response = await fetch('https://calcpad.ifc/temp_2f3a76b7841d4402b11c1277666db65b.ifc');

                if (!response.ok) throw new Error('Error descargando archivo: ' + response.status);

                updateStatus('Leyendo datos...', 40);

                const ifcData = await response.arrayBuffer();

                updateStatus('Inicializando web-ifc...', 50);

                const ifcApi = new WebIFC.IfcAPI();

                await ifcApi.Init(function(path) {

                    if (path.endsWith('.wasm')) {

                        return 'https://calcpad.ifc/' + path;

                    }

                    return path;

                });

                updateStatus('Parseando modelo IFC...', 60);

                const modelID = ifcApi.OpenModel(new Uint8Array(ifcData));

                updateStatus('Generando geometrÃ­a 3D...', 70);

                const flatMeshes = ifcApi.LoadAllGeometry(modelID);

                updateStatus('Construyendo malla...', 80);

                const allMeshes = new THREE.Group();

                const nivelesSet = new Set();

                // ========== PROCESAMIENTO DE GEOMETRIA IFC ==========

                for (let i = 0; i < flatMeshes.size(); i++) {

                    const flatMesh = flatMeshes.get(i);

                    const expressID = flatMesh.expressID;

                    const placedGeometries = flatMesh.geometries;

                    for (let j = 0; j < placedGeometries.size(); j++) {

                        const pg = placedGeometries.get(j);

                        const geom = ifcApi.GetGeometry(modelID, pg.geometryExpressID);

                        const verts = ifcApi.GetVertexArray(geom.GetVertexData(), geom.GetVertexDataSize());

                        const indices = ifcApi.GetIndexArray(geom.GetIndexData(), geom.GetIndexDataSize());

                        if (verts.length === 0 || indices.length === 0) continue;

                        const positions = new Float32Array(verts.length / 2);

                        const normals = new Float32Array(verts.length / 2);

                        for (let k = 0; k < verts.length; k += 6) {

                            const idx = (k / 6) * 3;

                            positions[idx] = verts[k];

                            positions[idx + 1] = verts[k + 1];

                            positions[idx + 2] = verts[k + 2];

                            normals[idx] = verts[k + 3];

                            normals[idx + 1] = verts[k + 4];

                            normals[idx + 2] = verts[k + 5];

                        }

                        const bufferGeom = new THREE.BufferGeometry();

                        bufferGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                        bufferGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));

                        bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));

                        const color = new THREE.Color(pg.color.x, pg.color.y, pg.color.z);

                        const material = new THREE.MeshPhongMaterial({

                            color: color,

                            side: THREE.DoubleSide,

                            transparent: pg.color.w < 1,

                            opacity: pg.color.w

                        });

                        const meshObj = new THREE.Mesh(bufferGeom, material);

                        const matrix = new THREE.Matrix4().fromArray(pg.flatTransformation);

                        meshObj.applyMatrix4(matrix);

                        // Detectar tipo IFC

                        let ifcType = 'OTHER';

                        try {

                            const line = ifcApi.GetLine(modelID, expressID);

                            if (line && line.constructor) {

                                const tn = line.constructor.name.toUpperCase();

                                if (tn.includes('WALL')) ifcType = 'WALL';

                                else if (tn.includes('SLAB') || tn.includes('FLOOR')) ifcType = 'SLAB';

                                else if (tn.includes('COLUMN')) ifcType = 'COLUMN';

                                else if (tn.includes('BEAM')) ifcType = 'BEAM';

                                else if (tn.includes('WINDOW')) ifcType = 'WINDOW';

                                else if (tn.includes('DOOR')) ifcType = 'DOOR';

                            }

                        } catch(e) {}

                        meshObj.userData.ifcType = ifcType;

                        // Detectar nivel basado en posiciÃ³n Y

                        bufferGeom.computeBoundingBox();

                        const yPos = bufferGeom.boundingBox.min.y;

                        const nivel = Math.floor(yPos / 3); // Aproximar niveles cada 3 metros

                        meshObj.userData.nivel = nivel;

                        nivelesSet.add(nivel);

                        // Agregar puntos de snap completos (similar a modelo analÃ­tico)

                        const min = bufferGeom.boundingBox.min.clone().applyMatrix4(meshObj.matrixWorld);

                        const max = bufferGeom.boundingBox.max.clone().applyMatrix4(meshObj.matrixWorld);

                        const cen = new THREE.Vector3();

                        bufferGeom.boundingBox.getCenter(cen);

                        cen.applyMatrix4(meshObj.matrixWorld);

                        // Centro (centroide)

                        snapPuntos.push({ pos: cen, tipo: 'Centro' });

                        // 8 esquinas del bounding box

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, min.y, min.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, min.y, min.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, max.y, min.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, max.y, min.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, min.y, max.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, min.y, max.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, max.y, max.z), tipo: 'Esquina' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, max.y, max.z), tipo: 'Esquina' });

                        // 12 puntos medios de aristas

                        snapPuntos.push({ pos: new THREE.Vector3((min.x+max.x)/2, min.y, min.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3((min.x+max.x)/2, max.y, min.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3((min.x+max.x)/2, min.y, max.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3((min.x+max.x)/2, max.y, max.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, (min.y+max.y)/2, min.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, (min.y+max.y)/2, min.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, (min.y+max.y)/2, max.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, (min.y+max.y)/2, max.z), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, min.y, (min.z+max.z)/2), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, min.y, (min.z+max.z)/2), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, max.y, (min.z+max.z)/2), tipo: 'Medio' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, max.y, (min.z+max.z)/2), tipo: 'Medio' });

                        // 6 centros de caras

                        snapPuntos.push({ pos: new THREE.Vector3(min.x, cen.y, cen.z), tipo: 'Cara' });

                        snapPuntos.push({ pos: new THREE.Vector3(max.x, cen.y, cen.z), tipo: 'Cara' });

                        snapPuntos.push({ pos: new THREE.Vector3(cen.x, min.y, cen.z), tipo: 'Cara' });

                        snapPuntos.push({ pos: new THREE.Vector3(cen.x, max.y, cen.z), tipo: 'Cara' });

                        snapPuntos.push({ pos: new THREE.Vector3(cen.x, cen.y, min.z), tipo: 'Cara' });

                        snapPuntos.push({ pos: new THREE.Vector3(cen.x, cen.y, max.z), tipo: 'Cara' });

                        allMeshes.add(meshObj);

                        geometries.push(meshObj);

                        // Clasificar por tipo para transparencia

                        if (elementsByType[ifcType]) {

                            elementsByType[ifcType].push(meshObj);

                        } else {

                            elementsByType.OTHER.push(meshObj);

                        }

                        // Recolectar info para modelo analÃ­tico

                        if (ifcType === 'SLAB') {

                            slabLevels.push(max.y);

                        }

                        if (ifcType === 'COLUMN') {
                            columnCenters.push({
                                x: cen.x,
                                z: cen.z,
                                minY: min.y,
                                maxY: max.y,
                                mesh: meshObj  // Referencia al mesh fÃ­sico para divisiÃ³n
                            });
                        }

                    }

                }

                scene.add(allMeshes);

                // Deduplicar y ordenar niveles de losa

                slabLevels = [...new Set(slabLevels.map(y => Math.round(y * 100) / 100))].sort((a, b) => a - b);

                console.log('Niveles de losa detectados:', slabLevels);

                console.log('Centros de columnas:', columnCenters.length);

                // Configurar niveles con sus alturas Y

                const nivelesOrdenados = Array.from(nivelesSet).sort((a,b) => a-b);

                niveles = ['Todos', ...nivelesOrdenados.map(n => 'Nivel ' + n)];

                // Guardar las alturas Y de cada nivel (para la navegaciÃ³n)

                nivelesOrdenados.forEach(n => {

                    nivelesY.push(n * 3); // Cada nivel estÃ¡ a n*3 metros

                });

                if (levelDisplay) levelDisplay.textContent = niveles[0];

                console.log('Niveles detectados:', niveles, 'Alturas Y:', nivelesY);

                // ========== AJUSTE AUTOMATICO DE VISTA ==========

                updateStatus('Ajustando vista...', 90);

                const box = new THREE.Box3().setFromObject(allMeshes);

                modelCenter = box.getCenter(new THREE.Vector3());

                const size = box.getSize(new THREE.Vector3());

                modelMaxDim = Math.max(size.x, size.y, size.z);

                camera.position.set(modelCenter.x + modelMaxDim, modelCenter.y + modelMaxDim, modelCenter.z + modelMaxDim);

                controls.target.copy(modelCenter);

                controls.update();

                // Configurar slider de corte

                if (clipSlider) {

                    clipSlider.min = -modelMaxDim;

                    clipSlider.max = modelMaxDim;

                    clipSlider.value = 0;

                }

                if (loading) loading.style.display = 'none';

                if (stats) stats.innerHTML = '<br>' + geometries.length + ' elementos';

                ifcApi.CloseModel(modelID);

                // ========== FUNCIONES DE VISTAS ==========

                function setView(view) {

                    const c = modelCenter, d = modelMaxDim * 1.5;

                    camera.up.set(0, 1, 0); // Reset up vector

                    switch(view) {

                        case 'top':

                            camera.position.set(c.x, c.y + d, c.z);

                            camera.up.set(0, 0, -1);

                            // Aplicar corte horizontal automÃ¡tico si hay un nivel seleccionado

                            if (nivelActual > 0 && niveles[nivelActual] !== 'Todos') {

                                const nivelY = nivelesY[nivelActual - 1] || c.y;

                                camera.position.set(c.x, nivelY + d/2, c.z);

                                controls.target.set(c.x, nivelY, c.z);

                            } else {

                                controls.target.copy(c);

                            }

                            break;

                        case 'front':

                            camera.position.set(c.x, c.y, c.z + d);

                            controls.target.copy(c);

                            break;

                        case 'right':

                            camera.position.set(c.x + d, c.y, c.z);

                            controls.target.copy(c);

                            break;

                        case '3d':

                            camera.position.set(c.x + d*0.8, c.y + d*0.8, c.z + d*0.8);

                            controls.target.copy(c);

                            break;

                    }

                    controls.update();

                }

                function fitView() {

                    camera.position.set(modelCenter.x + modelMaxDim, modelCenter.y + modelMaxDim, modelCenter.z + modelMaxDim);

                    controls.target.copy(modelCenter);

                    controls.update();

                }

                // ========== FILTROS POR TIPO ==========

                function aplicarFiltros() {

                    document.querySelectorAll('.filter-cb').forEach(cb => {

                        const tipo = cb.dataset.type;

                        const visible = cb.checked;

                        geometries.forEach(m => {

                            if (m.userData.ifcType === tipo && m.userData.nivelVisible !== false) {

                                m.visible = visible;

                            }

                        });

                    });

                }

                // ========== FILTROS POR NIVEL ==========

                function aplicarNivel() {

                    const nivelSeleccionado = niveles[nivelActual];

                    console.log('Aplicando nivel:', nivelSeleccionado, 'nivelActual:', nivelActual);

                    if (nivelSeleccionado === 'Todos') {

                        // Mostrar todos los elementos

                        geometries.forEach(m => {

                            m.userData.nivelVisible = true;

                            m.visible = true;

                        });

                        // Quitar corte

                        clipAxis = 'none';

                        aplicarCorte();

                        // Actualizar botones de corte

                        document.querySelectorAll('.clip-axis').forEach(b => b.classList.remove('active'));

                    } else {

                        const nivelNum = parseInt(nivelSeleccionado.replace('Nivel ', ''));

                        const nivelY = nivelesY[nivelActual - 1];

                        console.log('Nivel num:', nivelNum, 'nivelY:', nivelY, 'nivelesY:', nivelesY);

                        // Mostrar solo elementos de este nivel

                        geometries.forEach(m => {

                            const enNivel = m.userData.nivel === nivelNum;

                            m.userData.nivelVisible = enNivel;

                            m.visible = enNivel;

                        });

                        // Aplicar corte horizontal automÃ¡tico en Y (para ver planta del nivel)

                        if (nivelY !== undefined && modelMaxDim) {

                            clipAxis = 'y';

                            // Convertir la altura del corte al valor del slider (-100 a 100)

                            // El corte debe estar 3m arriba del nivel actual

                            const cortePosY = nivelY + 3;

                            const offsetFromCenter = cortePosY - modelCenter.y;

                            const sliderValue = (offsetFromCenter / modelMaxDim) * 100;

                            if (clipSlider) {

                                clipSlider.value = Math.min(100, Math.max(-100, sliderValue));

                            }

                            aplicarCorte();

                            // Marcar botÃ³n Y como activo

                            document.querySelectorAll('.clip-axis').forEach(b => {

                                b.classList.toggle('active', b.dataset.axis === 'y');

                            });

                        }

                    }

                    aplicarFiltros();

                    if (levelDisplay) levelDisplay.textContent = nivelSeleccionado;

                }

                // ========== PLANO DE CORTE ==========

                function aplicarCorte() {

                    if (clipAxis === 'none') {

                        geometries.forEach(m => {

                            m.material.clippingPlanes = [];

                            m.material.needsUpdate = true;

                        });

                        if (clipValue) clipValue.textContent = 'OFF';

                        return;

                    }

                    // El slider va de -100 a 100, lo mapeamos al rango del modelo

                    const sliderVal = parseFloat(clipSlider?.value || 0);

                    const range = modelMaxDim || 100;  // Usar dimensiÃ³n mÃ¡xima del modelo

                    const normalizedPos = (sliderVal / 100) * range;  // -range a +range

                    // Calcular posiciÃ³n absoluta del plano

                    let planePos, normal;

                    switch(clipAxis) {

                        case 'x':

                            planePos = modelCenter.x + normalizedPos;

                            normal = new THREE.Vector3(-1, 0, 0);  // Normal negativa para cortar desde arriba/derecha

                            break;

                        case 'y':

                            planePos = modelCenter.y + normalizedPos;

                            normal = new THREE.Vector3(0, -1, 0);  // Normal negativa para cortar desde arriba

                            break;

                        case 'z':

                            planePos = modelCenter.z + normalizedPos;

                            normal = new THREE.Vector3(0, 0, -1);

                            break;

                    }

                    // Crear plano de corte: Plane(normal, constant) donde constant = -distancia en direcciÃ³n de normal

                    clipPlane = new THREE.Plane(normal, planePos);

                    geometries.forEach(m => {

                        m.material.clippingPlanes = [clipPlane];

                        m.material.clipShadows = true;

                        m.material.needsUpdate = true;

                    });

                    if (clipValue) clipValue.textContent = planePos.toFixed(1);

                    console.log('Corte aplicado:', clipAxis, 'pos:', planePos, 'slider:', sliderVal);

                }

                // ========== SNAP ==========

                function encontrarSnap(sx, sy) {

                    if (!snapActivo) return null;

                    let mejor = null, mejorD = 20;

                    snapPuntos.forEach(sp => {

                        const p = sp.pos.clone().project(camera);

                        const px = (p.x + 1) / 2 * container.clientWidth;

                        const py = (-p.y + 1) / 2 * container.clientHeight;

                        const d = Math.sqrt((px - sx) ** 2 + (py - sy) ** 2);

                        if (d < mejorD) { mejorD = d; mejor = sp; }

                    });

                    return mejor;

                }

                function getPunto3D(e) {

                    const rect = canvas.getBoundingClientRect();

                    const x = e.clientX - rect.left, y = e.clientY - rect.top;

                    const sp = encontrarSnap(x, y);

                    if (sp) {

                        snapIndicator.style.display = 'block';

                        snapIndicator.style.left = x + 'px';

                        snapIndicator.style.top = (y - 25) + 'px';

                        snapIndicator.textContent = sp.tipo;

                        return sp.pos.clone();

                    }

                    snapIndicator.style.display = 'none';

                    mouse.x = (x / rect.width) * 2 - 1;

                    mouse.y = -(y / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);

                    const hits = raycaster.intersectObjects(geometries);

                    if (hits.length > 0) return hits[0].point.clone();

                    const plano = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

                    const pt = new THREE.Vector3();

                    raycaster.ray.intersectPlane(plano, pt);

                    return pt;

                }

                function aplicarOrtho(ini, fin) {

                    if (!orthoActivo || !ini) return fin;

                    const dx = Math.abs(fin.x - ini.x), dy = Math.abs(fin.y - ini.y), dz = Math.abs(fin.z - ini.z);

                    if (dx >= dy && dx >= dz) return new THREE.Vector3(fin.x, ini.y, ini.z);

                    if (dy >= dx && dy >= dz) return new THREE.Vector3(ini.x, fin.y, ini.z);

                    return new THREE.Vector3(ini.x, ini.y, fin.z);

                }

                // ========== EVENT LISTENERS TOOLBAR ==========

                document.querySelectorAll('.tb-btn').forEach(btn => {

                    btn.addEventListener('click', () => {

                        const a = btn.dataset.action;

                        if (a === 'select') { modo = 'select'; controls.enabled = true; }

                        else if (a === 'line') { modo = 'line'; controls.enabled = false; puntoInicial = null; }

                        else if (a === 'polyline') { modo = 'polyline'; controls.enabled = false; }

                        else if (a === 'snap') {

                            snapActivo = !snapActivo;

                            btn.textContent = snapActivo ? 'Snap ON' : 'Snap OFF';

                            btn.classList.toggle('active', snapActivo);

                        }

                        else if (a === 'ortho') {

                            orthoActivo = !orthoActivo;

                            btn.textContent = orthoActivo ? 'Ortho ON' : 'Ortho OFF';

                            btn.classList.toggle('active', orthoActivo);

                        }

                        else if (a === 'grid') {

                            gridVisible = !gridVisible;

                            gridHelper.visible = gridVisible;

                            btn.classList.toggle('active', gridVisible);

                        }

                        else if (a === 'top' || a === 'front' || a === 'right' || a === '3d') setView(a);

                        else if (a === 'fit') fitView();

                        else if (a === 'undo') {

                            if (lineasHistorial.length > 0) {

                                const ultima = lineasHistorial.pop();

                                lineasGroup.remove(ultima);

                                ultima.geometry.dispose();

                            }

                        }

                        else if (a === 'clear') {

                            while (lineasHistorial.length > 0) {

                                const l = lineasHistorial.pop();

                                lineasGroup.remove(l);

                                l.geometry.dispose();

                            }

                        }

                        else if (a === 'copy-html') {

                            // Capturar estado actual del visor antes de copiar

                            // 1. Actualizar valores de sliders de transparencia en el HTML

                            document.querySelectorAll('.trans-slider').forEach(slider => {

                                slider.setAttribute('value', slider.value);

                            });

                            // 2. Actualizar estado de checkboxes de filtros

                            document.querySelectorAll('.filter-cb').forEach(cb => {

                                if (cb.checked) {

                                    cb.setAttribute('checked', 'checked');

                                } else {

                                    cb.removeAttribute('checked');

                                }

                            });

                            // 3. Guardar posiciÃ³n de cÃ¡mara actual como atributo data

                            const viewerContainer = document.querySelector('.ifc-viewer-container');

                            if (viewerContainer && camera) {

                                viewerContainer.setAttribute('data-camera-x', camera.position.x.toFixed(2));

                                viewerContainer.setAttribute('data-camera-y', camera.position.y.toFixed(2));

                                viewerContainer.setAttribute('data-camera-z', camera.position.z.toFixed(2));

                                viewerContainer.setAttribute('data-target-x', controls.target.x.toFixed(2));

                                viewerContainer.setAttribute('data-target-y', controls.target.y.toFixed(2));

                                viewerContainer.setAttribute('data-target-z', controls.target.z.toFixed(2));

                            }

                            // 4. Guardar nivel actual

                            const levelDisplay = document.getElementById(containerId + '-level-display');

                            if (levelDisplay) {

                                levelDisplay.setAttribute('data-nivel-actual', nivelActual);

                            }

                            // 5. Guardar estado del plano de corte

                            const clipSliderEl = document.getElementById(containerId + '-clip-slider');

                            if (clipSliderEl) {

                                clipSliderEl.setAttribute('value', clipSliderEl.value);

                                clipSliderEl.setAttribute('data-clip-axis', clipAxis || 'none');

                            }

                            // Copiar el HTML actualizado al portapapeles

                            const htmlContent = document.documentElement.outerHTML;

                            navigator.clipboard.writeText(htmlContent).then(() => {

                                btn.textContent = 'Copiado!';

                                btn.style.background = '#27ae60';

                                setTimeout(() => {

                                    btn.textContent = 'Copiar HTML';

                                    btn.style.background = '#16a085';

                                }, 2000);

                            }).catch(err => {

                                console.error('Error copiando HTML:', err);

                                alert('Error al copiar. Intenta de nuevo.');

                            });

                        }

                        else if (a === 'update-editor') {

                            // ========== ACTUALIZAR EDITOR CON HTML COMPLETO MODIFICADO ==========

                            // Capturar el estado actual y actualizar los atributos HTML antes de enviar

                            // 1. Actualizar valores de sliders de transparencia en el HTML

                            document.querySelectorAll('.trans-slider').forEach(function(slider) {

                                slider.setAttribute('value', slider.value);

                            });

                            // 2. Actualizar estado de checkboxes de filtros

                            document.querySelectorAll('.filter-cb').forEach(function(cb) {

                                if (cb.checked) {

                                    cb.setAttribute('checked', 'checked');

                                } else {

                                    cb.removeAttribute('checked');

                                }

                            });

                            // 3. Guardar posiciÃ³n de cÃ¡mara actual como atributo data

                            var viewerContainer = document.querySelector('.ifc-viewer-container');

                            if (viewerContainer && camera) {

                                viewerContainer.setAttribute('data-camera-x', camera.position.x.toFixed(2));

                                viewerContainer.setAttribute('data-camera-y', camera.position.y.toFixed(2));

                                viewerContainer.setAttribute('data-camera-z', camera.position.z.toFixed(2));

                                viewerContainer.setAttribute('data-target-x', controls.target.x.toFixed(2));

                                viewerContainer.setAttribute('data-target-y', controls.target.y.toFixed(2));

                                viewerContainer.setAttribute('data-target-z', controls.target.z.toFixed(2));

                            }

                            // 4. Guardar nivel actual

                            if (levelDisplay) {

                                levelDisplay.setAttribute('data-nivel-actual', nivelActual);

                            }

                            // 5. Guardar estado del plano de corte

                            var clipSliderEl = document.getElementById(containerId + '-clip-slider');

                            if (clipSliderEl) {

                                clipSliderEl.setAttribute('value', clipSliderEl.value);

                                clipSliderEl.setAttribute('data-clip-axis', clipAxis || 'none');

                            }

                            // 6. Obtener el HTML completo actualizado

                            var fullHtml = document.documentElement.outerHTML;

                            // Enviar HTML completo a AvalonEdit via WebView2

                            if (window.chrome && window.chrome.webview) {

                                window.chrome.webview.postMessage({

                                    type: 'updateEditorFull',

                                    content: fullHtml

                                });

                                btn.textContent = 'Actualizado!';

                                btn.style.background = '#27ae60';

                                setTimeout(function() {

                                    btn.textContent = 'Actualizar Editor';

                                    btn.style.background = '#e67e22';

                                }, 2000);

                            } else {

                                // Fallback: copiar al portapapeles si no hay WebView2

                                navigator.clipboard.writeText(fullHtml).then(function() {

                                    btn.textContent = 'Copiado!';

                                    btn.style.background = '#27ae60';

                                    alert('HTML copiado al portapapeles.');

                                    setTimeout(function() {

                                        btn.textContent = 'Actualizar Editor';

                                        btn.style.background = '#e67e22';

                                    }, 2000);

                                });

                            }

                        }

                    });

                });

                // Event listeners filtros

                document.querySelectorAll('.filter-cb').forEach(cb => cb.addEventListener('change', aplicarFiltros));

                // ========== RESTAURAR ESTADO GUARDADO ==========

                // Restaurar transparencias desde atributos value guardados

                document.querySelectorAll('.trans-slider').forEach(slider => {

                    var savedValue = slider.getAttribute('value');

                    if (savedValue && savedValue !== '1') {

                        slider.value = savedValue;

                        var tipo = slider.dataset.type;

                        setTransparency(tipo, parseFloat(savedValue));

                    }

                });

                // Restaurar posiciÃ³n de cÃ¡mara si estÃ¡ guardada

                var viewerContainer = document.querySelector('.ifc-viewer-container');

                if (viewerContainer) {

                    var savedCamX = viewerContainer.getAttribute('data-camera-x');

                    var savedCamY = viewerContainer.getAttribute('data-camera-y');

                    var savedCamZ = viewerContainer.getAttribute('data-camera-z');

                    var savedTgtX = viewerContainer.getAttribute('data-target-x');

                    var savedTgtY = viewerContainer.getAttribute('data-target-y');

                    var savedTgtZ = viewerContainer.getAttribute('data-target-z');

                    if (savedCamX && savedCamY && savedCamZ && camera) {

                        camera.position.set(parseFloat(savedCamX), parseFloat(savedCamY), parseFloat(savedCamZ));

                        if (savedTgtX && savedTgtY && savedTgtZ && controls) {

                            controls.target.set(parseFloat(savedTgtX), parseFloat(savedTgtY), parseFloat(savedTgtZ));

                        }

                        if (controls) controls.update();

                    }

                }

                // Restaurar nivel actual si estÃ¡ guardado

                if (levelDisplay) {

                    var savedNivel = levelDisplay.getAttribute('data-nivel-actual');

                    if (savedNivel !== null && savedNivel !== undefined) {

                        nivelActual = parseInt(savedNivel);

                        if (!isNaN(nivelActual)) {

                            setTimeout(function() { aplicarNivel(); }, 500);

                        }

                    }

                }

                // Restaurar estado del plano de corte

                if (clipSlider) {

                    var savedClipValue = clipSlider.getAttribute('value');

                    var savedClipAxis = clipSlider.getAttribute('data-clip-axis');

                    if (savedClipValue) clipSlider.value = savedClipValue;

                    if (savedClipAxis && savedClipAxis !== 'none') {

                        clipAxis = savedClipAxis;

                        document.querySelectorAll('.clip-axis').forEach(function(b) {

                            if (b.dataset.axis === clipAxis) b.classList.add('active');

                        });

                        setTimeout(function() { aplicarCorte(); }, 600);

                    }

                }

                // IMPORTANTE: Aplicar filtros despuÃ©s de cargar el modelo

                // Los checkboxes ya tienen el estado correcto desde el HTML (checked/unchecked)

                // Esto asegura que los elementos ocultos se mantengan ocultos al recargar

                setTimeout(function() {

                    aplicarFiltros();

                    console.log('Filtros aplicados desde estado guardado');

                }, 700);

                // Event listeners niveles

                document.getElementById(containerId + '-level-up')?.addEventListener('click', () => {

                    if (nivelActual < niveles.length - 1) {

                        nivelActual++;

                        aplicarNivel();

                    }

                });

                document.getElementById(containerId + '-level-down')?.addEventListener('click', () => {

                    if (nivelActual > 0) {

                        nivelActual--;

                        aplicarNivel();

                    }

                });

                // Event listeners corte

                document.querySelectorAll('.clip-axis').forEach(btn => {

                    btn.addEventListener('click', () => {

                        clipAxis = btn.dataset.axis;

                        document.querySelectorAll('.clip-axis').forEach(b => b.classList.remove('active'));

                        if (clipAxis !== 'none') btn.classList.add('active');

                        aplicarCorte();

                    });

                });

                clipSlider?.addEventListener('input', aplicarCorte);

                // ========== EVENTOS DE MOUSE ==========

                canvas.addEventListener('mousemove', (e) => {

                    const pt = getPunto3D(e);

                    coordsEl.textContent = `X: ${pt.x.toFixed(2)} Y: ${pt.y.toFixed(2)} Z: ${pt.z.toFixed(2)}`;

                    if ((modo === 'line' || modo === 'polyline') && puntoInicial) {

                        let fin = pt;

                        if (orthoActivo) fin = aplicarOrtho(puntoInicial, fin);

                        if (lineaTemporal) { lineasGroup.remove(lineaTemporal); lineaTemporal.geometry.dispose(); }

                        const g = new THREE.BufferGeometry().setFromPoints([puntoInicial, fin]);

                        lineaTemporal = new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0xffcc00 }));

                        lineasGroup.add(lineaTemporal);

                        const len = puntoInicial.distanceTo(fin);

                        lineInfoEl.style.display = 'block';

                        lineInfoEl.textContent = `Longitud: ${len.toFixed(2)}`;

                    }

                });

                // FunciÃ³n para deseleccionar elemento

                function deseleccionarElemento() {

                    if (selectedMesh && originalMaterial) {

                        selectedMesh.material = originalMaterial;

                    }

                    selectedMesh = null;

                    originalMaterial = null;

                    if (selectionPanel) selectionPanel.style.display = 'none';

                }

                // FunciÃ³n para seleccionar elemento

                function seleccionarElemento(mesh) {

                    // Deseleccionar anterior

                    deseleccionarElemento();

                    // Seleccionar nuevo

                    selectedMesh = mesh;

                    originalMaterial = mesh.material;

                    mesh.material = selectMaterial;

                    // Mostrar informaciÃ³n

                    if (selectionPanel) {

                        selectionPanel.style.display = 'block';

                        const tipoNombre = {

                            'WALL': 'Muro', 'SLAB': 'Losa', 'COLUMN': 'Columna',

                            'BEAM': 'Viga', 'WINDOW': 'Ventana', 'DOOR': 'Puerta',

                            'STAIR': 'Escalera', 'RAILING': 'Barandilla', 'ROOF': 'Techo',

                            'OTHER': 'Otro'

                        };

                        const tipo = mesh.userData.ifcType || 'OTHER';

                        if (selTipo) selTipo.textContent = tipoNombre[tipo] || tipo;

                        if (selInfo) {

                            mesh.geometry.computeBoundingBox();

                            const box = mesh.geometry.boundingBox;

                            const size = new THREE.Vector3();

                            box.getSize(size);

                            selInfo.innerHTML = `

                                <div>Nivel: ${mesh.userData.nivel !== undefined ? mesh.userData.nivel : '-'}</div>

                                <div>Dimensiones: ${size.x.toFixed(2)} Ã— ${size.y.toFixed(2)} Ã— ${size.z.toFixed(2)} m</div>

                            `;

                        }

                    }

                }

                // Event listener para deseleccionar

                if (selDeselect) {

                    selDeselect.addEventListener('click', deseleccionarElemento);

                }

                canvas.addEventListener('click', (e) => {

                    // Modo selecciÃ³n

                    if (modo === 'select') {

                        const rect = canvas.getBoundingClientRect();

                        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;

                        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                        raycaster.setFromCamera(mouse, camera);

                        const intersects = raycaster.intersectObjects(geometries);

                        if (intersects.length > 0) {

                            seleccionarElemento(intersects[0].object);

                        } else {

                            deseleccionarElemento();

                        }

                    }

                    // Modo dibujo

                    else if (modo === 'line' || modo === 'polyline') {

                        let pt = getPunto3D(e);

                        if (orthoActivo && puntoInicial) pt = aplicarOrtho(puntoInicial, pt);

                        if (!puntoInicial) {

                            puntoInicial = pt;

                        } else {

                            const g = new THREE.BufferGeometry().setFromPoints([puntoInicial, pt]);

                            const linea = new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0xff6600, linewidth: 2 }));

                            lineasGroup.add(linea);

                            lineasHistorial.push(linea);

                            if (modo === 'polyline') {

                                puntoInicial = pt;

                            } else {

                                puntoInicial = null;

                                lineInfoEl.style.display = 'none';

                                if (lineaTemporal) { lineasGroup.remove(lineaTemporal); lineaTemporal = null; }

                            }

                        }

                    }

                });

                // ========== TECLAS DE ACCESO RAPIDO ==========

                document.addEventListener('keydown', (e) => {

                    if (e.key === 'f' || e.key === 'F') fitView();

                    else if (e.key === 'l' || e.key === 'L') { modo = 'line'; controls.enabled = false; puntoInicial = null; }

                    else if (e.key === 's' || e.key === 'S') { modo = 'select'; controls.enabled = true; }

                    else if (e.key === 'g' || e.key === 'G') {

                        gridVisible = !gridVisible;

                        gridHelper.visible = gridVisible;

                    }

                    else if (e.key === 'F3') {

                        snapActivo = !snapActivo;

                        const btn = document.querySelector('.snap-btn');

                        if (btn) {

                            btn.textContent = snapActivo ? 'Snap ON' : 'Snap OFF';

                            btn.classList.toggle('active', snapActivo);

                        }

                    }

                    else if (e.key === 'F8') {

                        orthoActivo = !orthoActivo;

                        const btn = document.querySelector('.ortho-btn');

                        if (btn) {

                            btn.textContent = orthoActivo ? 'Ortho ON' : 'Ortho OFF';

                            btn.classList.toggle('active', orthoActivo);

                        }

                    }

                    else if (e.key === 'Escape') {

                        // Cancelar dibujo y deseleccionar

                        puntoInicial = null;

                        lineInfoEl.style.display = 'none';

                        if (lineaTemporal) { lineasGroup.remove(lineaTemporal); lineaTemporal = null; }

                        deseleccionarElemento();

                        modo = 'select';

                        controls.enabled = true;

                    }

                    else if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {

                        e.preventDefault();

                        e.stopPropagation();

                        // Primero intentar deshacer lÃ­neas dibujadas

                        if (lineasHistorial.length > 0) {

                            const ultima = lineasHistorial.pop();

                            lineasGroup.remove(ultima);

                            ultima.geometry.dispose();

                            console.log('LÃ­nea deshecha');

                        }

                        // Si no hay lÃ­neas, restaurar modelo analÃ­tico anterior

                        else if (analyticHistory.length > 0) {

                            restoreAnalyticState(analyticHistory.pop());

                            console.log('Modelo analÃ­tico restaurado');

                        }

                        // Si no hay historial pero hay modelo, limpiar

                        else if (analyticModel.members.length > 0) {

                            clearAnalyticModel();

                            console.log('Modelo analÃ­tico limpiado');

                        }

                    }

                });

                // ========== FUNCIONES DE TRANSPARENCIA ==========

                function setTransparency(type, opacity) {

                    const elems = elementsByType[type] || [];

                    elems.forEach(mesh => {

                        mesh.material.opacity = opacity;

                        mesh.material.transparent = opacity < 1;

                        mesh.material.needsUpdate = true;

                    });

                }

                // ========== FUNCIONES DE MODELO ANALITICO ==========

                function findOrCreateNode(pos, tol = 0.01) {

                    for (const node of analyticModel.nodes) {

                        if (node.pos.distanceTo(pos) < tol) return node;

                    }

                    const newNode = { id: analyticModel.nextNodeId++, pos: pos.clone(), members: [] };

                    analyticModel.nodes.push(newNode);

                    return newNode;

                }

                function createAnalyticMember(p1, p2, type, name, section) {

                    const color = analyticColors[type] || 0xffffff;

                    const length = p1.distanceTo(p2);

                    if (length < 0.01) return;

                    const node1 = findOrCreateNode(p1);

                    const node2 = findOrCreateNode(p2);

                    const tubeGeom = new THREE.CylinderGeometry(0.08, 0.08, length, 8);

                    const tubeMat = new THREE.MeshBasicMaterial({ color });

                    const tube = new THREE.Mesh(tubeGeom, tubeMat);

                    const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);

                    tube.position.copy(midPoint);

                    const direction = new THREE.Vector3().subVectors(p2, p1).normalize();

                    const up = new THREE.Vector3(0, 1, 0);

                    tube.quaternion.setFromUnitVectors(up, direction);

                    const nodeMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });

                    const nodeGeom = new THREE.SphereGeometry(0.12, 12, 12);

                    const sphere1 = new THREE.Mesh(nodeGeom, nodeMat);

                    sphere1.position.copy(p1);

                    const sphere2 = new THREE.Mesh(nodeGeom, nodeMat);

                    sphere2.position.copy(p2);

                    const group = new THREE.Group();

                    group.add(tube, sphere1, sphere2);

                    analyticGroup.add(group);

                    analyticModel.members.push({

                        id: analyticModel.nextId++,

                        name, type, section, length,

                        node1: node1.id,

                        node2: node2.id,

                        color,

                        group

                    });

                    node1.members.push(analyticModel.members[analyticModel.members.length - 1].id);

                    node2.members.push(analyticModel.members[analyticModel.members.length - 1].id);

                }

                function updateAnalyticPanel() {

                    const colCount = analyticModel.members.filter(m => m.type === 'column').length;

                    const beamCount = analyticModel.members.filter(m => m.type === 'beam').length;

                    const statCols = document.getElementById(containerId + '-stat-cols');

                    const statBeams = document.getElementById(containerId + '-stat-beams');

                    const statNodes = document.getElementById(containerId + '-stat-nodes');

                    const statLength = document.getElementById(containerId + '-stat-length');

                    if (statCols) statCols.textContent = colCount;

                    if (statBeams) statBeams.textContent = beamCount;

                    if (statNodes) statNodes.textContent = analyticModel.nodes.length;

                    const total = analyticModel.members.reduce((s, m) => s + m.length, 0);

                    if (statLength) statLength.textContent = total.toFixed(2) + ' m';

                }

                function clearAnalyticModel() {

                    while (analyticGroup.children.length) analyticGroup.remove(analyticGroup.children[0]);

                    analyticModel = { members: [], nodes: [], nextId: 1, nextNodeId: 1 };

                    updateAnalyticPanel();

                }

                // Guardar estado actual del modelo analÃ­tico

                function saveAnalyticState() {

                    if (analyticModel.members.length === 0) return;

                    // Clonar el estado actual (solo datos, no geometrÃ­a)

                    const state = {

                        members: analyticModel.members.map(m => ({...m, p1: m.p1.clone(), p2: m.p2.clone()})),

                        nodes: analyticModel.nodes.map(n => ({...n, position: n.position.clone()})),

                        nextId: analyticModel.nextId,

                        nextNodeId: analyticModel.nextNodeId

                    };

                    analyticHistory.push(state);

                    // Limitar historial a 20 estados

                    if (analyticHistory.length > 20) analyticHistory.shift();

                    console.log('Estado guardado, historial:', analyticHistory.length);

                }

                // Restaurar estado guardado

                function restoreAnalyticState(state) {

                    clearAnalyticModel();

                    if (!state) return;

                    analyticModel.nextId = state.nextId;

                    analyticModel.nextNodeId = state.nextNodeId;

                    // Recrear miembros

                    for (const m of state.members) {

                        createAnalyticMember(m.p1, m.p2, m.type, m.name, m.section);

                    }

                    updateAnalyticPanel();

                }

                // ========== FUNCIONES PARA DIVIDIR MESH FÃSICO DE COLUMNAS ==========
                let dividedColumnMeshes = []; // Almacena meshes divididos para poder restaurarlos

                function divideColumnMeshByLevels(col, levels) {
                    if (!col.mesh) return;
                    const mesh = col.mesh;
                    const box = new THREE.Box3().setFromObject(mesh);
                    const minY = box.min.y;
                    const maxY = box.max.y;

                    // Filtrar niveles dentro de esta columna
                    const relevantLevels = levels.filter(y => y > minY + 0.1 && y < maxY - 0.1).sort((a,b) => a-b);
                    if (relevantLevels.length === 0) return; // Sin divisiÃ³n necesaria

                    // Ocultar mesh original
                    mesh.visible = false;
                    col.originalVisible = true;

                    // Crear segmentos
                    let prevY = minY;
                    const segments = [];

                    for (const levelY of [...relevantLevels, maxY]) {
                        const segment = cloneAndCropColumnMesh(mesh, prevY, levelY);
                        if (segment) {
                            segment.userData.isColumnSegment = true;
                            segment.userData.parentColumn = col;
                            allMeshes.add(segment);
                            geometries.push(segment);
                            segments.push(segment);
                        }
                        prevY = levelY;
                    }

                    dividedColumnMeshes.push({ col, segments });
                    console.log('Columna fÃ­sica dividida en', segments.length, 'segmentos');
                }

                function cloneAndCropColumnMesh(mesh, yMin, yMax) {
                    try {
                        const geometry = mesh.geometry.clone();
                        const positions = geometry.attributes.position.array;

                        // Recortar vÃ©rtices en Y
                        for (let i = 1; i < positions.length; i += 3) {
                            if (positions[i] < yMin) positions[i] = yMin;
                            if (positions[i] > yMax) positions[i] = yMax;
                        }

                        geometry.attributes.position.needsUpdate = true;
                        geometry.computeBoundingBox();
                        geometry.computeVertexNormals();

                        const newMesh = new THREE.Mesh(geometry, mesh.material.clone());
                        newMesh.userData.ifcType = 'COLUMN';
                        return newMesh;
                    } catch (e) {
                        console.error('Error clonando columna:', e);
                        return null;
                    }
                }

                function restoreOriginalColumns() {
                    // Eliminar meshes divididos
                    for (const item of dividedColumnMeshes) {
                        for (const seg of item.segments) {
                            allMeshes.remove(seg);
                            const idx = geometries.indexOf(seg);
                            if (idx > -1) geometries.splice(idx, 1);
                            seg.geometry.dispose();
                        }
                        // Restaurar visibilidad del mesh original
                        if (item.col.mesh) item.col.mesh.visible = true;
                    }
                    dividedColumnMeshes = [];
                    console.log('Columnas fÃ­sicas restauradas');
                }

                function generateAutoAnalyticalModel() {
                    // Guardar estado antes de regenerar
                    saveAnalyticState();

                    clearAnalyticModel();

                    // Leer checkboxes para saber quÃ© generar

                    const genColumns = document.getElementById(containerId + '-chk-columns')?.checked ?? true;

                    const genBeams = document.getElementById(containerId + '-chk-beams')?.checked ?? true;

                    console.log('Generando modelo analÃ­tico...');

                    console.log('Generar columnas:', genColumns, 'Generar vigas:', genBeams);

                    console.log('Columnas fÃ­sicas:', columnCenters.length, 'Vigas fÃ­sicas:', elementsByType.BEAM.length);

                    console.log('Niveles losa:', slabLevels);

                    // 1. Generar columnas (divididas o unidas segÃºn configuraciÃ³n)

                    if (genColumns) {

                    // Usar slabLevels si hay, sino usar nivelesY
                    const divisionLevels = slabLevels.length > 0 ? slabLevels : nivelesY;
                    console.log('Niveles para divisiÃ³n:', divisionLevels, 'divideByFloor:', divideByFloor);

                    // Primero restaurar columnas fÃ­sicas originales
                    restoreOriginalColumns();

                    // Si divideByFloor, tambiÃ©n dividir meshes fÃ­sicos
                    if (divideByFloor && divisionLevels.length > 0) {
                        for (const col of columnCenters) {
                            divideColumnMeshByLevels(col, divisionLevels);
                        }
                    }

                    for (const col of columnCenters) {
                        if (divideByFloor && divisionLevels.length > 0) {

                            // Dividir columnas por niveles de losa

                            // Filtrar solo niveles que estÃ¡n dentro de esta columna

                            const relevantLevels = divisionLevels.filter(

                                y => y > col.minY + 0.05 && y < col.maxY - 0.05

                            );

                            if (relevantLevels.length === 0) {

                                // No hay niveles intermedios, crear columna Ãºnica

                                createAnalyticMember(

                                    new THREE.Vector3(col.x, col.minY, col.z),

                                    new THREE.Vector3(col.x, col.maxY, col.z),

                                    'column',

                                    'C-' + analyticModel.nextId,

                                    '30x30'

                                );

                                console.log('Columna sin divisiÃ³n en', col.x.toFixed(2), col.z.toFixed(2));

                            } else {

                                // Crear segmentos divididos por nivel

                                let prevY = col.minY;

                                let segmentCount = 0;

                                for (const levelY of relevantLevels) {

                                    createAnalyticMember(

                                        new THREE.Vector3(col.x, prevY, col.z),

                                        new THREE.Vector3(col.x, levelY, col.z),

                                        'column',

                                        'C-' + analyticModel.nextId,

                                        '30x30'

                                    );

                                    prevY = levelY;

                                    segmentCount++;

                                }

                                // Ãšltimo segmento hasta el tope

                                createAnalyticMember(

                                    new THREE.Vector3(col.x, prevY, col.z),

                                    new THREE.Vector3(col.x, col.maxY, col.z),

                                    'column',

                                    'C-' + analyticModel.nextId,

                                    '30x30'

                                );

                                console.log('Columna dividida en', col.x.toFixed(2), col.z.toFixed(2), '- segmentos:', segmentCount + 1);

                            }

                        } else {

                            // Columna Ãºnica sin divisiÃ³n

                            createAnalyticMember(

                                new THREE.Vector3(col.x, col.minY, col.z),

                                new THREE.Vector3(col.x, col.maxY, col.z),

                                'column',

                                'C-' + analyticModel.nextId,

                                '30x30'

                            );

                        }

                    }

                    } // fin if genColumns

                    // 2. Generar vigas (en la parte superior, al nivel de cabeza de columna)

                    if (genBeams) {

                    for (const beamMesh of elementsByType.BEAM) {

                        beamMesh.geometry.computeBoundingBox();

                        const beamBox = new THREE.Box3().setFromObject(beamMesh);

                        const beamCenter = beamBox.getCenter(new THREE.Vector3());

                        const beamSize = beamBox.getSize(new THREE.Vector3());

                        const isXBeam = beamSize.x > beamSize.z;

                        // Usar parte superior de la viga (max.y) para coincidir con cabeza de columna

                        const beamY = beamBox.max.y;

                        let startPt, endPt;

                        if (isXBeam) {

                            startPt = new THREE.Vector3(beamBox.min.x, beamY, beamCenter.z);

                            endPt = new THREE.Vector3(beamBox.max.x, beamY, beamCenter.z);

                        } else {

                            startPt = new THREE.Vector3(beamCenter.x, beamY, beamBox.min.z);

                            endPt = new THREE.Vector3(beamCenter.x, beamY, beamBox.max.z);

                        }

                        const intersections = [];

                        const tol = 0.5;

                        for (const col of columnCenters) {

                            if (beamY >= col.minY && beamY <= col.maxY) {

                                if (isXBeam) {

                                    if (Math.abs(col.z - beamCenter.z) < tol) {

                                        if (col.x > beamBox.min.x + tol && col.x < beamBox.max.x - tol) {

                                            intersections.push(col.x);

                                        }

                                    }

                                } else {

                                    if (Math.abs(col.x - beamCenter.x) < tol) {

                                        if (col.z > beamBox.min.z + tol && col.z < beamBox.max.z - tol) {

                                            intersections.push(col.z);

                                        }

                                    }

                                }

                            }

                        }

                        intersections.sort((a, b) => a - b);

                        if (intersections.length === 0) {

                            createAnalyticMember(startPt, endPt, 'beam', 'V-' + analyticModel.nextId, '30x50');

                        } else {

                            let prevPt = startPt.clone();

                            for (const inter of intersections) {

                                const interPt = isXBeam

                                    ? new THREE.Vector3(inter, beamY, beamCenter.z)

                                    : new THREE.Vector3(beamCenter.x, beamY, inter);

                                createAnalyticMember(prevPt, interPt, 'beam', 'V-' + analyticModel.nextId, '30x50');

                                prevPt = interPt.clone();

                            }

                            createAnalyticMember(prevPt, endPt, 'beam', 'V-' + analyticModel.nextId, '30x50');

                        }

                    }

                    } // fin if genBeams

                    updateAnalyticPanel();

                    const colCount = analyticModel.members.filter(m => m.type === 'column').length;

                    const beamCount = analyticModel.members.filter(m => m.type === 'beam').length;

                    console.log('Modelo analÃ­tico generado:', analyticModel.members.length, 'miembros');

                    console.log('  - Columnas:', colCount, '  - Vigas:', beamCount);

                }

                function exportAnalyticModel() {

                    const data = {

                        nodes: analyticModel.nodes.map(n => ({ id: n.id, x: n.pos.x, y: n.pos.y, z: n.pos.z })),

                        members: analyticModel.members.map(m => ({

                            id: m.id, name: m.name, type: m.type, section: m.section,

                            node1: m.node1, node2: m.node2, length: m.length

                        }))

                    };

                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });

                    const a = document.createElement('a');

                    a.href = URL.createObjectURL(blob);

                    a.download = 'modelo_analitico.json';

                    a.click();

                }

                // Exportar modelo analÃ­tico a IFC

                async function exportToIFC() {

                    if (analyticModel.members.length === 0) {

                        alert('No hay modelo analÃ­tico para exportar');

                        return;

                    }

                    try {

                        updateStatus('Creando modelo IFC...', 30);

                        // Crear nueva instancia de web-ifc

                        const ifcApiExport = new WebIFC.IfcAPI();

                        await ifcApiExport.Init(function(path) {

                            if (path.endsWith('.wasm')) {

                                return 'https://calcpad.ifc/web-ifc.wasm';

                            }

                            return path;

                        });

                        // Crear nuevo modelo IFC4

                        const newModelID = ifcApiExport.CreateModel({

                            schema: 'IFC4'

                        });

                        // Helper para crear GUIDs

                        const guid = () => ifcApiExport.CreateIfcGloballyUniqueId(newModelID);

                        // Sin owner history por simplicidad

                        const owner = null;

                        const project = ifcApiExport.CreateIfcEntity(newModelID, WebIFC.IFCPROJECT,

                            guid(),

                            owner,

                            ifcApiExport.CreateIfcType(newModelID, WebIFC.IFCLABEL, 'Modelo Analitico Calcpad'),

                            null, null, null, null, null, null

                        );

                        ifcApiExport.WriteLine(newModelID, project);

                        // Crear cada miembro como IfcColumn/IfcBeam

                        let exportedCount = 0;

                        for (const member of analyticModel.members) {

                            const ifcType = member.type === 'column' ? WebIFC.IFCCOLUMN : WebIFC.IFCBEAM;

                            // Crear puntos

                            const pt1 = ifcApiExport.CreateIfcEntity(newModelID, WebIFC.IFCCARTESIANPOINT,

                                [member.p1.x, member.p1.y, member.p1.z]

                            );

                            const pt2 = ifcApiExport.CreateIfcEntity(newModelID, WebIFC.IFCCARTESIANPOINT,

                                [member.p2.x, member.p2.y, member.p2.z]

                            );

                            ifcApiExport.WriteLine(newModelID, pt1);

                            ifcApiExport.WriteLine(newModelID, pt2);

                            // Crear lÃ­nea

                            const polyline = ifcApiExport.CreateIfcEntity(newModelID, WebIFC.IFCPOLYLINE,

                                [pt1, pt2]

                            );

                            ifcApiExport.WriteLine(newModelID, polyline);

                            // Crear elemento estructural

                            const elem = ifcApiExport.CreateIfcEntity(newModelID, ifcType,

                                guid(),

                                owner,

                                ifcApiExport.CreateIfcType(newModelID, WebIFC.IFCLABEL, member.name),

                                null, null, null, null, null

                            );

                            ifcApiExport.WriteLine(newModelID, elem);

                            exportedCount++;

                        }

                        updateStatus('Guardando archivo IFC...', 80);

                        // Exportar a buffer

                        const ifcData = ifcApiExport.SaveModel(newModelID);

                        // Descargar archivo

                        const blobIfc = new Blob([ifcData], { type: 'application/x-step' });

                        const linkIfc = document.createElement('a');

                        linkIfc.href = URL.createObjectURL(blobIfc);

                        linkIfc.download = 'modelo_analitico.ifc';

                        linkIfc.click();

                        updateStatus('IFC exportado: ' + exportedCount + ' elementos', 100);

                        setTimeout(() => updateStatus('Modelo cargado', 100), 2000);

                        ifcApiExport.CloseModel(newModelID);

                    } catch (err) {

                        console.error('Error exportando IFC:', err);

                        alert('Error exportando IFC: ' + err.message);

                        updateStatus('Error en exportaciÃ³n', 0);

                    }

                }

                // ========== EVENT LISTENERS ADICIONALES ==========

                // Panel de transparencia

                const transPanel = document.getElementById(containerId + '-transparency');

                document.querySelectorAll('.trans-slider').forEach(slider => {

                    slider.addEventListener('input', (e) => {

                        setTransparency(e.target.dataset.type, parseFloat(e.target.value));

                    });

                });

                const transReset = document.getElementById(containerId + '-trans-reset');

                if (transReset) {

                    transReset.addEventListener('click', () => {

                        document.querySelectorAll('.trans-slider').forEach(slider => {

                            slider.value = 1;

                            setTransparency(slider.dataset.type, 1);

                        });

                    });

                }

                // Panel de modelo analÃ­tico

                const analyticPanel = document.getElementById(containerId + '-analytic');

                const showPhysical = document.getElementById(containerId + '-show-physical');

                const showAnalytic = document.getElementById(containerId + '-show-analytic');

                const exportBtn = document.getElementById(containerId + '-export-model');

                const clearBtn = document.getElementById(containerId + '-clear-model');

                if (showPhysical) showPhysical.addEventListener('change', (e) => { allMeshes.visible = e.target.checked; });

                if (showAnalytic) showAnalytic.addEventListener('change', (e) => { analyticGroup.visible = e.target.checked; });

                if (exportBtn) exportBtn.addEventListener('click', exportAnalyticModel);

                if (clearBtn) clearBtn.addEventListener('click', clearAnalyticModel);

                // BotÃ³n para exportar a IFC

                const exportIfcBtn = document.getElementById(containerId + '-export-ifc');

                if (exportIfcBtn) exportIfcBtn.addEventListener('click', exportToIFC);

                // BotÃ³n para dividir/unir columnas por piso

                const divideBtn = document.getElementById(containerId + '-divide-elements');

                if (divideBtn) {

                    divideBtn.addEventListener('click', () => {

                        divideByFloor = !divideByFloor;

                        divideBtn.textContent = divideByFloor ? 'Dividir por Piso' : 'Unir Columnas';

                        divideBtn.style.background = divideByFloor ? '#e67e22' : '#3498db';

                        generateAutoAnalyticalModel();

                    });

                }

                // Botones del toolbar para transparencia y modelo analÃ­tico

                document.querySelector('.trans-btn')?.addEventListener('click', () => {

                    if (transPanel) transPanel.style.display = transPanel.style.display === 'none' ? 'block' : 'none';

                });

                document.querySelector('.analytic-btn')?.addEventListener('click', generateAutoAnalyticalModel);

                // BotÃ³n "Generar Modelo" en el panel analÃ­tico

                document.getElementById(containerId + '-gen-analytic')?.addEventListener('click', generateAutoAnalyticalModel);

                document.querySelector('.model-btn')?.addEventListener('click', () => {

                    if (analyticPanel) analyticPanel.style.display = analyticPanel.style.display === 'none' ? 'block' : 'none';

                });

                // Teclas T, A, M, Ctrl+U

                document.addEventListener('keydown', (e) => {

                    if (e.key === 't' || e.key === 'T') {

                        if (transPanel) transPanel.style.display = transPanel.style.display === 'none' ? 'block' : 'none';

                    }

                    else if (e.key === 'a' || e.key === 'A') {

                        generateAutoAnalyticalModel();

                    }

                    else if (e.key === 'm' || e.key === 'M') {

                        if (analyticPanel) analyticPanel.style.display = analyticPanel.style.display === 'none' ? 'block' : 'none';

                    }

                    else if (e.ctrlKey && (e.key === 'u' || e.key === 'U')) {

                        // Ctrl+U: Actualizar editor

                        e.preventDefault();

                        const updateBtn = document.querySelector('[data-action="update-editor"]');

                        if (updateBtn) updateBtn.click();

                    }

                });

                // ========== LOOP DE ANIMACION ==========

                function animate() {

                    requestAnimationFrame(animate);

                    controls.update();

                    renderer.render(scene, camera);

                }

                animate();

                // ========== RESIZE ==========

                window.addEventListener('resize', () => {

                    camera.aspect = container.clientWidth / container.clientHeight;

                    camera.updateProjectionMatrix();

                    renderer.setSize(container.clientWidth, container.clientHeight);

                });

            } catch (error) {

                console.error('IFC Viewer Error:', error);

                if (loading) {

                    loading.innerHTML = '<p style="color: #dc3545;">Error: ' + error.message + '</p>';

                }

            }

        })();

    </script>

 </body></html>
@{end html-ifc}
@{end code}