"IFC Viewer con Grillas y Sistema de Snaps
@{html-ifc}
<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>IFC Viewer + Grillas + Snaps</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #fff;
            user-select: none;
        }
        #container { width: 100%; height: 100%; position: relative; }
        canvas { width: 100%; height: 100%; display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            background: rgba(0,0,0,0.92);
            padding: 5px 8px;
            border-radius: 6px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .toolbar button {
            background: #2d2d44;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 9px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .toolbar button:hover { background: #3d3d5c; border-color: #0078d4; }
        .toolbar button.active { background: #0078d4; border-color: #0078d4; }
        .toolbar button.snap-active { background: #27ae60; border-color: #27ae60; }
        .toolbar-sep { width: 1px; background: #444; margin: 0 3px; }

        /* Panel base */
        .panel {
            position: absolute;
            background: rgba(10,10,20,0.95);
            padding: 10px;
            border-radius: 6px;
            font-size: 10px;
            z-index: 100;
            border: 1px solid #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .panel h4 {
            color: #0078d4;
            margin-bottom: 8px;
            font-size: 11px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .panel label { display: block; color: #888; margin-bottom: 2px; margin-top: 6px; font-size: 9px; }
        .panel input[type="number"], .panel input[type="text"] {
            width: 100%;
            padding: 4px 6px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-size: 10px;
        }
        .panel input:focus { border-color: #0078d4; outline: none; }
        .panel button {
            width: 100%;
            padding: 6px;
            margin-top: 8px;
            background: #0078d4;
            border: none;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .panel button:hover { background: #0066b8; }
        .panel button.secondary { background: #444; }
        .panel button.secondary:hover { background: #555; }
        .panel-row { display: flex; gap: 6px; }
        .panel-row > div { flex: 1; }

        /* Grid Panel */
        .grid-panel { top: 50px; left: 10px; width: 200px; display: none; }
        .grid-panel.visible { display: block; }

        /* Snap Panel */
        .snap-panel { top: 50px; right: 10px; width: 180px; display: none; }
        .snap-panel.visible { display: block; }
        .snap-option { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
        .snap-option input { margin: 0; }
        .snap-option label { margin: 0; color: #ccc; cursor: pointer; }
        .snap-option.disabled label { color: #666; }

        /* Align Panel */
        .align-panel { bottom: 60px; left: 10px; width: 200px; display: none; }
        .align-panel.visible { display: block; }
        .slider-row { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
        .slider-row label { margin: 0; min-width: 35px; color: #888; }
        .slider-row input[type="range"] { flex: 1; height: 4px; }
        .slider-row .val { min-width: 40px; text-align: right; color: #fff; font-family: monospace; }

        /* Info panel */
        .info-panel { bottom: 10px; left: 10px; max-width: 200px; }
        .info-panel strong { color: #0078d4; font-size: 11px; }

        /* Snap indicator */
        .snap-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            display: none;
        }
        .snap-indicator.visible { display: block; }
        .snap-indicator .marker {
            width: 16px;
            height: 16px;
            border: 2px solid #f1c40f;
            border-radius: 50%;
            background: rgba(241, 196, 15, 0.3);
            position: absolute;
            transform: translate(-50%, -50%);
        }
        .snap-indicator .label {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(241, 196, 15, 0.9);
            color: #000;
            padding: 2px 5px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Grid labels */
        .grid-label {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            pointer-events: none;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* Coords display */
        .coords-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
        }
        .coords-display span { color: #0078d4; }

        /* Loading */
        .loading {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26,26,46,0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 3px solid #333; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; }
        .progress { width: 180px; height: 4px; background: #333; border-radius: 2px; margin-top: 12px; }
        .progress-fill { height: 100%; background: #0078d4; width: 0%; transition: width 0.3s; }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <!-- Toolbar -->
        <div class="toolbar">
            <button id="btn-3d" class="active" title="Vista 3D (1)">3D</button>
            <button id="btn-top" title="Planta (2)">Planta</button>
            <button id="btn-front" title="Frontal (3)">Frontal</button>
            <button id="btn-right" title="Lateral (4)">Lateral</button>
            <div class="toolbar-sep"></div>
            <button id="btn-grids" title="Panel Grillas (G)">Grillas</button>
            <button id="btn-align" title="Alinear Grillas (A)">Alinear</button>
            <div class="toolbar-sep"></div>
            <button id="btn-snap" title="Toggle Snap (S)">Snap</button>
            <button id="btn-snap-opts" title="Opciones Snap">Opts</button>
            <div class="toolbar-sep"></div>
            <button id="btn-fit" title="Fit (F)">Fit</button>
        </div>

        <!-- Grid Panel -->
        <div id="grid-panel" class="panel grid-panel">
            <h4>Crear Grillas</h4>
            <div class="panel-row">
                <div>
                    <label>Ejes X</label>
                    <input type="number" id="grid-x-count" value="5" min="2" max="20">
                </div>
                <div>
                    <label>Espac. X (m)</label>
                    <input type="number" id="grid-x-space" value="5" min="0.5" step="0.5">
                </div>
            </div>
            <div class="panel-row">
                <div>
                    <label>Ejes Y</label>
                    <input type="number" id="grid-y-count" value="4" min="2" max="20">
                </div>
                <div>
                    <label>Espac. Y (m)</label>
                    <input type="number" id="grid-y-space" value="4" min="0.5" step="0.5">
                </div>
            </div>
            <label>Nombres X (A,B,C...)</label>
            <input type="text" id="grid-x-names" value="A,B,C,D,E,F,G,H,I,J,K">
            <label>Nombres Y (1,2,3...)</label>
            <input type="text" id="grid-y-names" value="1,2,3,4,5,6,7,8,9,10">
            <button id="btn-create-grid">Crear Grillas</button>
            <button id="btn-clear-grid" class="secondary">Limpiar</button>
        </div>

        <!-- Snap Options Panel -->
        <div id="snap-panel" class="panel snap-panel">
            <h4>Opciones de Snap</h4>
            <div class="snap-option"><input type="checkbox" id="snap-endpoint" checked><label for="snap-endpoint">Punto Final</label></div>
            <div class="snap-option"><input type="checkbox" id="snap-midpoint" checked><label for="snap-midpoint">Punto Medio</label></div>
            <div class="snap-option"><input type="checkbox" id="snap-center" checked><label for="snap-center">Centro</label></div>
            <div class="snap-option"><input type="checkbox" id="snap-quadrant" checked><label for="snap-quadrant">Cuadrante</label></div>
            <div class="snap-option"><input type="checkbox" id="snap-intersection"><label for="snap-intersection">Intersección</label></div>
            <div class="snap-option"><input type="checkbox" id="snap-gridline" checked><label for="snap-gridline">Línea de Grilla</label></div>
            <div class="snap-option"><input type="checkbox" id="snap-gridnode" checked><label for="snap-gridnode">Nodo de Grilla</label></div>
            <label style="margin-top:8px">Tolerancia (px)</label>
            <input type="number" id="snap-tolerance" value="15" min="5" max="50">
        </div>

        <!-- Align Panel -->
        <div id="align-panel" class="panel align-panel">
            <h4>Alinear Grillas</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="align-x" min="-100" max="100" value="0" step="0.1">
                <span class="val" id="align-x-val">0.0</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="align-y" min="-100" max="100" value="0" step="0.1">
                <span class="val" id="align-y-val">0.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="align-z" min="-100" max="100" value="0" step="0.1">
                <span class="val" id="align-z-val">0.0</span>
            </div>
            <div class="slider-row">
                <label>Rot:</label>
                <input type="range" id="align-rot" min="-180" max="180" value="0" step="1">
                <span class="val" id="align-rot-val">0°</span>
            </div>
            <button id="btn-auto-align">Auto-Alinear</button>
            <button id="btn-reset-align" class="secondary">Reset</button>
        </div>

        <!-- Info -->
        <div class="panel info-panel">
            <strong>IFC + Grillas + Snaps</strong>
            <div id="stats"></div>
            <div style="color:#555;margin-top:5px;font-size:9px">
                1-4: Vistas | F: Fit | G: Grillas<br>
                S: Snap | A: Alinear
            </div>
        </div>

        <!-- Coords -->
        <div class="coords-display">
            X: <span id="coord-x">0.00</span> |
            Y: <span id="coord-y">0.00</span> |
            Z: <span id="coord-z">0.00</span>
        </div>

        <!-- Snap indicator -->
        <div id="snap-indicator" class="snap-indicator">
            <div class="marker"></div>
            <div class="label" id="snap-label">Punto Final</div>
        </div>

        <!-- Grid labels container -->
        <div id="grid-labels"></div>

        <!-- Loading -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <p style="margin-top:12px;color:#888;font-size:11px" id="status">Cargando...</p>
        </div>
    </div>

    <script src="https://calcpad.ifc/three.min.js"></script>
    <script src="https://calcpad.ifc/OrbitControls.js"></script>
    <script src="https://calcpad.ifc/web-ifc-api-iife.js"></script>
    <script>
    (async function() {
        // ========== DOM ELEMENTS ==========
        const canvas = document.getElementById('canvas');
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const gridLabels = document.getElementById('grid-labels');
        const snapIndicator = document.getElementById('snap-indicator');
        const snapLabel = document.getElementById('snap-label');

        // ========== STATE ==========
        let scene, camera, orthoCamera, renderer, controls;
        let allMeshes, gridGroup, bbox, center, maxDim;
        let currentView = '3d';

        // Snap state
        let snapEnabled = true;
        let snapOptions = {
            endpoint: true,
            midpoint: true,
            center: true,
            quadrant: true,
            intersection: false,
            gridline: true,
            gridnode: true,
            tolerance: 15
        };
        let snapPoints = []; // All snap points in 3D
        let currentSnapPoint = null;

        // Grid state
        let gridData = {
            xAxes: [],
            yAxes: [],
            nodes: []
        };

        function updateProgress(msg, pct) {
            status.textContent = msg;
            progress.style.width = pct + '%';
        }

        try {
            updateProgress('Inicializando Three.js...', 10);

            // ========== SCENE SETUP ==========
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            camera.position.set(50, 50, 50);

            const aspect = container.clientWidth / container.clientHeight;
            orthoCamera = new THREE.OrthographicCamera(-50*aspect, 50*aspect, 50, -50, 0.1, 10000);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(50, 100, 50);
            scene.add(light);

            // Floor grid
            scene.add(new THREE.GridHelper(200, 200, 0x333333, 0x222222));

            // Grid group
            gridGroup = new THREE.Group();
            gridGroup.name = 'structuralGrids';
            scene.add(gridGroup);

            // ========== LOAD IFC ==========
            updateProgress('Descargando IFC...', 20);
            const response = await fetch('https://calcpad.ifc/temp_a7ce813c013e4fc48bd57558ccf7ebd6.ifc');
            if (!response.ok) throw new Error('Error: ' + response.status);

            updateProgress('Leyendo datos...', 40);
            const ifcData = await response.arrayBuffer();

            updateProgress('Inicializando web-ifc...', 50);
            const ifcApi = new WebIFC.IfcAPI();
            await ifcApi.Init(p => p.endsWith('.wasm') ? 'https://calcpad.ifc/' + p : p);

            updateProgress('Parseando IFC...', 60);
            const modelID = ifcApi.OpenModel(new Uint8Array(ifcData));

            updateProgress('Generando geometría...', 70);
            const flatMeshes = ifcApi.LoadAllGeometry(modelID);

            updateProgress('Construyendo mallas...', 80);
            allMeshes = new THREE.Group();
            let meshCount = 0;

            for (let i = 0; i < flatMeshes.size(); i++) {
                const fm = flatMeshes.get(i);
                const geoms = fm.geometries;

                for (let j = 0; j < geoms.size(); j++) {
                    const pg = geoms.get(j);
                    const geom = ifcApi.GetGeometry(modelID, pg.geometryExpressID);
                    const verts = ifcApi.GetVertexArray(geom.GetVertexData(), geom.GetVertexDataSize());
                    const indices = ifcApi.GetIndexArray(geom.GetIndexData(), geom.GetIndexDataSize());

                    if (verts.length === 0 || indices.length === 0) continue;

                    const positions = new Float32Array(verts.length / 2);
                    const normals = new Float32Array(verts.length / 2);

                    for (let k = 0; k < verts.length; k += 6) {
                        const idx = (k / 6) * 3;
                        positions[idx] = verts[k];
                        positions[idx + 1] = verts[k + 1];
                        positions[idx + 2] = verts[k + 2];
                        normals[idx] = verts[k + 3];
                        normals[idx + 1] = verts[k + 4];
                        normals[idx + 2] = verts[k + 5];
                    }

                    const bufGeom = new THREE.BufferGeometry();
                    bufGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    bufGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                    bufGeom.setIndex(new THREE.BufferAttribute(indices, 1));

                    const color = new THREE.Color(pg.color.x, pg.color.y, pg.color.z);
                    const mat = new THREE.MeshPhongMaterial({
                        color, side: THREE.DoubleSide,
                        transparent: pg.color.w < 1, opacity: pg.color.w
                    });

                    const mesh = new THREE.Mesh(bufGeom, mat);
                    mesh.applyMatrix4(new THREE.Matrix4().fromArray(pg.flatTransformation));
                    allMeshes.add(mesh);
                    meshCount++;
                }
            }

            scene.add(allMeshes);
            ifcApi.CloseModel(modelID);

            // ========== ADJUST VIEW ==========
            updateProgress('Ajustando vista...', 90);
            bbox = new THREE.Box3().setFromObject(allMeshes);
            center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            maxDim = Math.max(size.x, size.y, size.z);

            camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
            controls.target.copy(center);
            controls.update();

            // Update slider ranges
            ['align-x', 'align-y', 'align-z'].forEach(id => {
                const el = document.getElementById(id);
                el.min = -maxDim * 2;
                el.max = maxDim * 2;
            });

            loading.style.display = 'none';
            document.getElementById('stats').innerHTML = '<br>' + meshCount + ' elementos';

            // ========== SNAP FUNCTIONS ==========
            function updateSnapPoints() {
                snapPoints = [];

                // Add grid snap points
                if (snapOptions.gridnode) {
                    gridData.nodes.forEach(node => {
                        snapPoints.push({
                            position: node.position.clone().applyMatrix4(gridGroup.matrixWorld),
                            type: 'Nodo Grilla',
                            name: node.name
                        });
                    });
                }

                if (snapOptions.gridline) {
                    // Add points along grid lines
                    gridData.xAxes.forEach(axis => {
                        const start = new THREE.Vector3(axis.x, 0, gridData.minZ || -50);
                        const end = new THREE.Vector3(axis.x, 0, gridData.maxZ || 50);
                        start.applyMatrix4(gridGroup.matrixWorld);
                        end.applyMatrix4(gridGroup.matrixWorld);

                        snapPoints.push({ position: start, type: 'Grilla ' + axis.name, name: axis.name + '-start' });
                        snapPoints.push({ position: end, type: 'Grilla ' + axis.name, name: axis.name + '-end' });
                    });

                    gridData.yAxes.forEach(axis => {
                        const start = new THREE.Vector3(gridData.minX || -50, 0, axis.z);
                        const end = new THREE.Vector3(gridData.maxX || 50, 0, axis.z);
                        start.applyMatrix4(gridGroup.matrixWorld);
                        end.applyMatrix4(gridGroup.matrixWorld);

                        snapPoints.push({ position: start, type: 'Grilla ' + axis.name, name: axis.name + '-start' });
                        snapPoints.push({ position: end, type: 'Grilla ' + axis.name, name: axis.name + '-end' });
                    });
                }

                // Add IFC element snap points (from bounding boxes)
                if (snapOptions.endpoint || snapOptions.center) {
                    allMeshes.children.forEach(mesh => {
                        const meshBox = new THREE.Box3().setFromObject(mesh);
                        const meshCenter = meshBox.getCenter(new THREE.Vector3());
                        const meshMin = meshBox.min;
                        const meshMax = meshBox.max;

                        if (snapOptions.center) {
                            snapPoints.push({ position: meshCenter.clone(), type: 'Centro', name: 'center' });
                        }

                        if (snapOptions.endpoint) {
                            // 8 corners of bounding box
                            snapPoints.push({ position: new THREE.Vector3(meshMin.x, meshMin.y, meshMin.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMax.x, meshMin.y, meshMin.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMin.x, meshMax.y, meshMin.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMax.x, meshMax.y, meshMin.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMin.x, meshMin.y, meshMax.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMax.x, meshMin.y, meshMax.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMin.x, meshMax.y, meshMax.z), type: 'Punto Final', name: 'corner' });
                            snapPoints.push({ position: new THREE.Vector3(meshMax.x, meshMax.y, meshMax.z), type: 'Punto Final', name: 'corner' });
                        }

                        if (snapOptions.midpoint) {
                            // Midpoints of edges
                            snapPoints.push({ position: new THREE.Vector3((meshMin.x+meshMax.x)/2, meshMin.y, meshMin.z), type: 'Punto Medio', name: 'mid' });
                            snapPoints.push({ position: new THREE.Vector3((meshMin.x+meshMax.x)/2, meshMax.y, meshMin.z), type: 'Punto Medio', name: 'mid' });
                            snapPoints.push({ position: new THREE.Vector3((meshMin.x+meshMax.x)/2, meshMin.y, meshMax.z), type: 'Punto Medio', name: 'mid' });
                            snapPoints.push({ position: new THREE.Vector3((meshMin.x+meshMax.x)/2, meshMax.y, meshMax.z), type: 'Punto Medio', name: 'mid' });
                        }
                    });
                }
            }

            function findNearestSnapPoint(screenX, screenY) {
                if (!snapEnabled || snapPoints.length === 0) return null;

                const activeCam = currentView === '3d' ? camera : orthoCamera;
                let nearest = null;
                let minDist = snapOptions.tolerance;

                snapPoints.forEach(sp => {
                    const screenPos = sp.position.clone().project(activeCam);
                    const sx = (screenPos.x * 0.5 + 0.5) * container.clientWidth;
                    const sy = (-screenPos.y * 0.5 + 0.5) * container.clientHeight;

                    // Only consider points in front of camera
                    if (screenPos.z < 1) {
                        const dist = Math.sqrt((sx - screenX) ** 2 + (sy - screenY) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = { ...sp, screenX: sx, screenY: sy };
                        }
                    }
                });

                return nearest;
            }

            function showSnapIndicator(snapPoint) {
                if (snapPoint) {
                    snapIndicator.style.left = snapPoint.screenX + 'px';
                    snapIndicator.style.top = snapPoint.screenY + 'px';
                    snapLabel.textContent = snapPoint.type;
                    snapIndicator.classList.add('visible');
                    currentSnapPoint = snapPoint;
                } else {
                    snapIndicator.classList.remove('visible');
                    currentSnapPoint = null;
                }
            }

            // ========== GRID FUNCTIONS ==========
            function createGrids() {
                // Clear existing
                while (gridGroup.children.length > 0) {
                    gridGroup.remove(gridGroup.children[0]);
                }
                gridLabels.innerHTML = '';
                gridData = { xAxes: [], yAxes: [], nodes: [] };

                const xCount = parseInt(document.getElementById('grid-x-count').value);
                const yCount = parseInt(document.getElementById('grid-y-count').value);
                const xSpace = parseFloat(document.getElementById('grid-x-space').value);
                const ySpace = parseFloat(document.getElementById('grid-y-space').value);
                const xNames = document.getElementById('grid-x-names').value.split(',');
                const yNames = document.getElementById('grid-y-names').value.split(',');

                const totalX = (xCount - 1) * xSpace;
                const totalY = (yCount - 1) * ySpace;
                const gridHeight = maxDim * 1.2;

                gridData.minX = -totalX / 2 - 3;
                gridData.maxX = totalX / 2 + 3;
                gridData.minZ = -totalY / 2 - 3;
                gridData.maxZ = totalY / 2 + 3;

                const matX = new THREE.LineBasicMaterial({ color: 0x3498db });
                const matY = new THREE.LineBasicMaterial({ color: 0xe74c3c });

                // Create X axes
                for (let i = 0; i < xCount; i++) {
                    const x = i * xSpace - totalX / 2;
                    const name = xNames[i] || String.fromCharCode(65 + i);

                    // Horizontal line
                    const pts = [
                        new THREE.Vector3(x, 0, gridData.minZ),
                        new THREE.Vector3(x, 0, gridData.maxZ)
                    ];
                    const lineGeom = new THREE.BufferGeometry().setFromPoints(pts);
                    gridGroup.add(new THREE.Line(lineGeom, matX));

                    // Vertical line
                    const vPts = [
                        new THREE.Vector3(x, 0, gridData.minZ),
                        new THREE.Vector3(x, gridHeight, gridData.minZ)
                    ];
                    const vGeom = new THREE.BufferGeometry().setFromPoints(vPts);
                    gridGroup.add(new THREE.Line(vGeom, matX));

                    // Bubble
                    const bubble = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 16, 16),
                        new THREE.MeshBasicMaterial({ color: 0x3498db })
                    );
                    bubble.position.set(x, 0, gridData.minZ - 1.5);
                    bubble.userData = { type: 'bubbleX', name };
                    gridGroup.add(bubble);

                    gridData.xAxes.push({ name, x });
                }

                // Create Y axes
                for (let i = 0; i < yCount; i++) {
                    const z = i * ySpace - totalY / 2;
                    const name = yNames[i] || (i + 1).toString();

                    // Horizontal line
                    const pts = [
                        new THREE.Vector3(gridData.minX, 0, z),
                        new THREE.Vector3(gridData.maxX, 0, z)
                    ];
                    const lineGeom = new THREE.BufferGeometry().setFromPoints(pts);
                    gridGroup.add(new THREE.Line(lineGeom, matY));

                    // Vertical line
                    const vPts = [
                        new THREE.Vector3(gridData.minX, 0, z),
                        new THREE.Vector3(gridData.minX, gridHeight, z)
                    ];
                    const vGeom = new THREE.BufferGeometry().setFromPoints(vPts);
                    gridGroup.add(new THREE.Line(vGeom, matY));

                    // Bubble
                    const bubble = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 16, 16),
                        new THREE.MeshBasicMaterial({ color: 0xe74c3c })
                    );
                    bubble.position.set(gridData.minX - 1.5, 0, z);
                    bubble.userData = { type: 'bubbleY', name };
                    gridGroup.add(bubble);

                    gridData.yAxes.push({ name, z });
                }

                // Create intersection nodes
                gridData.xAxes.forEach(xAxis => {
                    gridData.yAxes.forEach(yAxis => {
                        gridData.nodes.push({
                            name: xAxis.name + yAxis.name,
                            position: new THREE.Vector3(xAxis.x, 0, yAxis.z)
                        });
                    });
                });

                autoAlign();
                updateSnapPoints();
            }

            function clearGrids() {
                while (gridGroup.children.length > 0) {
                    gridGroup.remove(gridGroup.children[0]);
                }
                gridLabels.innerHTML = '';
                gridData = { xAxes: [], yAxes: [], nodes: [] };
                updateSnapPoints();
            }

            function autoAlign() {
                document.getElementById('align-x').value = center.x;
                document.getElementById('align-y').value = bbox.min.y;
                document.getElementById('align-z').value = center.z;
                document.getElementById('align-rot').value = 0;
                updateGridPosition();
            }

            function resetAlign() {
                document.getElementById('align-x').value = 0;
                document.getElementById('align-y').value = 0;
                document.getElementById('align-z').value = 0;
                document.getElementById('align-rot').value = 0;
                updateGridPosition();
            }

            function updateGridPosition() {
                const x = parseFloat(document.getElementById('align-x').value);
                const y = parseFloat(document.getElementById('align-y').value);
                const z = parseFloat(document.getElementById('align-z').value);
                const rot = parseFloat(document.getElementById('align-rot').value);

                gridGroup.position.set(x, y, z);
                gridGroup.rotation.y = rot * Math.PI / 180;

                document.getElementById('align-x-val').textContent = x.toFixed(1);
                document.getElementById('align-y-val').textContent = y.toFixed(1);
                document.getElementById('align-z-val').textContent = z.toFixed(1);
                document.getElementById('align-rot-val').textContent = rot + '°';

                updateSnapPoints();
            }

            // ========== VIEW FUNCTIONS ==========
            function setView(view) {
                currentView = view;
                document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));

                const dist = maxDim * 2;

                switch(view) {
                    case '3d':
                        document.getElementById('btn-3d').classList.add('active');
                        controls.object = camera;
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.enableRotate = true;
                        break;
                    case 'top':
                        document.getElementById('btn-top').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y + dist, center.z);
                        orthoCamera.up.set(0, 0, -1);
                        controls.enableRotate = false;
                        break;
                    case 'front':
                        document.getElementById('btn-front').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y, center.z + dist);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                    case 'right':
                        document.getElementById('btn-right').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x + dist, center.y, center.z);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                }
                controls.target.copy(center);
                controls.update();

                // Keep snap button state
                if (snapEnabled) document.getElementById('btn-snap').classList.add('snap-active');
            }

            function updateOrtho(size) {
                const aspect = container.clientWidth / container.clientHeight;
                orthoCamera.left = -size * aspect;
                orthoCamera.right = size * aspect;
                orthoCamera.top = size;
                orthoCamera.bottom = -size;
                orthoCamera.updateProjectionMatrix();
            }

            function fitView() {
                if (currentView === '3d') {
                    camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                }
                controls.target.copy(center);
                controls.update();
            }

            // ========== UPDATE GRID LABELS ==========
            function updateGridLabels() {
                gridLabels.innerHTML = '';
                if (gridGroup.children.length === 0) return;

                const activeCam = currentView === '3d' ? camera : orthoCamera;

                gridGroup.children.forEach(obj => {
                    if (obj.userData && (obj.userData.type === 'bubbleX' || obj.userData.type === 'bubbleY')) {
                        const worldPos = new THREE.Vector3();
                        obj.getWorldPosition(worldPos);

                        const screenPos = worldPos.clone().project(activeCam);
                        const sx = (screenPos.x * 0.5 + 0.5) * container.clientWidth;
                        const sy = (-screenPos.y * 0.5 + 0.5) * container.clientHeight;

                        if (screenPos.z < 1 && sx > 0 && sx < container.clientWidth && sy > 0 && sy < container.clientHeight) {
                            const label = document.createElement('div');
                            label.className = 'grid-label';
                            label.textContent = obj.userData.name;
                            label.style.left = (sx - 10) + 'px';
                            label.style.top = (sy - 10) + 'px';
                            label.style.background = obj.userData.type === 'bubbleX' ? '#3498db' : '#e74c3c';
                            label.style.color = '#fff';
                            gridLabels.appendChild(label);
                        }
                    }
                });
            }

            // ========== MOUSE TRACKING ==========
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                mouse.x = (x / rect.width) * 2 - 1;
                mouse.y = -(y / rect.height) * 2 + 1;

                const activeCam = currentView === '3d' ? camera : orthoCamera;
                raycaster.setFromCamera(mouse, activeCam);

                // Get 3D point on horizontal plane
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);

                if (intersectPoint) {
                    document.getElementById('coord-x').textContent = intersectPoint.x.toFixed(2);
                    document.getElementById('coord-y').textContent = intersectPoint.y.toFixed(2);
                    document.getElementById('coord-z').textContent = intersectPoint.z.toFixed(2);
                }

                // Find snap point
                const snapPt = findNearestSnapPoint(x, y);
                showSnapIndicator(snapPt);
            });

            // ========== EVENT LISTENERS ==========
            document.getElementById('btn-3d').onclick = () => setView('3d');
            document.getElementById('btn-top').onclick = () => setView('top');
            document.getElementById('btn-front').onclick = () => setView('front');
            document.getElementById('btn-right').onclick = () => setView('right');
            document.getElementById('btn-fit').onclick = fitView;

            document.getElementById('btn-grids').onclick = function() {
                this.classList.toggle('active');
                document.getElementById('grid-panel').classList.toggle('visible');
            };

            document.getElementById('btn-align').onclick = function() {
                this.classList.toggle('active');
                document.getElementById('align-panel').classList.toggle('visible');
            };

            document.getElementById('btn-snap').onclick = function() {
                snapEnabled = !snapEnabled;
                this.classList.toggle('snap-active', snapEnabled);
                if (!snapEnabled) showSnapIndicator(null);
            };

            document.getElementById('btn-snap-opts').onclick = function() {
                this.classList.toggle('active');
                document.getElementById('snap-panel').classList.toggle('visible');
            };

            document.getElementById('btn-create-grid').onclick = createGrids;
            document.getElementById('btn-clear-grid').onclick = clearGrids;
            document.getElementById('btn-auto-align').onclick = autoAlign;
            document.getElementById('btn-reset-align').onclick = resetAlign;

            // Align sliders
            ['align-x', 'align-y', 'align-z', 'align-rot'].forEach(id => {
                document.getElementById(id).oninput = updateGridPosition;
            });

            // Snap options
            ['endpoint', 'midpoint', 'center', 'quadrant', 'intersection', 'gridline', 'gridnode'].forEach(opt => {
                const el = document.getElementById('snap-' + opt);
                if (el) {
                    el.onchange = () => {
                        snapOptions[opt] = el.checked;
                        updateSnapPoints();
                    };
                }
            });

            document.getElementById('snap-tolerance').onchange = (e) => {
                snapOptions.tolerance = parseInt(e.target.value);
            };

            // Keyboard
            document.addEventListener('keydown', e => {
                switch(e.key.toLowerCase()) {
                    case '1': setView('3d'); break;
                    case '2': setView('top'); break;
                    case '3': setView('front'); break;
                    case '4': setView('right'); break;
                    case 'f': fitView(); break;
                    case 'g':
                        document.getElementById('btn-grids').click();
                        break;
                    case 'a':
                        document.getElementById('btn-align').click();
                        break;
                    case 's':
                        document.getElementById('btn-snap').click();
                        break;
                }
            });

            // Resize
            window.addEventListener('resize', () => {
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                updateOrtho(maxDim * 2);
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // ========== ANIMATION ==========
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                const activeCam = currentView === '3d' ? camera : orthoCamera;
                renderer.render(scene, activeCam);
                updateGridLabels();
            }
            animate();

            // Initial snap points
            updateSnapPoints();

        } catch (err) {
            console.error(err);
            status.textContent = 'Error: ' + err.message;
            status.style.color = '#ff6b6b';
        }
    })();
    </script>
</body>
</html>
@{end html-ifc}
