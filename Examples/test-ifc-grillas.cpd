"Test IFC con Sistema de Grillas Alineables
@{html-ifc}
<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>IFC Viewer con Grillas</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #fff;
            user-select: none;
        }
        #container { width: 100%; height: 100%; position: relative; }
        canvas { width: 100%; height: 100%; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.9);
            padding: 6px 10px;
            border-radius: 8px;
            z-index: 100;
        }
        .toolbar button {
            background: #2d2d44;
            color: #fff;
            border: 1px solid #444;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .toolbar button:hover { background: #3d3d5c; border-color: #0078d4; }
        .toolbar button.active { background: #0078d4; border-color: #0078d4; }
        .toolbar-sep { width: 1px; background: #444; margin: 0 4px; }

        /* Panels */
        .panel {
            position: absolute;
            background: rgba(0,0,0,0.92);
            padding: 12px;
            border-radius: 8px;
            font-size: 11px;
            z-index: 100;
            border: 1px solid #333;
        }
        .panel h4 { color: #0078d4; margin-bottom: 10px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 6px; }
        .panel label { display: block; color: #888; margin-bottom: 3px; margin-top: 8px; }
        .panel input[type="number"], .panel input[type="text"] {
            width: 100%;
            padding: 5px 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-size: 11px;
        }
        .panel input:focus { border-color: #0078d4; outline: none; }
        .panel button {
            width: 100%;
            padding: 7px;
            margin-top: 10px;
            background: #0078d4;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .panel button:hover { background: #0066b8; }
        .panel button.secondary { background: #444; }
        .panel button.secondary:hover { background: #555; }

        /* Grid Panel */
        .grid-panel {
            top: 60px;
            left: 10px;
            width: 220px;
            display: none;
        }
        .grid-panel.visible { display: block; }
        .grid-row { display: flex; gap: 8px; }
        .grid-row > div { flex: 1; }
        .axis-list {
            max-height: 120px;
            overflow-y: auto;
            background: #111;
            border-radius: 4px;
            padding: 5px;
            margin-top: 5px;
        }
        .axis-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 5px;
            background: #222;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 10px;
        }
        .axis-item .name { color: #0078d4; font-weight: bold; }

        /* Align Panel */
        .align-panel {
            top: 60px;
            right: 10px;
            width: 200px;
            display: none;
        }
        .align-panel.visible { display: block; }
        .align-panel .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        .align-panel .slider-row label { margin: 0; min-width: 50px; }
        .align-panel input[type="range"] { flex: 1; }
        .align-panel .value { min-width: 45px; text-align: right; color: #fff; }

        /* Info */
        .info-panel {
            bottom: 10px;
            left: 10px;
        }
        .info-panel strong { color: #0078d4; }

        /* Loading */
        .loading {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26,26,46,0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; }
        .progress { width: 200px; height: 5px; background: #333; border-radius: 3px; margin-top: 15px; }
        .progress-fill { height: 100%; background: #0078d4; width: 0%; transition: width 0.3s; }

        /* Grid labels in 3D */
        .grid-label {
            position: absolute;
            background: #e74c3c;
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            pointer-events: none;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <!-- Toolbar -->
        <div class="toolbar">
            <button id="btn-3d" class="active">3D</button>
            <button id="btn-top">Planta</button>
            <button id="btn-front">Frontal</button>
            <button id="btn-right">Lateral</button>
            <div class="toolbar-sep"></div>
            <button id="btn-grids">Grillas</button>
            <button id="btn-align">Alinear</button>
            <div class="toolbar-sep"></div>
            <button id="btn-fit">Fit (F)</button>
        </div>

        <!-- Grid Creation Panel -->
        <div id="grid-panel" class="panel grid-panel">
            <h4>Sistema de Grillas</h4>

            <div class="grid-row">
                <div>
                    <label>Ejes X (cantidad)</label>
                    <input type="number" id="grid-x-count" value="4" min="2" max="20">
                </div>
                <div>
                    <label>Espaciado X (m)</label>
                    <input type="number" id="grid-x-spacing" value="5" min="0.5" step="0.5">
                </div>
            </div>

            <div class="grid-row">
                <div>
                    <label>Ejes Y (cantidad)</label>
                    <input type="number" id="grid-y-count" value="3" min="2" max="20">
                </div>
                <div>
                    <label>Espaciado Y (m)</label>
                    <input type="number" id="grid-y-spacing" value="4" min="0.5" step="0.5">
                </div>
            </div>

            <label>Prefijo ejes X</label>
            <input type="text" id="grid-x-prefix" value="A,B,C,D,E,F,G,H,I,J" placeholder="A,B,C... o 1,2,3...">

            <label>Prefijo ejes Y</label>
            <input type="text" id="grid-y-prefix" value="1,2,3,4,5,6,7,8,9,10" placeholder="1,2,3... o A,B,C...">

            <button id="btn-create-grids">Crear Grillas</button>
            <button id="btn-clear-grids" class="secondary">Limpiar Grillas</button>

            <div id="axis-list-container" style="display:none;">
                <label>Ejes creados:</label>
                <div id="axis-list" class="axis-list"></div>
            </div>
        </div>

        <!-- Align Panel -->
        <div id="align-panel" class="panel align-panel">
            <h4>Alinear Grillas al Modelo</h4>

            <div class="slider-row">
                <label>Mover X:</label>
                <input type="range" id="align-x" min="-50" max="50" value="0" step="0.1">
                <span class="value" id="align-x-val">0.0</span>
            </div>

            <div class="slider-row">
                <label>Mover Y:</label>
                <input type="range" id="align-y" min="-50" max="50" value="0" step="0.1">
                <span class="value" id="align-y-val">0.0</span>
            </div>

            <div class="slider-row">
                <label>Mover Z:</label>
                <input type="range" id="align-z" min="-50" max="50" value="0" step="0.1">
                <span class="value" id="align-z-val">0.0</span>
            </div>

            <div class="slider-row">
                <label>Rotar:</label>
                <input type="range" id="align-rot" min="-180" max="180" value="0" step="1">
                <span class="value" id="align-rot-val">0°</span>
            </div>

            <button id="btn-auto-align">Auto-Alinear al BBox</button>
            <button id="btn-reset-align" class="secondary">Resetear</button>
        </div>

        <!-- Info -->
        <div class="panel info-panel">
            <strong>IFC Viewer + Grillas</strong>
            <div id="stats"></div>
            <div style="color:#666;margin-top:8px;font-size:10px;">
                Click+Arrastrar: Rotar | Scroll: Zoom<br>
                F: Fit | G: Toggle Grillas
            </div>
        </div>

        <!-- Loading -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <p style="margin-top:15px;color:#888" id="status">Cargando...</p>
        </div>

        <!-- Grid labels container -->
        <div id="grid-labels"></div>
    </div>

    <script src="https://calcpad.ifc/three.min.js"></script>
    <script src="https://calcpad.ifc/OrbitControls.js"></script>
    <script src="https://calcpad.ifc/web-ifc-api-iife.js"></script>
    <script>
    (async function() {
        const canvas = document.getElementById('canvas');
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const statsEl = document.getElementById('stats');
        const gridPanel = document.getElementById('grid-panel');
        const alignPanel = document.getElementById('align-panel');
        const gridLabelsContainer = document.getElementById('grid-labels');

        let scene, camera, orthoCamera, renderer, controls;
        let allMeshes, gridGroup, bbox, center, maxDim;
        let currentView = '3d';
        let gridsVisible = true;
        let gridData = { xAxes: [], yAxes: [], offset: {x:0, y:0, z:0}, rotation: 0 };

        function updateProgress(msg, pct) {
            status.textContent = msg;
            progress.style.width = pct + '%';
        }

        try {
            updateProgress('Inicializando...', 10);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Cameras
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            camera.position.set(50, 50, 50);

            const aspect = container.clientWidth / container.clientHeight;
            orthoCamera = new THREE.OrthographicCamera(-50*aspect, 50*aspect, 50, -50, 0.1, 10000);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(50, 100, 50);
            scene.add(light1);

            // Grid helper (floor)
            scene.add(new THREE.GridHelper(200, 200, 0x333333, 0x222222));

            // Group for structural grids
            gridGroup = new THREE.Group();
            gridGroup.name = 'structuralGrids';
            scene.add(gridGroup);

            // Load IFC
            updateProgress('Descargando IFC...', 20);
            const response = await fetch('https://calcpad.ifc/temp_a7ce813c013e4fc48bd57558ccf7ebd6.ifc');
            if (!response.ok) throw new Error('Error: ' + response.status);

            updateProgress('Leyendo...', 40);
            const ifcData = await response.arrayBuffer();

            updateProgress('Inicializando web-ifc...', 50);
            const ifcApi = new WebIFC.IfcAPI();
            await ifcApi.Init(p => p.endsWith('.wasm') ? 'https://calcpad.ifc/' + p : p);

            updateProgress('Parseando IFC...', 60);
            const modelID = ifcApi.OpenModel(new Uint8Array(ifcData));

            updateProgress('Generando geometría...', 70);
            const flatMeshes = ifcApi.LoadAllGeometry(modelID);

            updateProgress('Construyendo...', 80);
            allMeshes = new THREE.Group();
            let meshCount = 0;

            for (let i = 0; i < flatMeshes.size(); i++) {
                const flatMesh = flatMeshes.get(i);
                const geometries = flatMesh.geometries;

                for (let j = 0; j < geometries.size(); j++) {
                    const pg = geometries.get(j);
                    const geom = ifcApi.GetGeometry(modelID, pg.geometryExpressID);
                    const verts = ifcApi.GetVertexArray(geom.GetVertexData(), geom.GetVertexDataSize());
                    const indices = ifcApi.GetIndexArray(geom.GetIndexData(), geom.GetIndexDataSize());

                    if (verts.length === 0 || indices.length === 0) continue;

                    const positions = new Float32Array(verts.length / 2);
                    const normals = new Float32Array(verts.length / 2);
                    for (let k = 0; k < verts.length; k += 6) {
                        const idx = (k / 6) * 3;
                        positions[idx] = verts[k];
                        positions[idx + 1] = verts[k + 1];
                        positions[idx + 2] = verts[k + 2];
                        normals[idx] = verts[k + 3];
                        normals[idx + 1] = verts[k + 4];
                        normals[idx + 2] = verts[k + 5];
                    }

                    const bufferGeom = new THREE.BufferGeometry();
                    bufferGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    bufferGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                    bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));

                    const color = new THREE.Color(pg.color.x, pg.color.y, pg.color.z);
                    const material = new THREE.MeshPhongMaterial({
                        color, side: THREE.DoubleSide,
                        transparent: pg.color.w < 1, opacity: pg.color.w
                    });

                    const mesh = new THREE.Mesh(bufferGeom, material);
                    mesh.applyMatrix4(new THREE.Matrix4().fromArray(pg.flatTransformation));
                    allMeshes.add(mesh);
                    meshCount++;
                }
            }

            scene.add(allMeshes);
            ifcApi.CloseModel(modelID);

            // Adjust view
            updateProgress('Ajustando...', 90);
            bbox = new THREE.Box3().setFromObject(allMeshes);
            center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            maxDim = Math.max(size.x, size.y, size.z);

            camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
            controls.target.copy(center);
            controls.update();

            // Update align sliders range based on model size
            document.getElementById('align-x').min = -maxDim;
            document.getElementById('align-x').max = maxDim;
            document.getElementById('align-y').min = -maxDim;
            document.getElementById('align-y').max = maxDim;
            document.getElementById('align-z').min = -maxDim;
            document.getElementById('align-z').max = maxDim;

            loading.style.display = 'none';
            statsEl.innerHTML = '<br>' + meshCount + ' elementos';

            // ========== GRID FUNCTIONS ==========
            function createGrids() {
                // Clear existing
                while (gridGroup.children.length > 0) {
                    gridGroup.remove(gridGroup.children[0]);
                }
                gridLabelsContainer.innerHTML = '';
                gridData.xAxes = [];
                gridData.yAxes = [];

                const xCount = parseInt(document.getElementById('grid-x-count').value);
                const yCount = parseInt(document.getElementById('grid-y-count').value);
                const xSpacing = parseFloat(document.getElementById('grid-x-spacing').value);
                const ySpacing = parseFloat(document.getElementById('grid-y-spacing').value);
                const xNames = document.getElementById('grid-x-prefix').value.split(',');
                const yNames = document.getElementById('grid-y-prefix').value.split(',');

                const totalX = (xCount - 1) * xSpacing;
                const totalY = (yCount - 1) * ySpacing;
                const gridHeight = maxDim * 1.5;

                // Material for grid lines
                const gridMaterial = new THREE.LineBasicMaterial({ color: 0x3498db, linewidth: 2 });
                const gridMaterialY = new THREE.LineBasicMaterial({ color: 0xe74c3c, linewidth: 2 });

                // Create X axes (vertical lines in plan view, running along Y)
                for (let i = 0; i < xCount; i++) {
                    const x = i * xSpacing - totalX / 2;
                    const name = xNames[i] || String.fromCharCode(65 + i);

                    // Line geometry
                    const points = [
                        new THREE.Vector3(x, 0, -totalY/2 - 5),
                        new THREE.Vector3(x, 0, totalY/2 + 5)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, gridMaterial);
                    line.userData = { type: 'gridX', name, index: i };
                    gridGroup.add(line);

                    // Vertical line for 3D view
                    const vPoints = [
                        new THREE.Vector3(x, 0, -totalY/2 - 5),
                        new THREE.Vector3(x, gridHeight, -totalY/2 - 5)
                    ];
                    const vGeom = new THREE.BufferGeometry().setFromPoints(vPoints);
                    const vLine = new THREE.Line(vGeom, gridMaterial);
                    gridGroup.add(vLine);

                    // Bubble (sphere at end)
                    const bubbleGeom = new THREE.SphereGeometry(1, 16, 16);
                    const bubbleMat = new THREE.MeshBasicMaterial({ color: 0x3498db });
                    const bubble = new THREE.Mesh(bubbleGeom, bubbleMat);
                    bubble.position.set(x, 0, -totalY/2 - 7);
                    bubble.userData = { type: 'bubbleX', name, index: i };
                    gridGroup.add(bubble);

                    gridData.xAxes.push({ name, position: x });
                }

                // Create Y axes (horizontal lines in plan view, running along X)
                for (let i = 0; i < yCount; i++) {
                    const z = i * ySpacing - totalY / 2;
                    const name = yNames[i] || (i + 1).toString();

                    // Line geometry
                    const points = [
                        new THREE.Vector3(-totalX/2 - 5, 0, z),
                        new THREE.Vector3(totalX/2 + 5, 0, z)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, gridMaterialY);
                    line.userData = { type: 'gridY', name, index: i };
                    gridGroup.add(line);

                    // Vertical line for 3D
                    const vPoints = [
                        new THREE.Vector3(-totalX/2 - 5, 0, z),
                        new THREE.Vector3(-totalX/2 - 5, gridHeight, z)
                    ];
                    const vGeom = new THREE.BufferGeometry().setFromPoints(vPoints);
                    const vLine = new THREE.Line(vGeom, gridMaterialY);
                    gridGroup.add(vLine);

                    // Bubble
                    const bubbleGeom = new THREE.SphereGeometry(1, 16, 16);
                    const bubbleMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
                    const bubble = new THREE.Mesh(bubbleGeom, bubbleMat);
                    bubble.position.set(-totalX/2 - 7, 0, z);
                    bubble.userData = { type: 'bubbleY', name, index: i };
                    gridGroup.add(bubble);

                    gridData.yAxes.push({ name, position: z });
                }

                // Show axis list
                updateAxisList();

                // Auto-align to center
                autoAlign();
            }

            function updateAxisList() {
                const listEl = document.getElementById('axis-list');
                const containerEl = document.getElementById('axis-list-container');

                if (gridData.xAxes.length === 0 && gridData.yAxes.length === 0) {
                    containerEl.style.display = 'none';
                    return;
                }

                containerEl.style.display = 'block';
                let html = '';

                gridData.xAxes.forEach(a => {
                    html += `<div class="axis-item"><span class="name" style="color:#3498db">${a.name}</span><span>X: ${a.position.toFixed(2)}m</span></div>`;
                });
                gridData.yAxes.forEach(a => {
                    html += `<div class="axis-item"><span class="name" style="color:#e74c3c">${a.name}</span><span>Z: ${a.position.toFixed(2)}m</span></div>`;
                });

                listEl.innerHTML = html;
            }

            function clearGrids() {
                while (gridGroup.children.length > 0) {
                    gridGroup.remove(gridGroup.children[0]);
                }
                gridLabelsContainer.innerHTML = '';
                gridData.xAxes = [];
                gridData.yAxes = [];
                document.getElementById('axis-list-container').style.display = 'none';
            }

            function updateGridPosition() {
                const x = parseFloat(document.getElementById('align-x').value);
                const y = parseFloat(document.getElementById('align-y').value);
                const z = parseFloat(document.getElementById('align-z').value);
                const rot = parseFloat(document.getElementById('align-rot').value);

                gridGroup.position.set(x, y, z);
                gridGroup.rotation.y = rot * Math.PI / 180;

                document.getElementById('align-x-val').textContent = x.toFixed(1);
                document.getElementById('align-y-val').textContent = y.toFixed(1);
                document.getElementById('align-z-val').textContent = z.toFixed(1);
                document.getElementById('align-rot-val').textContent = rot + '°';

                gridData.offset = {x, y, z};
                gridData.rotation = rot;
            }

            function autoAlign() {
                // Align grid center to model center
                document.getElementById('align-x').value = center.x;
                document.getElementById('align-y').value = bbox.min.y;
                document.getElementById('align-z').value = center.z;
                document.getElementById('align-rot').value = 0;
                updateGridPosition();
            }

            function resetAlign() {
                document.getElementById('align-x').value = 0;
                document.getElementById('align-y').value = 0;
                document.getElementById('align-z').value = 0;
                document.getElementById('align-rot').value = 0;
                updateGridPosition();
            }

            // ========== VIEW FUNCTIONS ==========
            function setView(view) {
                currentView = view;
                document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));

                const dist = maxDim * 2;

                switch(view) {
                    case '3d':
                        document.getElementById('btn-3d').classList.add('active');
                        controls.object = camera;
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.enableRotate = true;
                        break;
                    case 'top':
                        document.getElementById('btn-top').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y + dist, center.z);
                        orthoCamera.up.set(0, 0, -1);
                        controls.enableRotate = false;
                        break;
                    case 'front':
                        document.getElementById('btn-front').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y, center.z + dist);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                    case 'right':
                        document.getElementById('btn-right').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x + dist, center.y, center.z);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                }
                controls.target.copy(center);
                controls.update();
            }

            function updateOrtho(size) {
                const aspect = container.clientWidth / container.clientHeight;
                orthoCamera.left = -size * aspect;
                orthoCamera.right = size * aspect;
                orthoCamera.top = size;
                orthoCamera.bottom = -size;
                orthoCamera.updateProjectionMatrix();
            }

            function fitView() {
                if (currentView === '3d') {
                    camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                }
                controls.target.copy(center);
                controls.update();
            }

            // ========== UPDATE GRID LABELS (2D overlay) ==========
            function updateGridLabels() {
                gridLabelsContainer.innerHTML = '';
                if (!gridsVisible || gridGroup.children.length === 0) return;

                const activeCamera = currentView === '3d' ? camera : orthoCamera;

                gridGroup.children.forEach(obj => {
                    if (obj.userData && (obj.userData.type === 'bubbleX' || obj.userData.type === 'bubbleY')) {
                        const worldPos = new THREE.Vector3();
                        obj.getWorldPosition(worldPos);

                        // Project to screen
                        const screenPos = worldPos.clone().project(activeCamera);
                        const x = (screenPos.x * 0.5 + 0.5) * container.clientWidth;
                        const y = (-screenPos.y * 0.5 + 0.5) * container.clientHeight;

                        // Check if in front of camera
                        if (screenPos.z < 1) {
                            const label = document.createElement('div');
                            label.className = 'grid-label';
                            label.textContent = obj.userData.name;
                            label.style.left = (x - 12) + 'px';
                            label.style.top = (y - 12) + 'px';
                            label.style.background = obj.userData.type === 'bubbleX' ? '#3498db' : '#e74c3c';
                            gridLabelsContainer.appendChild(label);
                        }
                    }
                });
            }

            // ========== EVENTS ==========
            document.getElementById('btn-3d').onclick = () => setView('3d');
            document.getElementById('btn-top').onclick = () => setView('top');
            document.getElementById('btn-front').onclick = () => setView('front');
            document.getElementById('btn-right').onclick = () => setView('right');
            document.getElementById('btn-fit').onclick = fitView;

            document.getElementById('btn-grids').onclick = function() {
                this.classList.toggle('active');
                gridPanel.classList.toggle('visible');
            };

            document.getElementById('btn-align').onclick = function() {
                this.classList.toggle('active');
                alignPanel.classList.toggle('visible');
            };

            document.getElementById('btn-create-grids').onclick = createGrids;
            document.getElementById('btn-clear-grids').onclick = clearGrids;
            document.getElementById('btn-auto-align').onclick = autoAlign;
            document.getElementById('btn-reset-align').onclick = resetAlign;

            document.getElementById('align-x').oninput = updateGridPosition;
            document.getElementById('align-y').oninput = updateGridPosition;
            document.getElementById('align-z').oninput = updateGridPosition;
            document.getElementById('align-rot').oninput = updateGridPosition;

            document.addEventListener('keydown', e => {
                switch(e.key.toLowerCase()) {
                    case 'f': fitView(); break;
                    case 'g':
                        gridsVisible = !gridsVisible;
                        gridGroup.visible = gridsVisible;
                        break;
                    case '1': setView('3d'); break;
                    case '2': setView('top'); break;
                    case '3': setView('front'); break;
                    case '4': setView('right'); break;
                }
            });

            window.addEventListener('resize', () => {
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                updateOrtho(maxDim * 2);
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // ========== ANIMATION ==========
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                const activeCam = currentView === '3d' ? camera : orthoCamera;
                renderer.render(scene, activeCam);
                updateGridLabels();
            }
            animate();

        } catch (err) {
            console.error(err);
            status.textContent = 'Error: ' + err.message;
            status.style.color = '#ff6b6b';
        }
    })();
    </script>
</body>
</html>
@{end html-ifc}
