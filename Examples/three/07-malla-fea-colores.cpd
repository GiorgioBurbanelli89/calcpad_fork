"============================================
"EJEMPLO 7: Malla FEA con Mapa de Colores
"============================================
"Visualización de desplazamientos usando
"escala de colores (azul → verde → rojo)

"LOSA SIMPLEMENTE APOYADA:
'Dimensiones:'
a = 6m
b = 4m
t = 0.25m

"MATERIAL:
'Módulo de elasticidad:'E = 25e9Pa
'Módulo de Poisson:'ν = 0.2

"CARGA:
'Carga uniformemente distribuida:'q = 5kN/m²

"MALLA:
n_x = 12
n_y = 8

#val
'Rigidez a flexión:'
D = E*t^3/(12*(1 - ν^2))

'Deflexión máxima teórica (centro):'
'Para losa simplemente apoyada:'
β = 0.00406'Factor para a/b ≈ 1.5
w_max = β*q*b^4/D|mm

@{html}
<script src="https://cdn.jsdelivr.net/npm/three@0.145/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145/examples/js/controls/OrbitControls.js"></script>
<div id="canvas7" style="width:1000px; height:700px; border:2px solid #ccc; margin:10px 0;"></div>

<!-- Escala de colores -->
<div style="background:#fff; padding:15px; margin:10px 0; border:2px solid #ccc;">
  <strong>Escala de Desplazamientos Verticales:</strong><br>
  <div style="display:flex; align-items:center; margin-top:10px;">
    <span style="font-weight:bold; margin-right:10px;">0 mm</span>
    <div style="width:400px; height:30px; background:linear-gradient(to right, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000);"></div>
    <span style="font-weight:bold; margin-left:10px;">@{calcpad:w_max} mm</span>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {
    document.getElementById('canvas7').innerHTML = '<p style="color:red;">Error</p>';
    return;
  }

  // Variables
  const a = @{calcpad:a};
  const b = @{calcpad:b};
  const t = @{calcpad:t};
  const E = @{calcpad:E};
  const nu = @{calcpad:ν};
  const q = @{calcpad:q} * 1000;  // Convertir a N/m²
  const nx = @{calcpad:n_x};
  const ny = @{calcpad:n_y};
  const D = @{calcpad:D};
  const wMax = @{calcpad:w_max} / 1000;  // Convertir a metros

  console.log('Deflexión máxima teórica:', wMax, 'm');

  // Escena
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf5f5f5);

  // Cámara
  const camera = new THREE.PerspectiveCamera(45, 1000/700, 0.1, 1000);
  camera.position.set(a*1.3, b*1.2, b*1.5);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(1000, 700);
  document.getElementById('canvas7').appendChild(renderer.domElement);

  // Controles
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(a/2, -wMax/2, b/2);
  controls.update();

  // ===================================================================
  // CALCULAR DESPLAZAMIENTOS EN CADA NODO
  // ===================================================================

  // Fórmula aproximada para losa simplemente apoyada
  // w(x,z) = w_max * sin(π*x/a) * sin(π*z/b)

  const nodes = [];
  const displacements = [];

  for (let j = 0; j <= ny; j++) {
    for (let i = 0; i <= nx; i++) {
      const x = i * a / nx;
      const z = j * b / ny;

      // Desplazamiento vertical (negativo = hacia abajo)
      const w = -wMax * Math.sin(Math.PI * x / a) * Math.sin(Math.PI * z / b);

      nodes.push(new THREE.Vector3(x, w, z));
      displacements.push(w);
    }
  }

  // Normalizar desplazamientos para escala de colores [0, 1]
  const maxDisp = Math.max(...displacements.map(Math.abs));
  const normalizedDisp = displacements.map(d => Math.abs(d) / maxDisp);

  console.log('Máximo desplazamiento calculado:', maxDisp, 'm');

  // ===================================================================
  // FUNCIÓN DE MAPA DE COLORES
  // ===================================================================

  // Azul (0) → Cian (0.25) → Verde (0.5) → Amarillo (0.75) → Rojo (1)
  function getColorFromValue(value) {
    const color = new THREE.Color();

    if (value < 0.25) {
      // Azul → Cian
      const t = value / 0.25;
      color.setRGB(0, t, 1);
    } else if (value < 0.5) {
      // Cian → Verde
      const t = (value - 0.25) / 0.25;
      color.setRGB(0, 1, 1 - t);
    } else if (value < 0.75) {
      // Verde → Amarillo
      const t = (value - 0.5) / 0.25;
      color.setRGB(t, 1, 0);
    } else {
      // Amarillo → Rojo
      const t = (value - 0.75) / 0.25;
      color.setRGB(1, 1 - t, 0);
    }

    return color;
  }

  // ===================================================================
  // CREAR GEOMETRÍA CON COLORES
  // ===================================================================

  const positions = [];
  const colors = [];
  const normals = [];

  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const n1 = j * (nx + 1) + i;
      const n2 = j * (nx + 1) + (i + 1);
      const n3 = (j + 1) * (nx + 1) + (i + 1);
      const n4 = (j + 1) * (nx + 1) + i;

      const p1 = nodes[n1];
      const p2 = nodes[n2];
      const p3 = nodes[n3];
      const p4 = nodes[n4];

      // Colores de cada nodo
      const c1 = getColorFromValue(normalizedDisp[n1]);
      const c2 = getColorFromValue(normalizedDisp[n2]);
      const c3 = getColorFromValue(normalizedDisp[n3]);
      const c4 = getColorFromValue(normalizedDisp[n4]);

      // Triángulo 1: n1-n2-n3
      positions.push(p1.x, p1.y, p1.z);
      positions.push(p2.x, p2.y, p2.z);
      positions.push(p3.x, p3.y, p3.z);

      colors.push(c1.r, c1.g, c1.b);
      colors.push(c2.r, c2.g, c2.b);
      colors.push(c3.r, c3.g, c3.b);

      // Triángulo 2: n1-n3-n4
      positions.push(p1.x, p1.y, p1.z);
      positions.push(p3.x, p3.y, p3.z);
      positions.push(p4.x, p4.y, p4.z);

      colors.push(c1.r, c1.g, c1.b);
      colors.push(c3.r, c3.g, c3.b);
      colors.push(c4.r, c4.g, c4.b);
    }
  }

  // Crear geometría
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  // Material
  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    metalness: 0.3,
    roughness: 0.7
  });

  const slab = new THREE.Mesh(geometry, material);
  scene.add(slab);

  // Wireframe
  const wireframeGeom = new THREE.EdgesGeometry(geometry);
  const wireframeMat = new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 1,
    opacity: 0.3,
    transparent: true
  });
  const wireframe = new THREE.LineSegments(wireframeGeom, wireframeMat);
  scene.add(wireframe);

  // ===================================================================
  // LOSA SIN DEFORMAR (REFERENCIA)
  // ===================================================================

  const refPositions = [];
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const x1 = i * a / nx;
      const x2 = (i + 1) * a / nx;
      const z1 = j * b / ny;
      const z2 = (j + 1) * b / ny;

      // Triángulo 1
      refPositions.push(x1, 0, z1);
      refPositions.push(x2, 0, z1);
      refPositions.push(x2, 0, z2);

      // Triángulo 2
      refPositions.push(x1, 0, z1);
      refPositions.push(x2, 0, z2);
      refPositions.push(x1, 0, z2);
    }
  }

  const refGeom = new THREE.BufferGeometry();
  refGeom.setAttribute('position', new THREE.Float32BufferAttribute(refPositions, 3));

  const refWireframe = new THREE.LineSegments(
    new THREE.EdgesGeometry(refGeom),
    new THREE.LineBasicMaterial({
      color: 0x9e9e9e,
      linewidth: 1,
      opacity: 0.2,
      transparent: true
    })
  );
  scene.add(refWireframe);

  // ===================================================================
  // APOYOS SIMPLES (ESFERAS EN LAS ESQUINAS)
  // ===================================================================

  const supportGeom = new THREE.SphereGeometry(0.15, 16, 16);
  const supportMat = new THREE.MeshStandardMaterial({ color: 0x37474f });

  const supports = [
    [0, 0],
    [a, 0],
    [a, b],
    [0, b]
  ];

  supports.forEach(([x, z]) => {
    const support = new THREE.Mesh(supportGeom, supportMat);
    support.position.set(x, -0.15, z);
    scene.add(support);
  });

  // ===================================================================
  // ILUMINACIÓN
  // ===================================================================

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight1.position.set(a, b*2, b);
  scene.add(dirLight1);

  const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
  dirLight2.position.set(-a, b, -b);
  scene.add(dirLight2);

  // Grid
  const gridSize = Math.max(a, b) * 1.5;
  const gridHelper = new THREE.GridHelper(gridSize, 30);
  gridHelper.position.y = -wMax - 0.1;
  scene.add(gridHelper);

  // Ejes
  const axesHelper = new THREE.AxesHelper(Math.max(a, b) * 0.4);
  scene.add(axesHelper);

  // ===================================================================
  // ANIMACIÓN
  // ===================================================================

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  animate();
});
</script>
@{end html}

"EXPLICACIÓN DEL MAPA DE COLORES:
"
"1. CÁLCULO DE DESPLAZAMIENTOS:
"   w(x,z) = w_max × sin(πx/a) × sin(πz/b)
"   Esta fórmula da la deflexión en cualquier punto
"
"2. NORMALIZACIÓN:
"   Convertir desplazamientos al rango [0, 1]
"   para mapear a colores
"
"3. ESCALA DE COLORES (rainbow):
"   0.00 → Azul   (mínimo desplazamiento)
"   0.25 → Cian
"   0.50 → Verde
"   0.75 → Amarillo
"   1.00 → Rojo   (máximo desplazamiento)
"
"4. INTERPOLACIÓN:
"   Three.js interpola automáticamente los colores
"   entre vértices, creando gradientes suaves
"
"La malla gris transparente muestra la
"configuración sin deformar para referencia
