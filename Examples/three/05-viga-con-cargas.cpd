"============================================
"EJEMPLO 5: Viga con Cargas Visualizadas
"============================================
"Viga con cargas puntuales y distribuidas
"representadas como vectores 3D

"GEOMETRA:
'Longitud:'L = 8m
'Ancho:'b = 0.30m
'Altura:'h = 0.60m

"CARGAS:
'Carga puntual en centro:'P = 50kN
'Carga distribuida:'q = 10kN/m
'Momento en extremo:'M = 30kN路m

"REACCIONES (viga simplemente apoyada):
'Reacci贸n izquierda:'
R_A = q*L/2 + P/2 - M/L
'Reacci贸n derecha:'
R_B = q*L/2 + P/2 + M/L

#val
'Momento m谩ximo (centro):'
M_max = R_A*L/2 - q*(L/2)^2/2
'Cortante m谩ximo:'
V_max = max(abs(R_A); abs(R_B))

@{html}
<script src="https://cdn.jsdelivr.net/npm/three@0.145/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145/examples/js/controls/OrbitControls.js"></script>
<div id="canvas5" style="width:900px; height:600px; border:2px solid #ccc; margin:10px 0;"></div>
<div style="background:#e3f2fd; padding:15px; margin:10px 0; border-left:4px solid #2196f3;">
  <strong>Leyenda de colores:</strong><br>
   Rojo: Cargas puntuales (P)<br>
   Azul: Cargas distribuidas (q)<br>
   Verde: Reacciones (R)<br>
   Morado: Momentos (M)
</div>
<script>
window.addEventListener('DOMContentLoaded', () => {
  if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {
    document.getElementById('canvas5').innerHTML = '<p style="color:red;">Error</p>';
    return;
  }

  // Variables
  const L = @{calcpad:L};
  const b = @{calcpad:b};
  const h = @{calcpad:h};
  const P = @{calcpad:P};
  const q = @{calcpad:q};
  const M = @{calcpad:M};
  const R_A = @{calcpad:R_A};
  const R_B = @{calcpad:R_B};

  // Escala para visualizaci贸n de fuerzas
  const forceScale = L / 100;

  // Escena
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf5f5f5);

  // C谩mara
  const camera = new THREE.PerspectiveCamera(45, 900/600, 0.1, 1000);
  camera.position.set(L*0.9, h*3, L*0.8);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(900, 600);
  document.getElementById('canvas5').appendChild(renderer.domElement);

  // Controles
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(L/2, 0, 0);
  controls.update();

  // VIGA
  const beamGeom = new THREE.BoxGeometry(L, h, b);
  const beamMat = new THREE.MeshStandardMaterial({
    color: 0x90a4ae,
    metalness: 0.2,
    roughness: 0.7,
    transparent: true,
    opacity: 0.9
  });
  const beam = new THREE.Mesh(beamGeom, beamMat);
  beam.position.set(L/2, h/2, 0);
  beam.castShadow = true;
  scene.add(beam);

  // Wireframe
  const edges = new THREE.EdgesGeometry(beamGeom);
  const wireframe = new THREE.LineSegments(edges,
    new THREE.LineBasicMaterial({ color: 0x000000 }));
  beam.add(wireframe);

  // FUNCIN PARA CREAR FLECHAS (CARGAS)
  function createArrow(origin, direction, length, color) {
    const arrowHelper = new THREE.ArrowHelper(
      direction,
      origin,
      length,
      color,
      length * 0.2,  // Cabeza
      length * 0.15   // Ancho cabeza
    );
    return arrowHelper;
  }

  // 1. CARGA PUNTUAL EN CENTRO (P)
  const pointLoadPos = new THREE.Vector3(L/2, h*1.5, 0);
  const pointLoadDir = new THREE.Vector3(0, -1, 0);
  const pointLoadLength = P * forceScale;
  const pointLoad = createArrow(pointLoadPos, pointLoadDir, pointLoadLength, 0xff0000);
  scene.add(pointLoad);

  // Etiqueta para P
  const labelP = createTextLabel('P = ' + P.toFixed(0) + ' kN',
    new THREE.Vector3(L/2 + L*0.1, h*1.8, 0), 0xff0000);
  scene.add(labelP);

  // 2. CARGA DISTRIBUIDA (q) - m煤ltiples flechas
  const numArrows = 10;
  for (let i = 0; i < numArrows; i++) {
    const x = L * (i + 0.5) / numArrows;
    const distLoadPos = new THREE.Vector3(x, h*1.2, 0);
    const distLoadLength = q * L / numArrows * forceScale;
    const distLoad = createArrow(distLoadPos, pointLoadDir, distLoadLength, 0x2196f3);
    scene.add(distLoad);
  }

  // Etiqueta para q
  const labelQ = createTextLabel('q = ' + q.toFixed(1) + ' kN/m',
    new THREE.Vector3(L*0.75, h*1.5, 0), 0x2196f3);
  scene.add(labelQ);

  // 3. REACCIONES
  // Reacci贸n A (izquierda)
  const reactionAPos = new THREE.Vector3(0, -h*0.5, 0);
  const reactionADir = new THREE.Vector3(0, 1, 0);
  const reactionALength = Math.abs(R_A) * forceScale;
  const reactionA = createArrow(reactionAPos, reactionADir, reactionALength, 0x4caf50);
  scene.add(reactionA);

  const labelRA = createTextLabel('R_A = ' + R_A.toFixed(1) + ' kN',
    new THREE.Vector3(0, -h*1.2, 0), 0x4caf50);
  scene.add(labelRA);

  // Reacci贸n B (derecha)
  const reactionBPos = new THREE.Vector3(L, -h*0.5, 0);
  const reactionBLength = Math.abs(R_B) * forceScale;
  const reactionB = createArrow(reactionBPos, reactionADir, reactionBLength, 0x4caf50);
  scene.add(reactionB);

  const labelRB = createTextLabel('R_B = ' + R_B.toFixed(1) + ' kN',
    new THREE.Vector3(L, -h*1.2, 0), 0x4caf50);
  scene.add(labelRB);

  // 4. MOMENTO (M) - representado como arco curvo
  const momentRadius = h * 0.8;
  const momentCurve = new THREE.EllipseCurve(
    L, 0,              // Centro
    momentRadius, momentRadius,
    0, Math.PI * 1.5,  // ngulo inicio y fin
    false,             // No en sentido horario
    0                  // Rotaci贸n
  );
  const points = momentCurve.getPoints(50);
  const momentGeom = new THREE.BufferGeometry().setFromPoints(points);
  const momentMat = new THREE.LineBasicMaterial({ color: 0x9c27b0, linewidth: 3 });
  const momentLine = new THREE.Line(momentGeom, momentMat);
  momentLine.rotation.z = Math.PI / 2;
  momentLine.position.set(L, h/2, 0);
  scene.add(momentLine);

  // Flecha del momento
  const momentArrowPos = new THREE.Vector3(L + momentRadius*0.7, h/2 + momentRadius*0.7, 0);
  const momentArrowDir = new THREE.Vector3(1, 1, 0).normalize();
  const momentArrow = createArrow(momentArrowPos, momentArrowDir, h*0.4, 0x9c27b0);
  scene.add(momentArrow);

  const labelM = createTextLabel('M = ' + M.toFixed(0) + ' kN路m',
    new THREE.Vector3(L + h, h/2 + h, 0), 0x9c27b0);
  scene.add(labelM);

  // APOYOS
  const supportRadius = Math.min(b, h) * 0.35;
  const supportGeom = new THREE.CylinderGeometry(supportRadius, supportRadius, b*1.3, 16);
  const supportMat = new THREE.MeshStandardMaterial({ color: 0x37474f });

  const support1 = new THREE.Mesh(supportGeom, supportMat);
  support1.position.set(0, 0, 0);
  support1.rotation.z = Math.PI/2;
  scene.add(support1);

  const support2 = new THREE.Mesh(supportGeom, supportMat);
  support2.position.set(L, 0, 0);
  support2.rotation.z = Math.PI/2;
  scene.add(support2);

  // Funci贸n auxiliar para etiquetas
  function createTextLabel(text, position, color) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 128;
    context.fillStyle = '#ffffff';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.strokeStyle = '#' + color.toString(16).padStart(6, '0');
    context.lineWidth = 4;
    context.strokeRect(2, 2, canvas.width-4, canvas.height-4);
    context.font = 'Bold 32px Arial';
    context.fillStyle = '#' + color.toString(16).padStart(6, '0');
    context.textAlign = 'center';
    context.fillText(text, 256, 75);

    const texture = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.position.copy(position);
    sprite.scale.set(L*0.2, L*0.05, 1);
    return sprite;
  }

  // Plano y grid
  const planeGeom = new THREE.PlaneGeometry(L*1.5, b*5);
  const plane = new THREE.Mesh(planeGeom,
    new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
  plane.rotation.x = -Math.PI / 2;
  plane.position.y = -h*0.3;
  plane.receiveShadow = true;
  scene.add(plane);

  const gridHelper = new THREE.GridHelper(L*1.5, 20);
  gridHelper.position.y = -h*0.29;
  scene.add(gridHelper);

  // Iluminaci贸n
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(L, h*5, L);
  dirLight.castShadow = true;
  scene.add(dirLight);

  // Ejes
  const axesHelper = new THREE.AxesHelper(L*0.3);
  scene.add(axesHelper);

  // Animaci贸n
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  animate();
});
</script>
@{end html}

"Elementos visualizados:
"- Viga con wireframe
"- Cargas puntuales (flechas rojas)
"- Cargas distribuidas (m煤ltiples flechas azules)
"- Reacciones en apoyos (flechas verdes hacia arriba)
"- Momento aplicado (arco curvo morado)
"- Etiquetas con valores calculados
