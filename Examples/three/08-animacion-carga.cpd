"============================================
"EJEMPLO 8: Animaci√≥n de Aplicaci√≥n de Carga
"============================================
"La carga se aplica gradualmente y la estructura
"se deforma en tiempo real

"PAR√ÅMETROS:
a = 5m
b = 3m
t = 0.20m
E = 25e9Pa
ŒΩ = 0.2
'Carga m√°xima:'q_max = 8kN/m¬≤

n_x = 10
n_y = 6

#val
D = E*t^3/(12*(1 - ŒΩ^2))
Œ≤ = 0.00406
w_max = Œ≤*q_max*b^4/D|mm

@{html}
<script src="https://cdn.jsdelivr.net/npm/three@0.145/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.145/examples/js/controls/OrbitControls.js"></script>

<div style="background:#fff3e0; padding:15px; margin:10px 0; border-left:4px solid #ff9800;">
  <strong>‚èØÔ∏è Controles de Animaci√≥n:</strong><br>
  <button id="playBtn" style="padding:8px 16px; margin:5px; cursor:pointer; font-size:16px;">‚ñ∂Ô∏è Play</button>
  <button id="pauseBtn" style="padding:8px 16px; margin:5px; cursor:pointer; font-size:16px;">‚è∏Ô∏è Pause</button>
  <button id="resetBtn" style="padding:8px 16px; margin:5px; cursor:pointer; font-size:16px;">üîÑ Reset</button>
  <br>
  <label for="speedSlider">Velocidad: </label>
  <input type="range" id="speedSlider" min="0.5" max="5" step="0.5" value="1" style="width:200px;">
  <span id="speedValue">1.0x</span>
</div>

<div id="canvas8" style="width:1000px; height:700px; border:2px solid #ccc; margin:10px 0;"></div>

<div id="loadInfo" style="background:#e3f2fd; padding:15px; margin:10px 0; border-left:4px solid #2196f3;">
  <strong>Estado Actual:</strong><br>
  Carga aplicada: <span id="currentLoad">0.0</span> kN/m¬≤ (<span id="loadPercent">0</span>%)<br>
  Deflexi√≥n actual: <span id="currentDefl">0.00</span> mm
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {
    document.getElementById('canvas8').innerHTML = '<p style="color:red;">Error</p>';
    return;
  }

  // Variables
  const a = @{calcpad:a};
  const b = @{calcpad:b};
  const t = @{calcpad:t};
  const nx = @{calcpad:n_x};
  const ny = @{calcpad:n_y};
  const qMax = @{calcpad:q_max} * 1000;  // N/m¬≤
  const wMaxTheory = @{calcpad:w_max} / 1000;  // m

  // Estado de animaci√≥n
  let loadFactor = 0;  // 0 = sin carga, 1 = carga completa
  let isPlaying = true;
  let animationSpeed = 1.0;
  const loadRate = 0.01;  // Incremento por frame

  // Escena
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf8f9fa);

  // C√°mara
  const camera = new THREE.PerspectiveCamera(45, 1000/700, 0.1, 1000);
  camera.position.set(a*1.5, b*1.5, b*1.8);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(1000, 700);
  document.getElementById('canvas8').appendChild(renderer.domElement);

  // Controles
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(a/2, 0, b/2);
  controls.update();

  // ===================================================================
  // GENERAR NODOS Y TOPOLOG√çA
  // ===================================================================

  const elements = [];
  for (let j = 0; j < ny; j++) {
    for (let i = 0; i < nx; i++) {
      const n1 = j * (nx + 1) + i;
      const n2 = j * (nx + 1) + (i + 1);
      const n3 = (j + 1) * (nx + 1) + (i + 1);
      const n4 = (j + 1) * (nx + 1) + i;
      elements.push([n1, n2, n3, n4]);
    }
  }

  // ===================================================================
  // FUNCI√ìN PARA CALCULAR POSICIONES CON FACTOR DE CARGA
  // ===================================================================

  function calculateNodes(factor) {
    const nodes = [];
    const displacements = [];
    const wMax = wMaxTheory * factor;

    for (let j = 0; j <= ny; j++) {
      for (let i = 0; i <= nx; i++) {
        const x = i * a / nx;
        const z = j * b / ny;
        const w = -wMax * Math.sin(Math.PI * x / a) * Math.sin(Math.PI * z / b);

        nodes.push(new THREE.Vector3(x, w, z));
        displacements.push(w);
      }
    }

    return { nodes, displacements };
  }

  // Funci√≥n para obtener color
  function getColorFromValue(value) {
    const color = new THREE.Color();
    if (value < 0.25) {
      const t = value / 0.25;
      color.setRGB(0, t, 1);
    } else if (value < 0.5) {
      const t = (value - 0.25) / 0.25;
      color.setRGB(0, 1, 1 - t);
    } else if (value < 0.75) {
      const t = (value - 0.5) / 0.25;
      color.setRGB(t, 1, 0);
    } else {
      const t = (value - 0.75) / 0.25;
      color.setRGB(1, 1 - t, 0);
    }
    return color;
  }

  // ===================================================================
  // CREAR GEOMETR√çA DIN√ÅMICA
  // ===================================================================

  const geometry = new THREE.BufferGeometry();
  let positionsArray = new Float32Array(elements.length * 6 * 3);
  let colorsArray = new Float32Array(elements.length * 6 * 3);

  geometry.setAttribute('position', new THREE.BufferAttribute(positionsArray, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    metalness: 0.2,
    roughness: 0.7
  });

  const slab = new THREE.Mesh(geometry, material);
  scene.add(slab);

  // Wireframe
  const wireframeGeom = new THREE.WireframeGeometry(geometry);
  const wireframeMat = new THREE.LineBasicMaterial({
    color: 0x000000,
    opacity: 0.3,
    transparent: true
  });
  const wireframe = new THREE.LineSegments(wireframeGeom, wireframeMat);
  scene.add(wireframe);

  // ===================================================================
  // FUNCI√ìN PARA ACTUALIZAR GEOMETR√çA
  // ===================================================================

  function updateGeometry(factor) {
    const { nodes, displacements } = calculateNodes(factor);
    const maxDisp = Math.max(...displacements.map(Math.abs));
    const normalizedDisp = displacements.map(d => Math.abs(d) / (maxDisp || 1));

    let idx = 0;
    elements.forEach((elem) => {
      const [n1, n2, n3, n4] = elem;
      const p1 = nodes[n1];
      const p2 = nodes[n2];
      const p3 = nodes[n3];
      const p4 = nodes[n4];

      const c1 = getColorFromValue(normalizedDisp[n1]);
      const c2 = getColorFromValue(normalizedDisp[n2]);
      const c3 = getColorFromValue(normalizedDisp[n3]);
      const c4 = getColorFromValue(normalizedDisp[n4]);

      // Tri√°ngulo 1
      positionsArray[idx] = p1.x; positionsArray[idx+1] = p1.y; positionsArray[idx+2] = p1.z;
      colorsArray[idx] = c1.r; colorsArray[idx+1] = c1.g; colorsArray[idx+2] = c1.b;
      idx += 3;

      positionsArray[idx] = p2.x; positionsArray[idx+1] = p2.y; positionsArray[idx+2] = p2.z;
      colorsArray[idx] = c2.r; colorsArray[idx+1] = c2.g; colorsArray[idx+2] = c2.b;
      idx += 3;

      positionsArray[idx] = p3.x; positionsArray[idx+1] = p3.y; positionsArray[idx+2] = p3.z;
      colorsArray[idx] = c3.r; colorsArray[idx+1] = c3.g; colorsArray[idx+2] = c3.b;
      idx += 3;

      // Tri√°ngulo 2
      positionsArray[idx] = p1.x; positionsArray[idx+1] = p1.y; positionsArray[idx+2] = p1.z;
      colorsArray[idx] = c1.r; colorsArray[idx+1] = c1.g; colorsArray[idx+2] = c1.b;
      idx += 3;

      positionsArray[idx] = p3.x; positionsArray[idx+1] = p3.y; positionsArray[idx+2] = p3.z;
      colorsArray[idx] = c3.r; colorsArray[idx+1] = c3.g; colorsArray[idx+2] = c3.b;
      idx += 3;

      positionsArray[idx] = p4.x; positionsArray[idx+1] = p4.y; positionsArray[idx+2] = p4.z;
      colorsArray[idx] = c4.r; colorsArray[idx+1] = c4.g; colorsArray[idx+2] = c4.b;
      idx += 3;
    });

    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    geometry.computeVertexNormals();

    // Actualizar wireframe
    wireframe.geometry.dispose();
    wireframe.geometry = new THREE.WireframeGeometry(geometry);
  }

  // Inicializar con factor 0
  updateGeometry(0);

  // ===================================================================
  // APOYOS
  // ===================================================================

  const supportGeom = new THREE.SphereGeometry(0.12, 16, 16);
  const supportMat = new THREE.MeshStandardMaterial({ color: 0x263238 });

  [[0,0], [a,0], [a,b], [0,b]].forEach(([x,z]) => {
    const support = new THREE.Mesh(supportGeom, supportMat);
    support.position.set(x, -0.12, z);
    scene.add(support);
  });

  // ===================================================================
  // ILUMINACI√ìN
  // ===================================================================

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(a, b*2, b);
  scene.add(dirLight);

  const gridHelper = new THREE.GridHelper(Math.max(a,b)*1.5, 25);
  gridHelper.position.y = -wMaxTheory - 0.2;
  scene.add(gridHelper);

  const axesHelper = new THREE.AxesHelper(Math.max(a,b)*0.4);
  scene.add(axesHelper);

  // ===================================================================
  // CONTROLES DE ANIMACI√ìN
  // ===================================================================

  document.getElementById('playBtn').addEventListener('click', () => {
    isPlaying = true;
  });

  document.getElementById('pauseBtn').addEventListener('click', () => {
    isPlaying = false;
  });

  document.getElementById('resetBtn').addEventListener('click', () => {
    loadFactor = 0;
    updateGeometry(loadFactor);
    updateUI();
  });

  document.getElementById('speedSlider').addEventListener('input', (e) => {
    animationSpeed = parseFloat(e.target.value);
    document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
  });

  // ===================================================================
  // ACTUALIZAR UI
  // ===================================================================

  function updateUI() {
    const currentQ = (loadFactor * qMax / 1000).toFixed(2);
    const currentW = (loadFactor * wMaxTheory * 1000).toFixed(2);
    const percent = (loadFactor * 100).toFixed(0);

    document.getElementById('currentLoad').textContent = currentQ;
    document.getElementById('currentDefl').textContent = currentW;
    document.getElementById('loadPercent').textContent = percent;
  }

  // ===================================================================
  // ANIMACI√ìN PRINCIPAL
  // ===================================================================

  function animate() {
    requestAnimationFrame(animate);

    // Actualizar factor de carga
    if (isPlaying) {
      loadFactor += loadRate * animationSpeed;
      if (loadFactor >= 1) {
        loadFactor = 1;
        isPlaying = false;  // Pausar al llegar al m√°ximo
      }

      updateGeometry(loadFactor);
      updateUI();
    }

    controls.update();
    renderer.render(scene, camera);
  }

  animate();
  updateUI();
});
</script>
@{end html}

"CONCEPTOS DE ANIMACI√ìN:
"
"1. FACTOR DE CARGA (loadFactor):
"   - Var√≠a de 0 (sin carga) a 1 (carga completa)
"   - Se incrementa gradualmente en cada frame
"
"2. ACTUALIZACI√ìN DIN√ÅMICA:
"   - La geometr√≠a se recalcula cada frame
"   - Los atributos se marcan como 'needsUpdate'
"   - Three.js actualiza la GPU autom√°ticamente
"
"3. BUFFERATTRIBUTE:
"   - M√°s eficiente que recrear la geometr√≠a
"   - Modificamos los arrays in-place
"
"4. CONTROLES INTERACTIVOS:
"   - Play/Pause para controlar la animaci√≥n
"   - Reset para volver al inicio
"   - Slider de velocidad
"
"Este ejemplo muestra c√≥mo crear animaciones
"interactivas de an√°lisis estructural en tiempo real
