"IFC Viewer con Modelo Analítico Estructural
@{html-ifc}
<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>IFC + Modelo Analítico</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #fff;
            user-select: none;
        }
        #container { width: 100%; height: 100%; position: relative; }
        canvas { width: 100%; height: 100%; display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            background: rgba(0,0,0,0.92);
            padding: 5px 8px;
            border-radius: 6px;
            z-index: 100;
        }
        .toolbar button {
            background: #2d2d44;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 9px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.15s;
        }
        .toolbar button:hover { background: #3d3d5c; border-color: #0078d4; }
        .toolbar button.active { background: #0078d4; border-color: #0078d4; }
        .toolbar button.analytic { background: #8e44ad; border-color: #8e44ad; }
        .toolbar-sep { width: 1px; background: #444; margin: 0 3px; }

        /* Panels */
        .panel {
            position: absolute;
            background: rgba(10,10,20,0.95);
            padding: 10px;
            border-radius: 6px;
            font-size: 10px;
            z-index: 100;
            border: 1px solid #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .panel h4 {
            color: #0078d4;
            margin-bottom: 8px;
            font-size: 11px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .panel h4.analytic { color: #9b59b6; }
        .panel label { display: block; color: #888; margin-bottom: 2px; margin-top: 6px; font-size: 9px; }
        .panel input, .panel select {
            width: 100%;
            padding: 4px 6px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-size: 10px;
        }
        .panel input:focus, .panel select:focus { border-color: #0078d4; outline: none; }
        .panel button {
            width: 100%;
            padding: 6px;
            margin-top: 8px;
            background: #0078d4;
            border: none;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .panel button:hover { background: #0066b8; }
        .panel button.analytic-btn { background: #8e44ad; }
        .panel button.analytic-btn:hover { background: #7d3c98; }
        .panel button.secondary { background: #444; }
        .panel button.danger { background: #c0392b; }

        /* Element Info Panel */
        .element-panel {
            top: 50px;
            right: 10px;
            width: 240px;
            display: none;
        }
        .element-panel.visible { display: block; }
        .element-type {
            display: inline-block;
            background: #0078d4;
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            margin-bottom: 6px;
        }
        .element-name { font-size: 12px; font-weight: 600; margin-bottom: 8px; }
        .dim-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .dim-row .lbl { color: #888; }
        .dim-row .val { color: #fff; font-family: monospace; }

        /* Analytic Options */
        .analytic-section {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        .analytic-section h5 {
            color: #9b59b6;
            font-size: 10px;
            margin-bottom: 8px;
        }
        .axis-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px;
            background: #222;
            border-radius: 3px;
            margin: 3px 0;
            cursor: pointer;
        }
        .axis-option:hover { background: #333; }
        .axis-option input { margin: 0; }
        .axis-option label { margin: 0; color: #ccc; cursor: pointer; flex: 1; }
        .axis-preview {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Analytic Model Panel */
        .model-panel {
            top: 50px;
            left: 10px;
            width: 220px;
            display: none;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        .model-panel.visible { display: block; }
        .member-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px;
            background: #222;
            border-radius: 3px;
            margin: 3px 0;
            cursor: pointer;
        }
        .member-item:hover { background: #333; }
        .member-item.selected { background: #8e44ad; }
        .member-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .member-info { flex: 1; }
        .member-name { font-size: 10px; color: #fff; }
        .member-length { font-size: 8px; color: #888; }
        .member-delete {
            width: 16px;
            height: 16px;
            background: #c0392b;
            border: none;
            border-radius: 2px;
            color: #fff;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .member-delete:hover { background: #e74c3c; }

        /* Stats */
        .model-stats {
            background: #1a1a2e;
            padding: 6px;
            border-radius: 3px;
            margin-bottom: 8px;
        }
        .stat-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .stat-row .lbl { color: #888; }
        .stat-row .val { color: #9b59b6; font-weight: bold; }

        /* Info panel */
        .info-panel { bottom: 10px; left: 10px; }
        .info-panel strong { color: #0078d4; font-size: 11px; }

        /* Coords */
        .coords-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 5px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 9px;
        }
        .coords-display span { color: #0078d4; }

        /* Node markers */
        .node-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #f1c40f;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
        }

        /* Loading */
        .loading {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26,26,46,0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 3px solid #333; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; }
        .progress { width: 180px; height: 4px; background: #333; border-radius: 2px; margin-top: 12px; }
        .progress-fill { height: 100%; background: #0078d4; width: 0%; transition: width 0.3s; }

        /* Toggle visibility */
        .toggle-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        .toggle-row input { margin: 0; }
        .toggle-row label { margin: 0; color: #ccc; }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <!-- Toolbar -->
        <div class="toolbar">
            <button id="btn-3d" class="active">3D</button>
            <button id="btn-top">Planta</button>
            <button id="btn-front">Frontal</button>
            <button id="btn-right">Lateral</button>
            <div class="toolbar-sep"></div>
            <button id="btn-select" class="active">Seleccionar</button>
            <button id="btn-model" class="analytic">Modelo Analítico</button>
            <div class="toolbar-sep"></div>
            <button id="btn-export">Exportar</button>
            <button id="btn-fit">Fit</button>
        </div>

        <!-- Element Info Panel -->
        <div id="element-panel" class="panel element-panel">
            <h4>Elemento Seleccionado</h4>
            <div id="element-content">
                <p style="color:#666">Click en un elemento para seleccionarlo</p>
            </div>

            <div id="analytic-options" class="analytic-section" style="display:none">
                <h5>Generar Línea Analítica</h5>

                <label>Dirección del eje:</label>
                <div class="axis-option">
                    <input type="radio" name="axis-dir" id="axis-x" value="x">
                    <label for="axis-x">Eje X (Largo)</label>
                    <div class="axis-preview" style="background:#e74c3c"></div>
                </div>
                <div class="axis-option">
                    <input type="radio" name="axis-dir" id="axis-y" value="y" checked>
                    <label for="axis-y">Eje Y (Alto)</label>
                    <div class="axis-preview" style="background:#27ae60"></div>
                </div>
                <div class="axis-option">
                    <input type="radio" name="axis-dir" id="axis-z" value="z">
                    <label for="axis-z">Eje Z (Ancho)</label>
                    <div class="axis-preview" style="background:#3498db"></div>
                </div>

                <label>Posición en sección:</label>
                <select id="section-pos">
                    <option value="center">Centro (Centroide)</option>
                    <option value="top">Superior</option>
                    <option value="bottom">Inferior</option>
                    <option value="left">Izquierda</option>
                    <option value="right">Derecha</option>
                </select>

                <label>Nombre del miembro:</label>
                <input type="text" id="member-name" placeholder="Ej: V-01, C-05, B-12">

                <label>Tipo de elemento:</label>
                <select id="member-type">
                    <option value="beam">Viga (Beam)</option>
                    <option value="column">Columna (Column)</option>
                    <option value="brace">Arriostramiento (Brace)</option>
                    <option value="slab">Losa (Slab)</option>
                    <option value="wall">Muro (Wall)</option>
                </select>

                <label>Sección transversal:</label>
                <input type="text" id="section-name" placeholder="Ej: W12x26, HEB200, 30x50">

                <button id="btn-create-analytic" class="analytic-btn">Crear Línea Analítica</button>
            </div>
        </div>

        <!-- Analytic Model Panel -->
        <div id="model-panel" class="panel model-panel">
            <h4 class="analytic">Modelo Analítico</h4>

            <div class="model-stats">
                <div class="stat-row"><span class="lbl">Miembros:</span><span class="val" id="stat-members">0</span></div>
                <div class="stat-row"><span class="lbl">Nodos:</span><span class="val" id="stat-nodes">0</span></div>
                <div class="stat-row"><span class="lbl">Longitud total:</span><span class="val" id="stat-length">0.00 m</span></div>
            </div>

            <div class="toggle-row">
                <input type="checkbox" id="show-physical" checked>
                <label for="show-physical">Mostrar modelo físico</label>
            </div>
            <div class="toggle-row">
                <input type="checkbox" id="show-analytic" checked>
                <label for="show-analytic">Mostrar modelo analítico</label>
            </div>
            <div class="toggle-row">
                <input type="checkbox" id="show-nodes" checked>
                <label for="show-nodes">Mostrar nodos</label>
            </div>

            <label>Miembros:</label>
            <div id="members-list"></div>

            <button id="btn-clear-model" class="danger" style="margin-top:10px">Limpiar Modelo</button>
        </div>

        <!-- Export Panel (hidden by default) -->
        <div id="export-panel" class="panel" style="top:50%;left:50%;transform:translate(-50%,-50%);width:300px;display:none;z-index:150">
            <h4>Exportar Modelo Analítico</h4>
            <label>Formato:</label>
            <select id="export-format">
                <option value="json">JSON (Genérico)</option>
                <option value="csv">CSV (Nodos + Miembros)</option>
                <option value="dxf">DXF (AutoCAD)</option>
                <option value="s2k">S2K (SAP2000/ETABS)</option>
            </select>
            <button id="btn-do-export" class="analytic-btn">Exportar</button>
            <button id="btn-close-export" class="secondary">Cancelar</button>
        </div>

        <!-- Info -->
        <div class="panel info-panel">
            <strong>Modelo Analítico</strong>
            <div id="stats"></div>
            <div style="color:#555;margin-top:5px;font-size:9px">
                Click: Seleccionar | M: Modelo<br>
                1-4: Vistas | F: Fit
            </div>
        </div>

        <!-- Coords -->
        <div class="coords-display">
            X: <span id="coord-x">0.00</span> |
            Y: <span id="coord-y">0.00</span> |
            Z: <span id="coord-z">0.00</span>
        </div>

        <!-- Node markers container -->
        <div id="node-markers"></div>

        <!-- Loading -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <p style="margin-top:12px;color:#888;font-size:11px" id="status">Cargando...</p>
        </div>
    </div>

    <script src="https://calcpad.ifc/three.min.js"></script>
    <script src="https://calcpad.ifc/OrbitControls.js"></script>
    <script src="https://calcpad.ifc/web-ifc-api-iife.js"></script>
    <script>
    (async function() {
        // ========== DOM ==========
        const canvas = document.getElementById('canvas');
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const elementPanel = document.getElementById('element-panel');
        const elementContent = document.getElementById('element-content');
        const analyticOptions = document.getElementById('analytic-options');
        const modelPanel = document.getElementById('model-panel');
        const membersList = document.getElementById('members-list');
        const nodeMarkers = document.getElementById('node-markers');
        const exportPanel = document.getElementById('export-panel');

        // ========== STATE ==========
        let scene, camera, orthoCamera, renderer, controls;
        let allMeshes, analyticGroup, bbox, center, maxDim;
        let currentView = '3d';
        let selectedMesh = null;
        let selectedMemberIndex = -1;

        // Analytic model data
        let analyticModel = {
            members: [],  // { id, name, type, section, startNode, endNode, color, line }
            nodes: [],    // { id, position, connectedMembers }
            nextMemberId: 1,
            nextNodeId: 1
        };

        // Colors for member types
        const memberColors = {
            beam: 0xe74c3c,    // Red
            column: 0x27ae60,  // Green
            brace: 0xf39c12,   // Orange
            slab: 0x3498db,    // Blue
            wall: 0x9b59b6    // Purple
        };

        function updateProgress(msg, pct) {
            status.textContent = msg;
            progress.style.width = pct + '%';
        }

        try {
            updateProgress('Inicializando...', 10);

            // ========== SCENE ==========
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            camera.position.set(50, 50, 50);

            const aspect = container.clientWidth / container.clientHeight;
            orthoCamera = new THREE.OrthographicCamera(-50*aspect, 50*aspect, 50, -50, 0.1, 10000);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(50, 100, 50);
            scene.add(light);

            // Grid
            scene.add(new THREE.GridHelper(200, 200, 0x333333, 0x222222));

            // Analytic group
            analyticGroup = new THREE.Group();
            analyticGroup.name = 'analyticModel';
            scene.add(analyticGroup);

            // ========== LOAD IFC ==========
            updateProgress('Descargando IFC...', 20);
            const response = await fetch('https://calcpad.ifc/temp_a7ce813c013e4fc48bd57558ccf7ebd6.ifc');
            if (!response.ok) throw new Error('Error: ' + response.status);

            updateProgress('Leyendo...', 40);
            const ifcData = await response.arrayBuffer();

            updateProgress('Inicializando web-ifc...', 50);
            const ifcApi = new WebIFC.IfcAPI();
            await ifcApi.Init(p => p.endsWith('.wasm') ? 'https://calcpad.ifc/' + p : p);

            updateProgress('Parseando...', 60);
            const modelID = ifcApi.OpenModel(new Uint8Array(ifcData));

            updateProgress('Generando geometría...', 70);
            const flatMeshes = ifcApi.LoadAllGeometry(modelID);

            updateProgress('Construyendo...', 80);
            allMeshes = new THREE.Group();
            let meshCount = 0;

            for (let i = 0; i < flatMeshes.size(); i++) {
                const fm = flatMeshes.get(i);
                const geoms = fm.geometries;

                for (let j = 0; j < geoms.size(); j++) {
                    const pg = geoms.get(j);
                    const geom = ifcApi.GetGeometry(modelID, pg.geometryExpressID);
                    const verts = ifcApi.GetVertexArray(geom.GetVertexData(), geom.GetVertexDataSize());
                    const indices = ifcApi.GetIndexArray(geom.GetIndexData(), geom.GetIndexDataSize());

                    if (verts.length === 0 || indices.length === 0) continue;

                    const positions = new Float32Array(verts.length / 2);
                    const normals = new Float32Array(verts.length / 2);

                    for (let k = 0; k < verts.length; k += 6) {
                        const idx = (k / 6) * 3;
                        positions[idx] = verts[k];
                        positions[idx + 1] = verts[k + 1];
                        positions[idx + 2] = verts[k + 2];
                        normals[idx] = verts[k + 3];
                        normals[idx + 1] = verts[k + 4];
                        normals[idx + 2] = verts[k + 5];
                    }

                    const bufGeom = new THREE.BufferGeometry();
                    bufGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    bufGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                    bufGeom.setIndex(new THREE.BufferAttribute(indices, 1));

                    const color = new THREE.Color(pg.color.x, pg.color.y, pg.color.z);
                    const mat = new THREE.MeshPhongMaterial({
                        color, side: THREE.DoubleSide,
                        transparent: true, opacity: pg.color.w
                    });

                    const mesh = new THREE.Mesh(bufGeom, mat);
                    mesh.userData.expressID = fm.expressID;
                    mesh.userData.originalColor = color.clone();
                    mesh.userData.originalOpacity = pg.color.w;
                    mesh.applyMatrix4(new THREE.Matrix4().fromArray(pg.flatTransformation));
                    allMeshes.add(mesh);
                    meshCount++;
                }
            }

            scene.add(allMeshes);
            ifcApi.CloseModel(modelID);

            // ========== ADJUST VIEW ==========
            updateProgress('Ajustando...', 90);
            bbox = new THREE.Box3().setFromObject(allMeshes);
            center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            maxDim = Math.max(size.x, size.y, size.z);

            camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
            controls.target.copy(center);
            controls.update();

            loading.style.display = 'none';
            document.getElementById('stats').innerHTML = '<br>' + meshCount + ' elementos';

            // ========== SELECTION ==========
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function selectElement(mesh) {
                // Deselect previous
                if (selectedMesh) {
                    selectedMesh.material.emissive.setHex(0x000000);
                    selectedMesh.material.opacity = selectedMesh.userData.originalOpacity;
                }

                selectedMesh = mesh;

                if (mesh) {
                    mesh.material.emissive.setHex(0x333366);

                    const meshBox = new THREE.Box3().setFromObject(mesh);
                    const meshCenter = meshBox.getCenter(new THREE.Vector3());
                    const meshSize = meshBox.getSize(new THREE.Vector3());

                    // Determine likely element type based on dimensions
                    let suggestedType = 'beam';
                    let suggestedAxis = 'x';

                    if (meshSize.y > meshSize.x && meshSize.y > meshSize.z) {
                        suggestedType = 'column';
                        suggestedAxis = 'y';
                    } else if (meshSize.x > meshSize.z) {
                        suggestedType = 'beam';
                        suggestedAxis = 'x';
                    } else {
                        suggestedType = 'beam';
                        suggestedAxis = 'z';
                    }

                    // Update UI
                    elementContent.innerHTML = `
                        <span class="element-type">${suggestedType.toUpperCase()}</span>
                        <div class="element-name">Elemento #${mesh.userData.expressID || 'N/A'}</div>
                        <div class="dim-row"><span class="lbl">Largo X:</span><span class="val">${meshSize.x.toFixed(3)} m</span></div>
                        <div class="dim-row"><span class="lbl">Alto Y:</span><span class="val">${meshSize.y.toFixed(3)} m</span></div>
                        <div class="dim-row"><span class="lbl">Ancho Z:</span><span class="val">${meshSize.z.toFixed(3)} m</span></div>
                        <div class="dim-row"><span class="lbl">Centro:</span><span class="val">(${meshCenter.x.toFixed(2)}, ${meshCenter.y.toFixed(2)}, ${meshCenter.z.toFixed(2)})</span></div>
                    `;

                    // Set suggested values
                    document.getElementById('member-type').value = suggestedType;
                    document.getElementById('axis-' + suggestedAxis).checked = true;

                    // Auto-generate name
                    const prefix = suggestedType === 'column' ? 'C' : suggestedType === 'beam' ? 'V' : 'B';
                    document.getElementById('member-name').value = prefix + '-' + String(analyticModel.nextMemberId).padStart(2, '0');

                    // Auto-generate section name based on dimensions
                    if (suggestedType === 'column') {
                        const secX = (meshSize.x * 100).toFixed(0);
                        const secZ = (meshSize.z * 100).toFixed(0);
                        document.getElementById('section-name').value = secX + 'x' + secZ;
                    } else {
                        const secY = (meshSize.y * 100).toFixed(0);
                        const secZ = (meshSize.z * 100).toFixed(0);
                        document.getElementById('section-name').value = secZ + 'x' + secY;
                    }

                    analyticOptions.style.display = 'block';
                    elementPanel.classList.add('visible');
                } else {
                    elementContent.innerHTML = '<p style="color:#666">Click en un elemento</p>';
                    analyticOptions.style.display = 'none';
                }
            }

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                const activeCam = currentView === '3d' ? camera : orthoCamera;
                raycaster.setFromCamera(mouse, activeCam);

                const intersects = raycaster.intersectObjects(allMeshes.children, true);

                if (intersects.length > 0) {
                    selectElement(intersects[0].object);
                } else {
                    selectElement(null);
                }
            });

            // ========== ANALYTIC MODEL FUNCTIONS ==========
            function findOrCreateNode(position, tolerance = 0.01) {
                // Check if node exists at this position
                for (const node of analyticModel.nodes) {
                    if (node.position.distanceTo(position) < tolerance) {
                        return node;
                    }
                }

                // Create new node
                const newNode = {
                    id: analyticModel.nextNodeId++,
                    position: position.clone(),
                    connectedMembers: []
                };
                analyticModel.nodes.push(newNode);
                return newNode;
            }

            function createAnalyticLine() {
                if (!selectedMesh) return;

                const meshBox = new THREE.Box3().setFromObject(selectedMesh);
                const meshCenter = meshBox.getCenter(new THREE.Vector3());
                const meshSize = meshBox.getSize(new THREE.Vector3());
                const meshMin = meshBox.min;
                const meshMax = meshBox.max;

                // Get user options
                const axisDir = document.querySelector('input[name="axis-dir"]:checked').value;
                const sectionPos = document.getElementById('section-pos').value;
                const memberName = document.getElementById('member-name').value || 'M-' + analyticModel.nextMemberId;
                const memberType = document.getElementById('member-type').value;
                const sectionName = document.getElementById('section-name').value || 'Generic';

                // Calculate start and end points
                let startPoint = new THREE.Vector3();
                let endPoint = new THREE.Vector3();

                // Base position (section position)
                let baseX = meshCenter.x;
                let baseY = meshCenter.y;
                let baseZ = meshCenter.z;

                switch (sectionPos) {
                    case 'top':
                        if (axisDir === 'y') baseX = meshMax.x;
                        else baseY = meshMax.y;
                        break;
                    case 'bottom':
                        if (axisDir === 'y') baseX = meshMin.x;
                        else baseY = meshMin.y;
                        break;
                    case 'left':
                        if (axisDir === 'x') baseZ = meshMin.z;
                        else baseX = meshMin.x;
                        break;
                    case 'right':
                        if (axisDir === 'x') baseZ = meshMax.z;
                        else baseX = meshMax.x;
                        break;
                }

                // Calculate line endpoints based on axis
                switch (axisDir) {
                    case 'x':
                        startPoint.set(meshMin.x, baseY, baseZ);
                        endPoint.set(meshMax.x, baseY, baseZ);
                        break;
                    case 'y':
                        startPoint.set(baseX, meshMin.y, baseZ);
                        endPoint.set(baseX, meshMax.y, baseZ);
                        break;
                    case 'z':
                        startPoint.set(baseX, baseY, meshMin.z);
                        endPoint.set(baseX, baseY, meshMax.z);
                        break;
                }

                // Find or create nodes
                const startNode = findOrCreateNode(startPoint);
                const endNode = findOrCreateNode(endPoint);

                // Create 3D line
                const lineColor = memberColors[memberType] || 0xffffff;
                const lineMat = new THREE.LineBasicMaterial({ color: lineColor, linewidth: 3 });
                const lineGeom = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);
                const line = new THREE.Line(lineGeom, lineMat);

                // Create tube for better visibility
                const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
                const length = direction.length();
                direction.normalize();

                const tubeGeom = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
                const tubeMat = new THREE.MeshBasicMaterial({ color: lineColor });
                const tube = new THREE.Mesh(tubeGeom, tubeMat);

                // Position and rotate tube
                const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
                tube.position.copy(midPoint);

                // Rotate to align with direction
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                tube.quaternion.copy(quaternion);

                // Create node spheres
                const nodeMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });
                const nodeGeom = new THREE.SphereGeometry(0.15, 16, 16);

                const startSphere = new THREE.Mesh(nodeGeom, nodeMat);
                startSphere.position.copy(startPoint);

                const endSphere = new THREE.Mesh(nodeGeom, nodeMat);
                endSphere.position.copy(endPoint);

                // Group for this member
                const memberGroup = new THREE.Group();
                memberGroup.add(tube);
                memberGroup.add(startSphere);
                memberGroup.add(endSphere);
                analyticGroup.add(memberGroup);

                // Store member data
                const member = {
                    id: analyticModel.nextMemberId++,
                    name: memberName,
                    type: memberType,
                    section: sectionName,
                    startNode: startNode.id,
                    endNode: endNode.id,
                    length: length,
                    color: lineColor,
                    group: memberGroup,
                    sourceExpressID: selectedMesh.userData.expressID
                };

                analyticModel.members.push(member);

                // Update node connections
                startNode.connectedMembers.push(member.id);
                endNode.connectedMembers.push(member.id);

                // Update UI
                updateModelPanel();

                // Auto-increment name for next element
                const prefix = memberType === 'column' ? 'C' : memberType === 'beam' ? 'V' : 'B';
                document.getElementById('member-name').value = prefix + '-' + String(analyticModel.nextMemberId).padStart(2, '0');
            }

            function deleteMember(index) {
                const member = analyticModel.members[index];
                if (!member) return;

                // Remove from scene
                analyticGroup.remove(member.group);

                // Remove from nodes
                analyticModel.nodes.forEach(node => {
                    node.connectedMembers = node.connectedMembers.filter(id => id !== member.id);
                });

                // Remove orphan nodes
                analyticModel.nodes = analyticModel.nodes.filter(node => node.connectedMembers.length > 0);

                // Remove member
                analyticModel.members.splice(index, 1);

                updateModelPanel();
            }

            function clearModel() {
                // Remove all from scene
                while (analyticGroup.children.length > 0) {
                    analyticGroup.remove(analyticGroup.children[0]);
                }

                // Reset data
                analyticModel = {
                    members: [],
                    nodes: [],
                    nextMemberId: 1,
                    nextNodeId: 1
                };

                updateModelPanel();
            }

            function updateModelPanel() {
                // Stats
                document.getElementById('stat-members').textContent = analyticModel.members.length;
                document.getElementById('stat-nodes').textContent = analyticModel.nodes.length;

                const totalLength = analyticModel.members.reduce((sum, m) => sum + m.length, 0);
                document.getElementById('stat-length').textContent = totalLength.toFixed(2) + ' m';

                // Members list
                membersList.innerHTML = '';
                analyticModel.members.forEach((member, index) => {
                    const item = document.createElement('div');
                    item.className = 'member-item' + (index === selectedMemberIndex ? ' selected' : '');
                    item.innerHTML = `
                        <div class="member-color" style="background:#${member.color.toString(16).padStart(6,'0')}"></div>
                        <div class="member-info">
                            <div class="member-name">${member.name} (${member.type})</div>
                            <div class="member-length">${member.section} | L=${member.length.toFixed(3)}m</div>
                        </div>
                        <button class="member-delete" data-index="${index}">×</button>
                    `;
                    item.querySelector('.member-delete').onclick = (e) => {
                        e.stopPropagation();
                        deleteMember(index);
                    };
                    item.onclick = () => {
                        selectedMemberIndex = index;
                        updateModelPanel();
                        // Highlight member
                        analyticModel.members.forEach((m, i) => {
                            m.group.children[0].material.color.setHex(i === index ? 0xffffff : m.color);
                        });
                    };
                    membersList.appendChild(item);
                });
            }

            // ========== EXPORT FUNCTIONS ==========
            function exportModel(format) {
                let content = '';
                let filename = 'modelo_analitico';
                let mimeType = 'text/plain';

                switch (format) {
                    case 'json':
                        content = JSON.stringify({
                            nodes: analyticModel.nodes.map(n => ({
                                id: n.id,
                                x: n.position.x,
                                y: n.position.y,
                                z: n.position.z
                            })),
                            members: analyticModel.members.map(m => ({
                                id: m.id,
                                name: m.name,
                                type: m.type,
                                section: m.section,
                                startNode: m.startNode,
                                endNode: m.endNode,
                                length: m.length
                            }))
                        }, null, 2);
                        filename += '.json';
                        mimeType = 'application/json';
                        break;

                    case 'csv':
                        // Nodes
                        content = "=== NODES ===\nID,X,Y,Z\n";
                        analyticModel.nodes.forEach(n => {
                            content += `${n.id},${n.position.x.toFixed(6)},${n.position.y.toFixed(6)},${n.position.z.toFixed(6)}\n`;
                        });
                        // Members
                        content += "\n=== MEMBERS ===\nID,Name,Type,Section,StartNode,EndNode,Length\n";
                        analyticModel.members.forEach(m => {
                            content += `${m.id},${m.name},${m.type},${m.section},${m.startNode},${m.endNode},${m.length.toFixed(6)}\n`;
                        });
                        filename += '.csv';
                        break;

                    case 's2k':
                        // SAP2000/ETABS format
                        content = `$ SAP2000/ETABS Model - Exported from Calcpad IFC Viewer\n`;
                        content += `$ Date: ${new Date().toISOString()}\n\n`;

                        content += `TABLE:  "JOINT COORDINATES"\n`;
                        content += `   Joint=Text   CoordSys=Text   CoordType=Text   XorR=Unitless   Y=Unitless   Z=Unitless\n`;
                        analyticModel.nodes.forEach(n => {
                            content += `   ${n.id}   GLOBAL   Cartesian   ${n.position.x.toFixed(6)}   ${n.position.z.toFixed(6)}   ${n.position.y.toFixed(6)}\n`;
                        });
                        content += `END TABLE DATA\n\n`;

                        content += `TABLE:  "CONNECTIVITY - FRAME"\n`;
                        content += `   Frame=Text   JointI=Text   JointJ=Text   IsCurved=Yes/No   GUID=Text\n`;
                        analyticModel.members.forEach(m => {
                            content += `   ${m.name}   ${m.startNode}   ${m.endNode}   No\n`;
                        });
                        content += `END TABLE DATA\n\n`;

                        content += `TABLE:  "FRAME SECTION ASSIGNMENTS"\n`;
                        content += `   Frame=Text   SectionType=Text   AutoSelect=Text   AnalSect=Text\n`;
                        analyticModel.members.forEach(m => {
                            content += `   ${m.name}   ${m.section}   N.A.   ${m.section}\n`;
                        });
                        content += `END TABLE DATA\n`;

                        filename += '.$2k';
                        break;

                    case 'dxf':
                        // Simple DXF
                        content = `0\nSECTION\n2\nENTITIES\n`;
                        analyticModel.members.forEach(m => {
                            const startNode = analyticModel.nodes.find(n => n.id === m.startNode);
                            const endNode = analyticModel.nodes.find(n => n.id === m.endNode);
                            if (startNode && endNode) {
                                content += `0\nLINE\n8\n${m.type}\n`;
                                content += `10\n${startNode.position.x.toFixed(6)}\n20\n${startNode.position.z.toFixed(6)}\n30\n${startNode.position.y.toFixed(6)}\n`;
                                content += `11\n${endNode.position.x.toFixed(6)}\n21\n${endNode.position.z.toFixed(6)}\n31\n${endNode.position.y.toFixed(6)}\n`;
                            }
                        });
                        content += `0\nENDSEC\n0\nEOF\n`;
                        filename += '.dxf';
                        break;
                }

                // Download
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                exportPanel.style.display = 'none';
            }

            // ========== VIEW FUNCTIONS ==========
            function setView(view) {
                currentView = view;
                document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));

                const dist = maxDim * 2;

                switch(view) {
                    case '3d':
                        document.getElementById('btn-3d').classList.add('active');
                        controls.object = camera;
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.enableRotate = true;
                        break;
                    case 'top':
                        document.getElementById('btn-top').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y + dist, center.z);
                        orthoCamera.up.set(0, 0, -1);
                        controls.enableRotate = false;
                        break;
                    case 'front':
                        document.getElementById('btn-front').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y, center.z + dist);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                    case 'right':
                        document.getElementById('btn-right').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x + dist, center.y, center.z);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                }
                controls.target.copy(center);
                controls.update();
                document.getElementById('btn-select').classList.add('active');
            }

            function updateOrtho(size) {
                const aspect = container.clientWidth / container.clientHeight;
                orthoCamera.left = -size * aspect;
                orthoCamera.right = size * aspect;
                orthoCamera.top = size;
                orthoCamera.bottom = -size;
                orthoCamera.updateProjectionMatrix();
            }

            // ========== EVENT LISTENERS ==========
            document.getElementById('btn-3d').onclick = () => setView('3d');
            document.getElementById('btn-top').onclick = () => setView('top');
            document.getElementById('btn-front').onclick = () => setView('front');
            document.getElementById('btn-right').onclick = () => setView('right');

            document.getElementById('btn-fit').onclick = () => {
                camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                controls.target.copy(center);
                controls.update();
            };

            document.getElementById('btn-model').onclick = function() {
                this.classList.toggle('active');
                modelPanel.classList.toggle('visible');
            };

            document.getElementById('btn-export').onclick = () => {
                exportPanel.style.display = 'block';
            };

            document.getElementById('btn-do-export').onclick = () => {
                const format = document.getElementById('export-format').value;
                exportModel(format);
            };

            document.getElementById('btn-close-export').onclick = () => {
                exportPanel.style.display = 'none';
            };

            document.getElementById('btn-create-analytic').onclick = createAnalyticLine;
            document.getElementById('btn-clear-model').onclick = clearModel;

            // Visibility toggles
            document.getElementById('show-physical').onchange = (e) => {
                allMeshes.visible = e.target.checked;
            };

            document.getElementById('show-analytic').onchange = (e) => {
                analyticGroup.visible = e.target.checked;
            };

            document.getElementById('show-nodes').onchange = (e) => {
                analyticGroup.children.forEach(group => {
                    // Nodes are children 1 and 2 (spheres)
                    if (group.children.length >= 3) {
                        group.children[1].visible = e.target.checked;
                        group.children[2].visible = e.target.checked;
                    }
                });
            };

            // Mouse tracking
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                const activeCam = currentView === '3d' ? camera : orthoCamera;
                raycaster.setFromCamera(mouse, activeCam);

                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const pt = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, pt);

                if (pt) {
                    document.getElementById('coord-x').textContent = pt.x.toFixed(2);
                    document.getElementById('coord-y').textContent = pt.y.toFixed(2);
                    document.getElementById('coord-z').textContent = pt.z.toFixed(2);
                }
            });

            // Keyboard
            document.addEventListener('keydown', e => {
                switch(e.key) {
                    case '1': setView('3d'); break;
                    case '2': setView('top'); break;
                    case '3': setView('front'); break;
                    case '4': setView('right'); break;
                    case 'f': case 'F':
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.target.copy(center);
                        controls.update();
                        break;
                    case 'm': case 'M':
                        document.getElementById('btn-model').click();
                        break;
                    case 'Enter':
                        if (selectedMesh && analyticOptions.style.display !== 'none') {
                            createAnalyticLine();
                        }
                        break;
                    case 'Escape':
                        selectElement(null);
                        elementPanel.classList.remove('visible');
                        break;
                }
            });

            // Resize
            window.addEventListener('resize', () => {
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                updateOrtho(maxDim * 2);
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // ========== ANIMATION ==========
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                const activeCam = currentView === '3d' ? camera : orthoCamera;
                renderer.render(scene, activeCam);
            }
            animate();

        } catch (err) {
            console.error(err);
            status.textContent = 'Error: ' + err.message;
            status.style.color = '#ff6b6b';
        }
    })();
    </script>
</body>
</html>
@{end html-ifc}
