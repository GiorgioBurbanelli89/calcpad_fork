"IFC Viewer - Modelo Analítico con Posicionamiento Manual
@{html-ifc}
<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Modelo Analítico - Posicionamiento Manual</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #fff;
            user-select: none;
        }
        #container { width: 100%; height: 100%; position: relative; }
        canvas { width: 100%; height: 100%; display: block; cursor: crosshair; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }

        .toolbar {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            background: rgba(0,0,0,0.92);
            padding: 5px 8px;
            border-radius: 6px;
            z-index: 100;
        }
        .toolbar button {
            background: #2d2d44;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 9px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.15s;
        }
        .toolbar button:hover { background: #3d3d5c; border-color: #0078d4; }
        .toolbar button.active { background: #0078d4; }
        .toolbar button.drawing { background: #e74c3c; animation: pulse 1s infinite; }
        .toolbar button.analytic { background: #8e44ad; }
        .toolbar-sep { width: 1px; background: #444; margin: 0 3px; }

        .panel {
            position: absolute;
            background: rgba(10,10,20,0.95);
            padding: 10px;
            border-radius: 6px;
            font-size: 10px;
            z-index: 100;
            border: 1px solid #333;
        }
        .panel h4 { color: #0078d4; margin-bottom: 8px; font-size: 11px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .panel h4.purple { color: #9b59b6; }
        .panel label { display: block; color: #888; margin: 6px 0 2px; font-size: 9px; }
        .panel input, .panel select {
            width: 100%;
            padding: 4px 6px;
            background: #1a1a2e;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
            font-size: 10px;
        }
        .panel button {
            width: 100%;
            padding: 6px;
            margin-top: 8px;
            background: #0078d4;
            border: none;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .panel button:hover { background: #0066b8; }
        .panel button.purple { background: #8e44ad; }
        .panel button.red { background: #c0392b; }
        .panel button.gray { background: #555; }

        /* Drawing mode panel */
        .draw-panel {
            top: 50px;
            right: 10px;
            width: 220px;
            display: none;
        }
        .draw-panel.visible { display: block; }
        .draw-status {
            background: #222;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            text-align: center;
        }
        .draw-status.waiting { color: #f39c12; }
        .draw-status.point1 { color: #3498db; }
        .draw-status.point2 { color: #27ae60; }
        .point-info {
            background: #1a1a2e;
            padding: 6px;
            border-radius: 3px;
            margin: 4px 0;
            font-family: monospace;
            font-size: 9px;
        }
        .point-info .label { color: #888; }
        .point-info .coords { color: #0078d4; }

        /* Model panel */
        .model-panel {
            top: 50px;
            left: 10px;
            width: 220px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            display: none;
        }
        .model-panel.visible { display: block; }
        .model-stats {
            background: #1a1a2e;
            padding: 6px;
            border-radius: 3px;
            margin-bottom: 8px;
        }
        .stat-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .stat-row .lbl { color: #888; }
        .stat-row .val { color: #9b59b6; font-weight: bold; }
        .member-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px;
            background: #222;
            border-radius: 3px;
            margin: 3px 0;
            cursor: pointer;
        }
        .member-item:hover { background: #333; }
        .member-item.selected { background: #8e44ad; }
        .member-color { width: 10px; height: 10px; border-radius: 2px; }
        .member-info { flex: 1; }
        .member-name { font-size: 10px; }
        .member-length { font-size: 8px; color: #888; }
        .member-del {
            width: 16px; height: 16px;
            background: #c0392b;
            border: none;
            border-radius: 2px;
            color: #fff;
            cursor: pointer;
            font-size: 10px;
        }

        /* Snap indicator */
        .snap-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            display: none;
        }
        .snap-indicator.visible { display: block; }
        .snap-marker {
            width: 14px; height: 14px;
            border: 2px solid #f1c40f;
            background: rgba(241,196,15,0.3);
            position: absolute;
            transform: translate(-50%, -50%);
        }
        .snap-marker.endpoint { border-radius: 0; }
        .snap-marker.midpoint { border-radius: 50%; }
        .snap-marker.center { border-radius: 50%; background: rgba(241,196,15,0.6); }
        .snap-marker.face { border-radius: 2px; }
        .snap-label {
            position: absolute;
            top: 10px; left: 10px;
            background: rgba(241,196,15,0.9);
            color: #000;
            padding: 2px 5px;
            border-radius: 2px;
            font-size: 8px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Preview line */
        .preview-line {
            position: absolute;
            pointer-events: none;
            z-index: 140;
        }

        /* Info panel */
        .info-panel { bottom: 10px; left: 10px; }
        .info-panel strong { color: #9b59b6; font-size: 11px; }

        /* Coords */
        .coords-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 5px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 9px;
        }
        .coords-display span { color: #0078d4; }

        /* Instructions */
        .instructions {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 11px;
            display: none;
            border: 1px solid #8e44ad;
        }
        .instructions.visible { display: block; }
        .instructions .key { background: #444; padding: 2px 6px; border-radius: 3px; margin: 0 3px; }

        /* Loading */
        .loading {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26,26,46,0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 3px solid #333; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; }
        .progress { width: 180px; height: 4px; background: #333; border-radius: 2px; margin-top: 12px; }
        .progress-fill { height: 100%; background: #0078d4; width: 0%; transition: width 0.3s; }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <!-- Toolbar -->
        <div class="toolbar">
            <button id="btn-3d" class="active">3D</button>
            <button id="btn-top">Planta</button>
            <button id="btn-front">Frontal</button>
            <button id="btn-right">Lateral</button>
            <div class="toolbar-sep"></div>
            <button id="btn-draw" class="analytic" title="Dibujar línea analítica (D)">Dibujar Eje</button>
            <button id="btn-model" title="Ver modelo analítico (M)">Modelo</button>
            <div class="toolbar-sep"></div>
            <button id="btn-export">Exportar</button>
            <button id="btn-fit">Fit</button>
        </div>

        <!-- Draw Panel -->
        <div id="draw-panel" class="panel draw-panel">
            <h4 class="purple">Dibujar Línea Analítica</h4>

            <div id="draw-status" class="draw-status waiting">
                Click en el modelo para definir punto inicial
            </div>

            <div class="point-info">
                <span class="label">Punto 1:</span>
                <span class="coords" id="point1-coords">---</span>
            </div>
            <div class="point-info">
                <span class="label">Punto 2:</span>
                <span class="coords" id="point2-coords">---</span>
            </div>
            <div class="point-info">
                <span class="label">Longitud:</span>
                <span class="coords" id="line-length">---</span>
            </div>

            <label>Nombre del miembro:</label>
            <input type="text" id="member-name" value="V-01">

            <label>Tipo:</label>
            <select id="member-type">
                <option value="beam">Viga</option>
                <option value="column">Columna</option>
                <option value="brace">Arriostramiento</option>
            </select>

            <label>Sección:</label>
            <input type="text" id="section-name" value="30x50">

            <button id="btn-confirm" class="purple" style="display:none">Confirmar (Enter)</button>
            <button id="btn-cancel" class="gray">Cancelar (Esc)</button>
        </div>

        <!-- Model Panel -->
        <div id="model-panel" class="panel model-panel">
            <h4 class="purple">Modelo Analítico</h4>

            <div class="model-stats">
                <div class="stat-row"><span class="lbl">Miembros:</span><span class="val" id="stat-members">0</span></div>
                <div class="stat-row"><span class="lbl">Nodos:</span><span class="val" id="stat-nodes">0</span></div>
                <div class="stat-row"><span class="lbl">Long. total:</span><span class="val" id="stat-length">0.00 m</span></div>
            </div>

            <div style="display:flex;gap:6px;margin-bottom:8px">
                <label style="display:flex;align-items:center;gap:4px;margin:0">
                    <input type="checkbox" id="show-physical" checked> Físico
                </label>
                <label style="display:flex;align-items:center;gap:4px;margin:0">
                    <input type="checkbox" id="show-analytic" checked> Analítico
                </label>
            </div>

            <label>Miembros:</label>
            <div id="members-list"></div>

            <button id="btn-clear" class="red" style="margin-top:10px">Limpiar Todo</button>
        </div>

        <!-- Snap indicator -->
        <div id="snap-indicator" class="snap-indicator">
            <div class="snap-marker endpoint" id="snap-marker"></div>
            <div class="snap-label" id="snap-label">Punto</div>
        </div>

        <!-- Instructions -->
        <div id="instructions" class="instructions">
            <span class="key">Click</span> Punto inicial →
            <span class="key">Click</span> Punto final →
            <span class="key">Enter</span> Confirmar |
            <span class="key">Esc</span> Cancelar
        </div>

        <!-- Info -->
        <div class="panel info-panel">
            <strong>Modelo Analítico Manual</strong>
            <div id="stats"></div>
            <div style="color:#555;margin-top:5px;font-size:9px">
                D: Dibujar | M: Modelo | 1-4: Vistas
            </div>
        </div>

        <!-- Coords -->
        <div class="coords-display">
            X: <span id="coord-x">0.00</span> |
            Y: <span id="coord-y">0.00</span> |
            Z: <span id="coord-z">0.00</span>
        </div>

        <!-- Loading -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <p style="margin-top:12px;color:#888;font-size:11px" id="status">Cargando...</p>
        </div>
    </div>

    <script src="https://calcpad.ifc/three.min.js"></script>
    <script src="https://calcpad.ifc/OrbitControls.js"></script>
    <script src="https://calcpad.ifc/web-ifc-api-iife.js"></script>
    <script>
    (async function() {
        const canvas = document.getElementById('canvas');
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const snapIndicator = document.getElementById('snap-indicator');
        const snapMarker = document.getElementById('snap-marker');
        const snapLabelEl = document.getElementById('snap-label');
        const instructions = document.getElementById('instructions');
        const drawPanel = document.getElementById('draw-panel');
        const modelPanel = document.getElementById('model-panel');
        const drawStatus = document.getElementById('draw-status');

        let scene, camera, orthoCamera, renderer, controls;
        let allMeshes, analyticGroup, previewLine;
        let bbox, center, maxDim;
        let currentView = '3d';

        // Drawing state
        let drawMode = false;
        let drawStep = 0; // 0: waiting, 1: first point set, 2: both points set
        let point1 = null;
        let point2 = null;
        let currentSnapPoint = null;
        let snapPoints = [];

        // Model
        let model = {
            members: [],
            nodes: [],
            nextId: 1,
            nextNodeId: 1
        };

        const colors = {
            beam: 0xe74c3c,
            column: 0x27ae60,
            brace: 0xf39c12
        };

        function updateProgress(msg, pct) {
            document.getElementById('status').textContent = msg;
            document.getElementById('progress').style.width = pct + '%';
        }

        try {
            updateProgress('Inicializando...', 10);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            camera.position.set(50, 50, 50);

            const aspect = container.clientWidth / container.clientHeight;
            orthoCamera = new THREE.OrthographicCamera(-50*aspect, 50*aspect, 50, -50, 0.1, 10000);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(50, 100, 50);
            scene.add(light);

            scene.add(new THREE.GridHelper(200, 200, 0x333333, 0x222222));

            analyticGroup = new THREE.Group();
            scene.add(analyticGroup);

            // Preview line (dashed)
            const previewMat = new THREE.LineDashedMaterial({ color: 0xf1c40f, dashSize: 0.5, gapSize: 0.3 });
            const previewGeom = new THREE.BufferGeometry();
            previewLine = new THREE.Line(previewGeom, previewMat);
            previewLine.visible = false;
            scene.add(previewLine);

            // Load IFC
            updateProgress('Descargando IFC...', 20);
            const response = await fetch('https://calcpad.ifc/temp_a7ce813c013e4fc48bd57558ccf7ebd6.ifc');
            if (!response.ok) throw new Error('Error: ' + response.status);

            updateProgress('Leyendo...', 40);
            const ifcData = await response.arrayBuffer();

            updateProgress('Inicializando web-ifc...', 50);
            const ifcApi = new WebIFC.IfcAPI();
            await ifcApi.Init(p => p.endsWith('.wasm') ? 'https://calcpad.ifc/' + p : p);

            updateProgress('Parseando...', 60);
            const modelID = ifcApi.OpenModel(new Uint8Array(ifcData));

            updateProgress('Generando geometría...', 70);
            const flatMeshes = ifcApi.LoadAllGeometry(modelID);

            updateProgress('Construyendo...', 80);
            allMeshes = new THREE.Group();
            let meshCount = 0;

            for (let i = 0; i < flatMeshes.size(); i++) {
                const fm = flatMeshes.get(i);
                const geoms = fm.geometries;

                for (let j = 0; j < geoms.size(); j++) {
                    const pg = geoms.get(j);
                    const geom = ifcApi.GetGeometry(modelID, pg.geometryExpressID);
                    const verts = ifcApi.GetVertexArray(geom.GetVertexData(), geom.GetVertexDataSize());
                    const indices = ifcApi.GetIndexArray(geom.GetIndexData(), geom.GetIndexDataSize());

                    if (verts.length === 0 || indices.length === 0) continue;

                    const positions = new Float32Array(verts.length / 2);
                    const normals = new Float32Array(verts.length / 2);

                    for (let k = 0; k < verts.length; k += 6) {
                        const idx = (k / 6) * 3;
                        positions[idx] = verts[k];
                        positions[idx + 1] = verts[k + 1];
                        positions[idx + 2] = verts[k + 2];
                        normals[idx] = verts[k + 3];
                        normals[idx + 1] = verts[k + 4];
                        normals[idx + 2] = verts[k + 5];
                    }

                    const bufGeom = new THREE.BufferGeometry();
                    bufGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    bufGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                    bufGeom.setIndex(new THREE.BufferAttribute(indices, 1));

                    const color = new THREE.Color(pg.color.x, pg.color.y, pg.color.z);
                    const mat = new THREE.MeshPhongMaterial({
                        color, side: THREE.DoubleSide,
                        transparent: true, opacity: pg.color.w
                    });

                    const mesh = new THREE.Mesh(bufGeom, mat);
                    mesh.applyMatrix4(new THREE.Matrix4().fromArray(pg.flatTransformation));
                    allMeshes.add(mesh);
                    meshCount++;

                    // Generate snap points from this mesh
                    generateSnapPointsFromMesh(mesh);
                }
            }

            scene.add(allMeshes);
            ifcApi.CloseModel(modelID);

            updateProgress('Ajustando...', 90);
            bbox = new THREE.Box3().setFromObject(allMeshes);
            center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            maxDim = Math.max(size.x, size.y, size.z);

            camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
            controls.target.copy(center);
            controls.update();

            loading.style.display = 'none';
            document.getElementById('stats').innerHTML = '<br>' + meshCount + ' elementos<br>' + snapPoints.length + ' puntos snap';

            // ========== SNAP POINTS GENERATION ==========
            function generateSnapPointsFromMesh(mesh) {
                const meshBox = new THREE.Box3().setFromObject(mesh);
                const min = meshBox.min;
                const max = meshBox.max;
                const cen = meshBox.getCenter(new THREE.Vector3());

                // 8 corners (endpoints)
                snapPoints.push({ pos: new THREE.Vector3(min.x, min.y, min.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, min.y, min.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, max.y, min.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, max.y, min.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, min.y, max.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, min.y, max.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, max.y, max.z), type: 'endpoint', label: 'Esquina' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, max.y, max.z), type: 'endpoint', label: 'Esquina' });

                // 12 edge midpoints
                snapPoints.push({ pos: new THREE.Vector3((min.x+max.x)/2, min.y, min.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3((min.x+max.x)/2, max.y, min.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3((min.x+max.x)/2, min.y, max.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3((min.x+max.x)/2, max.y, max.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, (min.y+max.y)/2, min.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, (min.y+max.y)/2, min.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, (min.y+max.y)/2, max.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, (min.y+max.y)/2, max.z), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, min.y, (min.z+max.z)/2), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, min.y, (min.z+max.z)/2), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(min.x, max.y, (min.z+max.z)/2), type: 'midpoint', label: 'Medio arista' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, max.y, (min.z+max.z)/2), type: 'midpoint', label: 'Medio arista' });

                // 6 face centers
                snapPoints.push({ pos: new THREE.Vector3(min.x, cen.y, cen.z), type: 'face', label: 'Centro cara' });
                snapPoints.push({ pos: new THREE.Vector3(max.x, cen.y, cen.z), type: 'face', label: 'Centro cara' });
                snapPoints.push({ pos: new THREE.Vector3(cen.x, min.y, cen.z), type: 'face', label: 'Centro cara' });
                snapPoints.push({ pos: new THREE.Vector3(cen.x, max.y, cen.z), type: 'face', label: 'Centro cara' });
                snapPoints.push({ pos: new THREE.Vector3(cen.x, cen.y, min.z), type: 'face', label: 'Centro cara' });
                snapPoints.push({ pos: new THREE.Vector3(cen.x, cen.y, max.z), type: 'face', label: 'Centro cara' });

                // Center
                snapPoints.push({ pos: cen.clone(), type: 'center', label: 'Centroide' });
            }

            // ========== SNAP DETECTION ==========
            function findSnapPoint(screenX, screenY, tolerance = 15) {
                const activeCam = currentView === '3d' ? camera : orthoCamera;
                let nearest = null;
                let minDist = tolerance;

                for (const sp of snapPoints) {
                    const screenPos = sp.pos.clone().project(activeCam);
                    if (screenPos.z > 1) continue; // Behind camera

                    const sx = (screenPos.x * 0.5 + 0.5) * container.clientWidth;
                    const sy = (-screenPos.y * 0.5 + 0.5) * container.clientHeight;

                    const dist = Math.sqrt((sx - screenX) ** 2 + (sy - screenY) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = { ...sp, screenX: sx, screenY: sy };
                    }
                }

                // Also check existing model nodes
                for (const node of model.nodes) {
                    const screenPos = node.pos.clone().project(activeCam);
                    if (screenPos.z > 1) continue;

                    const sx = (screenPos.x * 0.5 + 0.5) * container.clientWidth;
                    const sy = (-screenPos.y * 0.5 + 0.5) * container.clientHeight;

                    const dist = Math.sqrt((sx - screenX) ** 2 + (sy - screenY) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = { pos: node.pos, type: 'node', label: 'Nodo ' + node.id, screenX: sx, screenY: sy };
                    }
                }

                return nearest;
            }

            function showSnap(sp) {
                if (sp) {
                    snapIndicator.style.left = sp.screenX + 'px';
                    snapIndicator.style.top = sp.screenY + 'px';
                    snapMarker.className = 'snap-marker ' + sp.type;
                    snapLabelEl.textContent = sp.label;
                    snapIndicator.classList.add('visible');
                    currentSnapPoint = sp;
                } else {
                    snapIndicator.classList.remove('visible');
                    currentSnapPoint = null;
                }
            }

            // ========== DRAWING ==========
            function startDrawMode() {
                drawMode = true;
                drawStep = 0;
                point1 = null;
                point2 = null;
                previewLine.visible = false;

                drawPanel.classList.add('visible');
                instructions.classList.add('visible');
                document.getElementById('btn-draw').classList.add('drawing');
                document.getElementById('btn-confirm').style.display = 'none';

                controls.enabled = true; // Allow pan/zoom but track clicks

                updateDrawStatus();
                autoGenerateName();
            }

            function stopDrawMode() {
                drawMode = false;
                drawStep = 0;
                point1 = null;
                point2 = null;
                previewLine.visible = false;

                drawPanel.classList.remove('visible');
                instructions.classList.remove('visible');
                document.getElementById('btn-draw').classList.remove('drawing');

                showSnap(null);
            }

            function updateDrawStatus() {
                const status = drawStatus;
                const p1el = document.getElementById('point1-coords');
                const p2el = document.getElementById('point2-coords');
                const lenEl = document.getElementById('line-length');

                if (drawStep === 0) {
                    status.textContent = 'Click para definir punto inicial';
                    status.className = 'draw-status waiting';
                    p1el.textContent = '---';
                    p2el.textContent = '---';
                    lenEl.textContent = '---';
                } else if (drawStep === 1) {
                    status.textContent = 'Click para definir punto final';
                    status.className = 'draw-status point1';
                    p1el.textContent = `(${point1.x.toFixed(3)}, ${point1.y.toFixed(3)}, ${point1.z.toFixed(3)})`;
                    p2el.textContent = '---';
                    lenEl.textContent = '---';
                } else if (drawStep === 2) {
                    status.textContent = 'Presiona Enter para confirmar';
                    status.className = 'draw-status point2';
                    p1el.textContent = `(${point1.x.toFixed(3)}, ${point1.y.toFixed(3)}, ${point1.z.toFixed(3)})`;
                    p2el.textContent = `(${point2.x.toFixed(3)}, ${point2.y.toFixed(3)}, ${point2.z.toFixed(3)})`;
                    const len = point1.distanceTo(point2);
                    lenEl.textContent = len.toFixed(3) + ' m';
                    document.getElementById('btn-confirm').style.display = 'block';
                }
            }

            function autoGenerateName() {
                const type = document.getElementById('member-type').value;
                const prefix = type === 'column' ? 'C' : type === 'beam' ? 'V' : 'B';
                document.getElementById('member-name').value = prefix + '-' + String(model.nextId).padStart(2, '0');
            }

            function updatePreviewLine(mousePos) {
                if (!drawMode || drawStep !== 1 || !point1) return;

                const target = currentSnapPoint ? currentSnapPoint.pos : mousePos;
                if (!target) return;

                const positions = new Float32Array([
                    point1.x, point1.y, point1.z,
                    target.x, target.y, target.z
                ]);
                previewLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                previewLine.geometry.computeBoundingSphere();
                previewLine.computeLineDistances();
                previewLine.visible = true;
            }

            function handleClick(e) {
                if (!drawMode) return;

                const pos = currentSnapPoint ? currentSnapPoint.pos : null;
                if (!pos) return; // Require snap

                if (drawStep === 0) {
                    point1 = pos.clone();
                    drawStep = 1;
                } else if (drawStep === 1) {
                    point2 = pos.clone();
                    drawStep = 2;
                    previewLine.visible = false;
                }

                updateDrawStatus();
            }

            function confirmMember() {
                if (drawStep !== 2 || !point1 || !point2) return;

                const name = document.getElementById('member-name').value || 'M-' + model.nextId;
                const type = document.getElementById('member-type').value;
                const section = document.getElementById('section-name').value || 'Generic';
                const color = colors[type] || 0xffffff;
                const length = point1.distanceTo(point2);

                // Find or create nodes
                const node1 = findOrCreateNode(point1);
                const node2 = findOrCreateNode(point2);

                // Create visual
                const tubeGeom = new THREE.CylinderGeometry(0.08, 0.08, length, 8);
                const tubeMat = new THREE.MeshBasicMaterial({ color });
                const tube = new THREE.Mesh(tubeGeom, tubeMat);

                const midPoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
                tube.position.copy(midPoint);

                const direction = new THREE.Vector3().subVectors(point2, point1).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                tube.quaternion.setFromUnitVectors(up, direction);

                // Node spheres
                const nodeMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });
                const nodeGeom = new THREE.SphereGeometry(0.12, 12, 12);

                const sphere1 = new THREE.Mesh(nodeGeom, nodeMat);
                sphere1.position.copy(point1);
                const sphere2 = new THREE.Mesh(nodeGeom, nodeMat);
                sphere2.position.copy(point2);

                const group = new THREE.Group();
                group.add(tube, sphere1, sphere2);
                analyticGroup.add(group);

                // Store
                model.members.push({
                    id: model.nextId++,
                    name, type, section, length,
                    node1: node1.id,
                    node2: node2.id,
                    color,
                    group
                });

                node1.members.push(model.members[model.members.length - 1].id);
                node2.members.push(model.members[model.members.length - 1].id);

                updateModelPanel();

                // Reset for next
                drawStep = 0;
                point1 = null;
                point2 = null;
                autoGenerateName();
                updateDrawStatus();
            }

            function findOrCreateNode(pos, tol = 0.01) {
                for (const node of model.nodes) {
                    if (node.pos.distanceTo(pos) < tol) return node;
                }
                const newNode = { id: model.nextNodeId++, pos: pos.clone(), members: [] };
                model.nodes.push(newNode);
                return newNode;
            }

            function updateModelPanel() {
                document.getElementById('stat-members').textContent = model.members.length;
                document.getElementById('stat-nodes').textContent = model.nodes.length;
                const total = model.members.reduce((s, m) => s + m.length, 0);
                document.getElementById('stat-length').textContent = total.toFixed(2) + ' m';

                const list = document.getElementById('members-list');
                list.innerHTML = '';
                model.members.forEach((m, i) => {
                    const item = document.createElement('div');
                    item.className = 'member-item';
                    item.innerHTML = `
                        <div class="member-color" style="background:#${m.color.toString(16).padStart(6,'0')}"></div>
                        <div class="member-info">
                            <div class="member-name">${m.name}</div>
                            <div class="member-length">${m.section} | L=${m.length.toFixed(3)}m</div>
                        </div>
                        <button class="member-del" data-i="${i}">×</button>
                    `;
                    item.querySelector('.member-del').onclick = (e) => {
                        e.stopPropagation();
                        deleteMember(i);
                    };
                    list.appendChild(item);
                });
            }

            function deleteMember(index) {
                const m = model.members[index];
                analyticGroup.remove(m.group);
                model.members.splice(index, 1);
                // Clean orphan nodes
                model.nodes = model.nodes.filter(n => {
                    n.members = n.members.filter(id => model.members.some(m => m.id === id));
                    return n.members.length > 0;
                });
                updateModelPanel();
            }

            function clearModel() {
                while (analyticGroup.children.length) analyticGroup.remove(analyticGroup.children[0]);
                model = { members: [], nodes: [], nextId: 1, nextNodeId: 1 };
                updateModelPanel();
            }

            // ========== EXPORT ==========
            function exportModel() {
                const data = {
                    nodes: model.nodes.map(n => ({ id: n.id, x: n.pos.x, y: n.pos.y, z: n.pos.z })),
                    members: model.members.map(m => ({
                        id: m.id, name: m.name, type: m.type, section: m.section,
                        node1: m.node1, node2: m.node2, length: m.length
                    }))
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'modelo_analitico.json';
                a.click();
            }

            // ========== VIEWS ==========
            function setView(v) {
                currentView = v;
                document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
                const d = maxDim * 2;

                switch(v) {
                    case '3d':
                        document.getElementById('btn-3d').classList.add('active');
                        controls.object = camera;
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.enableRotate = true;
                        break;
                    case 'top':
                        document.getElementById('btn-top').classList.add('active');
                        updateOrtho(d);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y + d, center.z);
                        orthoCamera.up.set(0, 0, -1);
                        controls.enableRotate = false;
                        break;
                    case 'front':
                        document.getElementById('btn-front').classList.add('active');
                        updateOrtho(d);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y, center.z + d);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                    case 'right':
                        document.getElementById('btn-right').classList.add('active');
                        updateOrtho(d);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x + d, center.y, center.z);
                        orthoCamera.up.set(0, 1, 0);
                        controls.enableRotate = false;
                        break;
                }
                controls.target.copy(center);
                controls.update();
                if (drawMode) document.getElementById('btn-draw').classList.add('drawing');
            }

            function updateOrtho(s) {
                const a = container.clientWidth / container.clientHeight;
                orthoCamera.left = -s * a;
                orthoCamera.right = s * a;
                orthoCamera.top = s;
                orthoCamera.bottom = -s;
                orthoCamera.updateProjectionMatrix();
            }

            // ========== EVENTS ==========
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                mouse.x = (x / rect.width) * 2 - 1;
                mouse.y = -(y / rect.height) * 2 + 1;

                const activeCam = currentView === '3d' ? camera : orthoCamera;
                raycaster.setFromCamera(mouse, activeCam);

                const pt = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, pt);

                if (pt) {
                    document.getElementById('coord-x').textContent = pt.x.toFixed(2);
                    document.getElementById('coord-y').textContent = pt.y.toFixed(2);
                    document.getElementById('coord-z').textContent = pt.z.toFixed(2);
                }

                // Snap
                const sp = findSnapPoint(x, y);
                showSnap(sp);

                // Preview line
                if (drawMode && drawStep === 1) {
                    updatePreviewLine(pt);
                }
            });

            canvas.addEventListener('click', handleClick);

            document.getElementById('btn-3d').onclick = () => setView('3d');
            document.getElementById('btn-top').onclick = () => setView('top');
            document.getElementById('btn-front').onclick = () => setView('front');
            document.getElementById('btn-right').onclick = () => setView('right');

            document.getElementById('btn-fit').onclick = () => {
                camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                controls.target.copy(center);
                controls.update();
            };

            document.getElementById('btn-draw').onclick = () => {
                if (drawMode) stopDrawMode();
                else startDrawMode();
            };

            document.getElementById('btn-model').onclick = function() {
                this.classList.toggle('active');
                modelPanel.classList.toggle('visible');
            };

            document.getElementById('btn-confirm').onclick = confirmMember;
            document.getElementById('btn-cancel').onclick = stopDrawMode;
            document.getElementById('btn-clear').onclick = clearModel;
            document.getElementById('btn-export').onclick = exportModel;

            document.getElementById('member-type').onchange = autoGenerateName;

            document.getElementById('show-physical').onchange = (e) => { allMeshes.visible = e.target.checked; };
            document.getElementById('show-analytic').onchange = (e) => { analyticGroup.visible = e.target.checked; };

            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case '1': setView('3d'); break;
                    case '2': setView('top'); break;
                    case '3': setView('front'); break;
                    case '4': setView('right'); break;
                    case 'f': case 'F':
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.target.copy(center);
                        controls.update();
                        break;
                    case 'd': case 'D':
                        if (drawMode) stopDrawMode();
                        else startDrawMode();
                        break;
                    case 'm': case 'M':
                        document.getElementById('btn-model').click();
                        break;
                    case 'Enter':
                        if (drawMode && drawStep === 2) confirmMember();
                        break;
                    case 'Escape':
                        if (drawMode) {
                            if (drawStep > 0) {
                                drawStep = 0;
                                point1 = null;
                                point2 = null;
                                previewLine.visible = false;
                                updateDrawStatus();
                            } else {
                                stopDrawMode();
                            }
                        }
                        break;
                }
            });

            window.addEventListener('resize', () => {
                const a = container.clientWidth / container.clientHeight;
                camera.aspect = a;
                camera.updateProjectionMatrix();
                updateOrtho(maxDim * 2);
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, currentView === '3d' ? camera : orthoCamera);
            }
            animate();

        } catch (err) {
            console.error(err);
            document.getElementById('status').textContent = 'Error: ' + err.message;
            document.getElementById('status').style.color = '#ff6b6b';
        }
    })();
    </script>
</body>
</html>
@{end html-ifc}
