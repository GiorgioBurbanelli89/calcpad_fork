"Test IFC con Vistas, Selección y Sección Transversal
@{html-ifc}
<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>IFC Viewer Avanzado</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #fff;
        }
        #viewer-container { width: 100%; height: 100%; position: relative; }
        #main-canvas { width: 100%; height: 100%; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ========== TOOLBAR ========== */
        .toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.9);
            padding: 6px 10px;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .toolbar button {
            background: #2d2d44;
            color: #fff;
            border: 1px solid #444;
            padding: 7px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .toolbar button:hover { background: #3d3d5c; border-color: #0078d4; }
        .toolbar button.active { background: #0078d4; border-color: #0078d4; }
        .toolbar button svg { width: 14px; height: 14px; }
        .toolbar-sep { width: 1px; background: #444; margin: 0 4px; }

        /* ========== PANELS ========== */
        .panel {
            position: absolute;
            background: rgba(0,0,0,0.92);
            padding: 12px;
            border-radius: 8px;
            font-size: 11px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            border: 1px solid #333;
        }
        .panel h4 {
            color: #0078d4;
            margin-bottom: 10px;
            font-size: 12px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        .panel-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            gap: 10px;
        }
        .panel-row .label { color: #888; }
        .panel-row .value { color: #fff; font-weight: 500; }

        /* Panel de Propiedades (derecha) */
        .props-panel {
            top: 60px;
            right: 10px;
            width: 280px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            display: none;
        }
        .props-panel.visible { display: block; }
        .props-panel .element-type {
            background: #0078d4;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            display: inline-block;
            margin-bottom: 8px;
        }
        .props-panel .element-name {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .props-section {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
        .props-section h5 {
            color: #0078d4;
            font-size: 11px;
            margin-bottom: 8px;
        }

        /* Panel de Sección Transversal */
        .section-view-panel {
            bottom: 10px;
            right: 10px;
            width: 250px;
            height: 250px;
            display: none;
        }
        .section-view-panel.visible { display: block; }
        .section-view-panel canvas {
            width: 100%;
            height: calc(100% - 30px);
            background: #111;
            border-radius: 4px;
        }
        .section-view-panel .section-info {
            margin-top: 8px;
            text-align: center;
            color: #888;
            font-size: 10px;
        }

        /* Panel de Corte */
        .cut-panel {
            top: 60px;
            left: 10px;
            width: 200px;
            display: none;
        }
        .cut-panel.visible { display: block; }
        .cut-panel label { display: block; color: #888; margin-bottom: 3px; }
        .cut-panel input[type="range"] { width: 100%; margin-bottom: 8px; }
        .cut-panel .value-display { text-align: right; color: #fff; font-size: 10px; margin-top: -6px; margin-bottom: 8px; }
        .cut-panel button {
            width: 100%;
            padding: 6px;
            background: #444;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
        }
        .cut-panel button:hover { background: #555; }

        /* Info panel */
        .info-panel {
            bottom: 10px;
            left: 10px;
            max-width: 220px;
        }
        .info-panel strong { color: #0078d4; font-size: 13px; }
        .info-panel .hint { color: #666; margin-top: 8px; font-size: 10px; }

        /* Loading */
        .loading {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26,26,46,0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid #333; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; }
        .progress { width: 200px; height: 5px; background: #333; border-radius: 3px; margin-top: 15px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #0078d4, #00b4d8); width: 0%; transition: width 0.3s; }

        /* Highlight del elemento seleccionado */
        .selection-highlight {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="viewer-container">
        <canvas id="main-canvas"></canvas>

        <!-- TOOLBAR -->
        <div class="toolbar">
            <button id="btn-3d" class="active" title="Vista 3D (1)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                3D
            </button>
            <div class="toolbar-sep"></div>
            <button id="btn-top" title="Planta (2)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="12" cy="12" r="3"/></svg>
                Planta
            </button>
            <button id="btn-front" title="Frontal (3)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="5" width="18" height="14" rx="2"/><path d="M3 10h18"/></svg>
                Frontal
            </button>
            <button id="btn-right" title="Lateral (4)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M10 3v18"/></svg>
                Lateral
            </button>
            <div class="toolbar-sep"></div>
            <button id="btn-cut" title="Plano de Corte (C)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h16"/><path d="M12 4v16" stroke-dasharray="4 2"/></svg>
                Corte
            </button>
            <button id="btn-select" title="Modo Selección (S)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg>
                Selección
            </button>
            <div class="toolbar-sep"></div>
            <button id="btn-fit" title="Ajustar Vista (F)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
                Fit
            </button>
        </div>

        <!-- PANEL DE PROPIEDADES -->
        <div id="props-panel" class="panel props-panel">
            <h4>Elemento Seleccionado</h4>
            <div id="props-content">
                <p style="color: #666;">Click en un elemento para ver sus propiedades</p>
            </div>
        </div>

        <!-- PANEL DE SECCIÓN TRANSVERSAL -->
        <div id="section-view-panel" class="panel section-view-panel">
            <h4>Sección Transversal</h4>
            <canvas id="section-canvas"></canvas>
            <div class="section-info" id="section-info">Sin elemento seleccionado</div>
        </div>

        <!-- PANEL DE CORTE -->
        <div id="cut-panel" class="panel cut-panel">
            <h4>Plano de Corte</h4>
            <label>Eje X</label>
            <input type="range" id="cut-x" min="-100" max="100" value="100">
            <div class="value-display" id="cut-x-val">--</div>
            <label>Eje Y (Altura)</label>
            <input type="range" id="cut-y" min="-100" max="100" value="100">
            <div class="value-display" id="cut-y-val">--</div>
            <label>Eje Z</label>
            <input type="range" id="cut-z" min="-100" max="100" value="100">
            <div class="value-display" id="cut-z-val">--</div>
            <button id="btn-reset-cut">Resetear</button>
        </div>

        <!-- INFO -->
        <div class="panel info-panel">
            <strong>Silvia Cedeño.ifc</strong>
            <div id="stats"></div>
            <div class="hint">Click en elemento para seleccionar<br>Teclas: 1-4 vistas, F fit, S selección, C corte</div>
        </div>

        <!-- LOADING -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <p style="margin-top:15px;color:#888" id="status">Inicializando...</p>
        </div>
    </div>

    <script src="https://calcpad.ifc/three.min.js"></script>
    <script src="https://calcpad.ifc/OrbitControls.js"></script>
    <script src="https://calcpad.ifc/web-ifc-api-iife.js"></script>
    <script>
    (async function() {
        // ========== DOM ==========
        const canvas = document.getElementById('main-canvas');
        const container = document.getElementById('viewer-container');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const statsEl = document.getElementById('stats');
        const propsPanel = document.getElementById('props-panel');
        const propsContent = document.getElementById('props-content');
        const sectionPanel = document.getElementById('section-view-panel');
        const sectionCanvas = document.getElementById('section-canvas');
        const sectionInfo = document.getElementById('section-info');
        const cutPanel = document.getElementById('cut-panel');

        // ========== STATE ==========
        let scene, camera, orthoCamera, renderer, controls;
        let allMeshes, bbox, center, maxDim;
        let currentView = '3d';
        let selectMode = true;
        let cutEnabled = false;
        let selectedMesh = null;
        let originalMaterials = new Map();
        let ifcApi, modelID;
        let meshToExpressID = new Map();
        let expressIDToMesh = new Map();

        // Section view renderer
        let sectionRenderer, sectionScene, sectionCamera;

        function updateProgress(msg, pct) {
            status.textContent = msg;
            progress.style.width = pct + '%';
        }

        try {
            updateProgress('Inicializando Three.js...', 10);

            // ========== MAIN SCENE ==========
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            camera.position.set(50, 50, 50);

            const aspect = container.clientWidth / container.clientHeight;
            orthoCamera = new THREE.OrthographicCamera(-50*aspect, 50*aspect, 50, -50, 0.1, 10000);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.localClippingEnabled = true;

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(50, 100, 50);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
            light2.position.set(-50, 50, -50);
            scene.add(light2);

            // Grid
            scene.add(new THREE.GridHelper(200, 200, 0x444444, 0x333333));

            // ========== SECTION VIEW SCENE ==========
            sectionScene = new THREE.Scene();
            sectionScene.background = new THREE.Color(0x111111);
            sectionCamera = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 100);
            sectionCamera.position.set(0, 0, 10);

            sectionRenderer = new THREE.WebGLRenderer({ canvas: sectionCanvas, antialias: true });
            sectionRenderer.setSize(230, 200);

            // Lights for section view
            sectionScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const sLight = new THREE.DirectionalLight(0xffffff, 0.5);
            sLight.position.set(5, 5, 10);
            sectionScene.add(sLight);

            // ========== LOAD IFC ==========
            updateProgress('Descargando IFC...', 20);
            const response = await fetch('https://calcpad.ifc/temp_a7ce813c013e4fc48bd57558ccf7ebd6.ifc');
            if (!response.ok) throw new Error('Error: ' + response.status);

            updateProgress('Leyendo datos...', 40);
            const ifcData = await response.arrayBuffer();

            updateProgress('Inicializando web-ifc...', 50);
            ifcApi = new WebIFC.IfcAPI();
            await ifcApi.Init(p => p.endsWith('.wasm') ? 'https://calcpad.ifc/' + p : p);

            updateProgress('Parseando IFC...', 60);
            modelID = ifcApi.OpenModel(new Uint8Array(ifcData));

            updateProgress('Generando geometría...', 70);
            const flatMeshes = ifcApi.LoadAllGeometry(modelID);

            updateProgress('Construyendo mallas...', 80);
            allMeshes = new THREE.Group();
            let meshCount = 0, triCount = 0;

            for (let i = 0; i < flatMeshes.size(); i++) {
                const flatMesh = flatMeshes.get(i);
                const expressID = flatMesh.expressID;
                const geometries = flatMesh.geometries;

                for (let j = 0; j < geometries.size(); j++) {
                    const pg = geometries.get(j);
                    const geom = ifcApi.GetGeometry(modelID, pg.geometryExpressID);

                    const verts = ifcApi.GetVertexArray(geom.GetVertexData(), geom.GetVertexDataSize());
                    const indices = ifcApi.GetIndexArray(geom.GetIndexData(), geom.GetIndexDataSize());

                    if (verts.length === 0 || indices.length === 0) continue;

                    const positions = new Float32Array(verts.length / 2);
                    const normals = new Float32Array(verts.length / 2);

                    for (let k = 0; k < verts.length; k += 6) {
                        const idx = (k / 6) * 3;
                        positions[idx] = verts[k];
                        positions[idx + 1] = verts[k + 1];
                        positions[idx + 2] = verts[k + 2];
                        normals[idx] = verts[k + 3];
                        normals[idx + 1] = verts[k + 4];
                        normals[idx + 2] = verts[k + 5];
                    }

                    const bufferGeom = new THREE.BufferGeometry();
                    bufferGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    bufferGeom.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                    bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));
                    bufferGeom.computeBoundingBox();

                    const color = new THREE.Color(pg.color.x, pg.color.y, pg.color.z);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        side: THREE.DoubleSide,
                        transparent: pg.color.w < 1,
                        opacity: pg.color.w,
                        clippingPlanes: []
                    });

                    const mesh = new THREE.Mesh(bufferGeom, material);
                    mesh.userData.expressID = expressID;
                    mesh.userData.geometryExpressID = pg.geometryExpressID;
                    mesh.userData.originalColor = color.clone();

                    const matrix = new THREE.Matrix4().fromArray(pg.flatTransformation);
                    mesh.applyMatrix4(matrix);

                    allMeshes.add(mesh);
                    meshToExpressID.set(mesh.uuid, expressID);
                    if (!expressIDToMesh.has(expressID)) {
                        expressIDToMesh.set(expressID, []);
                    }
                    expressIDToMesh.get(expressID).push(mesh);

                    meshCount++;
                    triCount += indices.length / 3;
                }
            }

            scene.add(allMeshes);

            // ========== ADJUST VIEW ==========
            updateProgress('Ajustando vista...', 90);
            bbox = new THREE.Box3().setFromObject(allMeshes);
            center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            maxDim = Math.max(size.x, size.y, size.z);

            camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
            controls.target.copy(center);
            controls.update();

            // Setup cut sliders
            const cutX = document.getElementById('cut-x');
            const cutY = document.getElementById('cut-y');
            const cutZ = document.getElementById('cut-z');

            cutX.min = bbox.min.x.toFixed(0); cutX.max = bbox.max.x.toFixed(0); cutX.value = bbox.max.x.toFixed(0);
            cutY.min = bbox.min.y.toFixed(0); cutY.max = bbox.max.y.toFixed(0); cutY.value = bbox.max.y.toFixed(0);
            cutZ.min = bbox.min.z.toFixed(0); cutZ.max = bbox.max.z.toFixed(0); cutZ.value = bbox.max.z.toFixed(0);

            loading.style.display = 'none';
            statsEl.innerHTML = '<br>' + meshCount + ' elementos<br>' + Math.round(triCount/1000) + 'k triángulos';

            // ========== RAYCASTER ==========
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            canvas.addEventListener('click', (e) => {
                if (!selectMode) return;

                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                const activeCamera = currentView === '3d' ? camera : orthoCamera;
                raycaster.setFromCamera(mouse, activeCamera);

                const intersects = raycaster.intersectObjects(allMeshes.children, true);

                if (intersects.length > 0) {
                    selectElement(intersects[0].object);
                } else {
                    deselectElement();
                }
            });

            // ========== SELECTION FUNCTIONS ==========
            function selectElement(mesh) {
                // Deselect previous
                if (selectedMesh) {
                    const prevMeshes = expressIDToMesh.get(selectedMesh.userData.expressID) || [];
                    prevMeshes.forEach(m => {
                        if (m.material && m.userData.originalColor) {
                            m.material.color.copy(m.userData.originalColor);
                            m.material.emissive.setHex(0x000000);
                        }
                    });
                }

                selectedMesh = mesh;
                const expressID = mesh.userData.expressID;

                // Highlight all meshes with same expressID
                const meshes = expressIDToMesh.get(expressID) || [mesh];
                meshes.forEach(m => {
                    if (m.material) {
                        m.material.emissive.setHex(0x0044aa);
                    }
                });

                // Show properties panel
                propsPanel.classList.add('visible');
                sectionPanel.classList.add('visible');

                // Get IFC properties
                loadElementProperties(expressID);

                // Create section view
                createSectionView(mesh);
            }

            function deselectElement() {
                if (selectedMesh) {
                    const meshes = expressIDToMesh.get(selectedMesh.userData.expressID) || [];
                    meshes.forEach(m => {
                        if (m.material && m.userData.originalColor) {
                            m.material.color.copy(m.userData.originalColor);
                            m.material.emissive.setHex(0x000000);
                        }
                    });
                }
                selectedMesh = null;
                propsPanel.classList.remove('visible');
                sectionPanel.classList.remove('visible');
                propsContent.innerHTML = '<p style="color:#666">Click en un elemento</p>';
            }

            async function loadElementProperties(expressID) {
                try {
                    const element = ifcApi.GetLine(modelID, expressID);
                    const typeID = ifcApi.GetLineIDsWithType(modelID, element.type);

                    // Get type name
                    let typeName = 'Elemento';
                    const typeNames = {
                        [WebIFC.IFCWALL]: 'Muro',
                        [WebIFC.IFCWALLSTANDARDCASE]: 'Muro',
                        [WebIFC.IFCSLAB]: 'Losa',
                        [WebIFC.IFCBEAM]: 'Viga',
                        [WebIFC.IFCCOLUMN]: 'Columna',
                        [WebIFC.IFCDOOR]: 'Puerta',
                        [WebIFC.IFCWINDOW]: 'Ventana',
                        [WebIFC.IFCSTAIR]: 'Escalera',
                        [WebIFC.IFCROOF]: 'Techo',
                        [WebIFC.IFCFOOTING]: 'Cimentación',
                        [WebIFC.IFCPLATE]: 'Placa',
                        [WebIFC.IFCMEMBER]: 'Perfil',
                        [WebIFC.IFCRAILING]: 'Barandilla',
                        [WebIFC.IFCFURNISHINGELEMENT]: 'Mobiliario',
                        [WebIFC.IFCBUILDINGELEMENTPROXY]: 'Elemento'
                    };
                    typeName = typeNames[element.type] || 'Elemento';

                    // Get name
                    const name = element.Name ? element.Name.value : 'Sin nombre';
                    const globalId = element.GlobalId ? element.GlobalId.value : '--';
                    const description = element.Description ? element.Description.value : '--';

                    // Get dimensions from bounding box of selected meshes
                    const meshes = expressIDToMesh.get(expressID) || [];
                    let elementBBox = new THREE.Box3();
                    meshes.forEach(m => elementBBox.expandByObject(m));
                    const dims = elementBBox.getSize(new THREE.Vector3());

                    // Try to get material/profile info
                    let materialInfo = '--';
                    let profileInfo = '--';

                    // Get property sets
                    let properties = [];
                    try {
                        const psets = ifcApi.GetLine(modelID, expressID, true);
                        if (psets.IsDefinedBy) {
                            for (const rel of psets.IsDefinedBy) {
                                if (rel.RelatingPropertyDefinition) {
                                    const pset = rel.RelatingPropertyDefinition;
                                    if (pset.HasProperties) {
                                        for (const prop of pset.HasProperties) {
                                            if (prop.Name && prop.NominalValue) {
                                                properties.push({
                                                    name: prop.Name.value,
                                                    value: prop.NominalValue.value
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } catch (e) {}

                    // Build HTML
                    let html = `
                        <span class="element-type">${typeName.toUpperCase()}</span>
                        <div class="element-name">${name}</div>
                        <div class="panel-row"><span class="label">ID:</span><span class="value">${expressID}</span></div>
                        <div class="panel-row"><span class="label">GlobalId:</span><span class="value" style="font-size:9px">${globalId.substring(0,15)}...</span></div>

                        <div class="props-section">
                            <h5>Dimensiones</h5>
                            <div class="panel-row"><span class="label">Largo:</span><span class="value">${dims.x.toFixed(2)} m</span></div>
                            <div class="panel-row"><span class="label">Alto:</span><span class="value">${dims.y.toFixed(2)} m</span></div>
                            <div class="panel-row"><span class="label">Ancho:</span><span class="value">${dims.z.toFixed(2)} m</span></div>
                            <div class="panel-row"><span class="label">Volumen:</span><span class="value">${(dims.x * dims.y * dims.z).toFixed(3)} m³</span></div>
                        </div>
                    `;

                    if (properties.length > 0) {
                        html += `<div class="props-section"><h5>Propiedades</h5>`;
                        properties.slice(0, 8).forEach(p => {
                            html += `<div class="panel-row"><span class="label">${p.name}:</span><span class="value">${p.value}</span></div>`;
                        });
                        html += `</div>`;
                    }

                    propsContent.innerHTML = html;

                } catch (e) {
                    console.error('Error loading properties:', e);
                    propsContent.innerHTML = `
                        <div class="panel-row"><span class="label">ExpressID:</span><span class="value">${expressID}</span></div>
                        <p style="color:#666;margin-top:10px">No se pudieron cargar propiedades detalladas</p>
                    `;
                }
            }

            function createSectionView(mesh) {
                // Clear previous
                while (sectionScene.children.length > 2) {
                    sectionScene.remove(sectionScene.children[sectionScene.children.length - 1]);
                }

                const expressID = mesh.userData.expressID;
                const meshes = expressIDToMesh.get(expressID) || [mesh];

                // Calculate combined bounding box
                let combinedBBox = new THREE.Box3();
                meshes.forEach(m => combinedBBox.expandByObject(m));

                const sectionCenter = combinedBBox.getCenter(new THREE.Vector3());
                const sectionSize = combinedBBox.getSize(new THREE.Vector3());

                // Determine the best section plane based on geometry
                // For beams/columns: show cross-section perpendicular to longest axis
                // For walls/slabs: show thickness section

                let sectionNormal, sectionUp;
                const maxAxis = sectionSize.x > sectionSize.y ?
                    (sectionSize.x > sectionSize.z ? 'x' : 'z') :
                    (sectionSize.y > sectionSize.z ? 'y' : 'z');

                // Create a cloned geometry for section view
                const group = new THREE.Group();

                meshes.forEach(m => {
                    const clonedGeom = m.geometry.clone();
                    const clonedMat = new THREE.MeshPhongMaterial({
                        color: 0x4488ff,
                        side: THREE.DoubleSide,
                    });
                    const clonedMesh = new THREE.Mesh(clonedGeom, clonedMat);

                    // Apply same world transform
                    clonedMesh.matrix.copy(m.matrixWorld);
                    clonedMesh.matrixAutoUpdate = false;

                    group.add(clonedMesh);
                });

                // Center the group
                const groupBBox = new THREE.Box3().setFromObject(group);
                const groupCenter = groupBBox.getCenter(new THREE.Vector3());
                group.position.sub(groupCenter);

                // Add edges for clarity
                meshes.forEach(m => {
                    const edges = new THREE.EdgesGeometry(m.geometry, 30);
                    const line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x00ff88, linewidth: 2 })
                    );
                    line.matrix.copy(m.matrixWorld);
                    line.matrixAutoUpdate = false;
                    line.position.sub(groupCenter);
                    group.add(line);
                });

                sectionScene.add(group);

                // Adjust camera to fit
                const viewSize = Math.max(sectionSize.x, sectionSize.y, sectionSize.z) * 1.5;
                sectionCamera.left = -viewSize;
                sectionCamera.right = viewSize;
                sectionCamera.top = viewSize;
                sectionCamera.bottom = -viewSize;
                sectionCamera.updateProjectionMatrix();

                // Position camera based on longest axis
                if (maxAxis === 'x') {
                    sectionCamera.position.set(viewSize * 2, 0, 0);
                    sectionInfo.textContent = `Sección YZ | ${sectionSize.y.toFixed(2)} x ${sectionSize.z.toFixed(2)} m`;
                } else if (maxAxis === 'y') {
                    sectionCamera.position.set(0, viewSize * 2, 0);
                    sectionInfo.textContent = `Sección XZ | ${sectionSize.x.toFixed(2)} x ${sectionSize.z.toFixed(2)} m`;
                } else {
                    sectionCamera.position.set(0, 0, viewSize * 2);
                    sectionInfo.textContent = `Sección XY | ${sectionSize.x.toFixed(2)} x ${sectionSize.y.toFixed(2)} m`;
                }
                sectionCamera.lookAt(0, 0, 0);
            }

            // ========== VIEW FUNCTIONS ==========
            function setView(view) {
                currentView = view;
                document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));

                const dist = maxDim * 2;

                switch(view) {
                    case '3d':
                        document.getElementById('btn-3d').classList.add('active');
                        controls.object = camera;
                        camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                        controls.target.copy(center);
                        controls.enableRotate = true;
                        break;
                    case 'top':
                        document.getElementById('btn-top').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y + dist, center.z);
                        orthoCamera.up.set(0, 0, -1);
                        controls.target.copy(center);
                        controls.enableRotate = false;
                        break;
                    case 'front':
                        document.getElementById('btn-front').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x, center.y, center.z + dist);
                        orthoCamera.up.set(0, 1, 0);
                        controls.target.copy(center);
                        controls.enableRotate = false;
                        break;
                    case 'right':
                        document.getElementById('btn-right').classList.add('active');
                        updateOrtho(dist);
                        controls.object = orthoCamera;
                        orthoCamera.position.set(center.x + dist, center.y, center.z);
                        orthoCamera.up.set(0, 1, 0);
                        controls.target.copy(center);
                        controls.enableRotate = false;
                        break;
                }
                controls.update();
                if (selectMode) document.getElementById('btn-select').classList.add('active');
            }

            function updateOrtho(size) {
                const aspect = container.clientWidth / container.clientHeight;
                orthoCamera.left = -size * aspect;
                orthoCamera.right = size * aspect;
                orthoCamera.top = size;
                orthoCamera.bottom = -size;
                orthoCamera.updateProjectionMatrix();
            }

            function fitView() {
                if (currentView === '3d') {
                    camera.position.set(center.x + maxDim, center.y + maxDim * 0.7, center.z + maxDim);
                } else {
                    setView(currentView);
                }
                controls.target.copy(center);
                controls.update();
            }

            function updateClipping() {
                const planes = [];
                if (cutEnabled) {
                    const x = parseFloat(cutX.value);
                    const y = parseFloat(cutY.value);
                    const z = parseFloat(cutZ.value);

                    if (x < bbox.max.x - 0.1) planes.push(new THREE.Plane(new THREE.Vector3(-1,0,0), x));
                    if (y < bbox.max.y - 0.1) planes.push(new THREE.Plane(new THREE.Vector3(0,-1,0), y));
                    if (z < bbox.max.z - 0.1) planes.push(new THREE.Plane(new THREE.Vector3(0,0,-1), z));

                    document.getElementById('cut-x-val').textContent = x.toFixed(1) + ' m';
                    document.getElementById('cut-y-val').textContent = y.toFixed(1) + ' m';
                    document.getElementById('cut-z-val').textContent = z.toFixed(1) + ' m';
                }

                allMeshes.traverse(obj => {
                    if (obj.isMesh && obj.material) {
                        obj.material.clippingPlanes = planes;
                        obj.material.needsUpdate = true;
                    }
                });
            }

            // ========== EVENTS ==========
            document.getElementById('btn-3d').onclick = () => setView('3d');
            document.getElementById('btn-top').onclick = () => setView('top');
            document.getElementById('btn-front').onclick = () => setView('front');
            document.getElementById('btn-right').onclick = () => setView('right');
            document.getElementById('btn-fit').onclick = fitView;

            document.getElementById('btn-select').onclick = function() {
                selectMode = !selectMode;
                this.classList.toggle('active', selectMode);
                if (!selectMode) deselectElement();
            };

            document.getElementById('btn-cut').onclick = function() {
                cutEnabled = !cutEnabled;
                this.classList.toggle('active', cutEnabled);
                cutPanel.classList.toggle('visible', cutEnabled);
                updateClipping();
            };

            document.getElementById('btn-reset-cut').onclick = () => {
                cutX.value = bbox.max.x;
                cutY.value = bbox.max.y;
                cutZ.value = bbox.max.z;
                updateClipping();
            };

            cutX.oninput = updateClipping;
            cutY.oninput = updateClipping;
            cutZ.oninput = updateClipping;

            document.addEventListener('keydown', e => {
                switch(e.key.toLowerCase()) {
                    case 'f': fitView(); break;
                    case '1': setView('3d'); break;
                    case '2': setView('top'); break;
                    case '3': setView('front'); break;
                    case '4': setView('right'); break;
                    case 's':
                        document.getElementById('btn-select').click();
                        break;
                    case 'c':
                        document.getElementById('btn-cut').click();
                        break;
                    case 'escape':
                        deselectElement();
                        break;
                }
            });

            window.addEventListener('resize', () => {
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                updateOrtho(maxDim * 2);
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // ========== ANIMATION ==========
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                const activeCam = currentView === '3d' ? camera : orthoCamera;
                renderer.render(scene, activeCam);

                // Render section view if visible
                if (sectionPanel.classList.contains('visible')) {
                    sectionRenderer.render(sectionScene, sectionCamera);
                }
            }
            animate();

            // Initial state
            document.getElementById('btn-select').classList.add('active');

        } catch (err) {
            console.error(err);
            status.textContent = 'Error: ' + err.message;
            status.style.color = '#ff6b6b';
        }
    })();
    </script>
</body>
</html>
@{end html-ifc}
