"Test: Color Map FEM con bloques separados
'Usando @{html}, @{css}, @{ts} como en awatif-ui

"1. Datos del analisis FEM
'Malla simple de 4 nodos y 2 triangulos:
nodos = 4
elementos = 2
'Valores de desplazamiento nodal:
v_min = 0
v_max = 10

"2. Estilos CSS para la leyenda
@{css}
#legend {
    width: 20px;
    height: 200px;
    background: linear-gradient(
        #ff0000,
        #ffff00 20%,
        #00ff00 50%,
        #00ffff 80%,
        #0000ff
    );
    position: absolute;
    right: 50px;
    top: 100px;
    z-index: 2;
}

#legend .marker {
    width: 10px;
    height: 1px;
    margin-left: 20px;
    background: white;
    position: relative;
}

#legend .marker p {
    position: absolute;
    color: white;
    font-size: 12px;
    top: -7px;
    left: 15px;
    margin: 0px;
    font-family: monospace;
}

#container {
    width: 100%;
    height: 400px;
    background: #1a1a2e;
}

#info {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: Arial;
    font-size: 14px;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 5px;
}
@{end css}

"3. Codigo TypeScript para Color Map
@{ts}
// Color Map FEM - TypeScript version
// Basado en awatif-ui/color-map

const nodes: number[][] = [
    [0, 0, 0],
    [5, 0, 0],
    [5, 0, 5],
    [0, 0, 5]
];

const elements: number[][] = [
    [0, 1, 2],
    [0, 2, 3]
];

const values: number[] = [0, 2.5, 10, 5];

// Calcular min/max
const minVal = Math.min(...values);
const maxVal = Math.max(...values);

console.log("=== Color Map FEM ===");
console.log(`Nodos: ${nodes.length}`);
console.log(`Elementos: ${elements.length}`);
console.log(`Valor min: ${minVal}`);
console.log(`Valor max: ${maxVal}`);

// Funcion para interpolar color (rainbow)
function getColor(value: number): string {
    const t = (value - minVal) / (maxVal - minVal);

    let r: number, g: number, b: number;

    if (t < 0.25) {
        r = 0; g = t * 4; b = 1;
    } else if (t < 0.5) {
        r = 0; g = 1; b = 1 - (t - 0.25) * 4;
    } else if (t < 0.75) {
        r = (t - 0.5) * 4; g = 1; b = 0;
    } else {
        r = 1; g = 1 - (t - 0.75) * 4; b = 0;
    }

    return `rgb(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)})`;
}

console.log("\nColores por nodo:");
values.forEach((v, i) => {
    console.log(`  Nodo ${i}: valor=${v.toFixed(1)}, color=${getColor(v)}`);
});
@{end ts}

"4. HTML con Three.js Viewer (Embebido)
@{html:embed}
<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; }
        #container { width: 100%; height: 400px; }
        #legend {
            width: 20px;
            height: 200px;
            background: linear-gradient(#ff0000, #ffff00 20%, #00ff00 50%, #00ffff 80%, #0000ff);
            position: absolute;
            right: 50px;
            top: 100px;
            z-index: 2;
        }
        #legend .marker {
            width: 10px;
            height: 1px;
            margin-left: 20px;
            background: white;
            position: relative;
        }
        #legend .marker p {
            position: absolute;
            color: white;
            font-size: 12px;
            top: -7px;
            left: 15px;
            margin: 0;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="legend">
        <div class="marker" style="margin-top:0"><p>10.0</p></div>
        <div class="marker" style="margin-top:48px"><p>7.5</p></div>
        <div class="marker" style="margin-top:48px"><p>5.0</p></div>
        <div class="marker" style="margin-top:48px"><p>2.5</p></div>
        <div class="marker" style="margin-top:48px"><p>0.0</p></div>
    </div>
    <div id="info">
        <b>Color Map FEM</b><br>
        Nodos: 4<br>
        Elementos: 2<br>
        Min: 0.0 | Max: 10.0
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Lut } from 'three/addons/math/Lut.js';

        // Datos de la malla
        const nodes = [
            [0, 0, 0],
            [5, 0, 0],
            [5, 0, 5],
            [0, 0, 5]
        ];
        const elements = [
            [0, 1, 2],
            [0, 2, 3]
        ];
        const values = [0, 2.5, 10, 5];

        // Setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(10, -15, 10);
        camera.up.set(0, 0, 1);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(2.5, 0, 2.5);
        controls.update();

        // Color Map usando LUT
        const lut = new Lut('rainbow', 512);
        lut.setMin(Math.min(...values));
        lut.setMax(Math.max(...values));

        // Crear geometria
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(nodes.flat());
        const indices = new Uint16Array(elements.flat());
        const colors = new Float32Array(nodes.length * 3);

        // Asignar colores basados en valores
        for (let i = 0; i < values.length; i++) {
            const color = lut.getColor(values[i]);
            colors[i * 3] = color.r * 0.8;
            colors[i * 3 + 1] = color.g * 0.8;
            colors[i * 3 + 2] = color.b * 0.8;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        geometry.computeVertexNormals();

        const material = new THREE.MeshBasicMaterial({
            vertexColors: true,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Wireframe
        const wireframe = new THREE.LineSegments(
            new THREE.WireframeGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
        );
        scene.add(wireframe);

        // Grid
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);

        // Axes
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
@{end html:embed}

'Fin del ejemplo con bloques separados
